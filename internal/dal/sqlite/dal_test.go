// Package sqlite provides sqlite-specific DAL tests
// Auto-generated by ForgeXML - do not edit manually
package sqlite

import (
	"context"
	"fmt"
	"testing"
	"time"

	parent "github.com/aequo-labs/forgexml-scap/internal/generated/dal"
)

// Silence unused import warnings
var _ = fmt.Sprintf
var _ = time.Now
var _ = context.Background

// Helper functions for creating pointer values
func stringPtr(s string) *string    { return &s }
func int64Ptr(i int64) *int64       { return &i }
func intPtr(i int) *int             { return &i }
func float64Ptr(f float64) *float64 { return &f }
func boolPtr(b bool) *bool          { return &b }
func timePtr(t time.Time) *time.Time { return &t }

// Entity factory functions for creating test data
// newRelationshipType creates a test RelationshipType entity with sample data
func newRelationshipType(suffix string) *parent.RelationshipType {
	return &parent.RelationshipType{
		Type: "test_type_" + suffix,
		Scope: stringPtr("test_" + suffix),
		Subject: "test_subject_" + suffix,
		Ref: "test_ref_" + suffix,
	}
}

// newElementMapType creates a test ElementMapType entity with sample data
func newElementMapType(suffix string) *parent.ElementMapType {
	return &parent.ElementMapType{
		TestID: int64Ptr(42),
		ObjectID: int64Ptr(42),
		StateID: int64Ptr(42),
		ItemID: int64Ptr(42),
	}
}

// newPGPDataType creates a test PGPDataType entity with sample data
func newPGPDataType(suffix string) *parent.PGPDataType {
	return &parent.PGPDataType{
		PGPKeyID: []byte("test_data_" + suffix),
	}
}

// newFactRefType creates a test FactRefType entity with sample data
func newFactRefType(suffix string) *parent.FactRefType {
	return &parent.FactRefType{
		Name: "test_name_" + suffix,
	}
}

// newCheckContentType creates a test CheckContentType entity with sample data
func newCheckContentType(suffix string) *parent.CheckContentType {
	return &parent.CheckContentType{
	}
}

// newTailoringBenchmarkReferenceType creates a test TailoringBenchmarkReferenceType entity with sample data
func newTailoringBenchmarkReferenceType(suffix string) *parent.TailoringBenchmarkReferenceType {
	return &parent.TailoringBenchmarkReferenceType{
		Version: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newUrlElementType creates a test UrlElementType entity with sample data
func newUrlElementType(suffix string) *parent.UrlElementType {
	return &parent.UrlElementType{
	}
}

// newOrganizationType creates a test OrganizationType entity with sample data
func newOrganizationType(suffix string) *parent.OrganizationType {
	return &parent.OrganizationType{
		ParentID: int64Ptr(42),
	}
}

// newObjectsType creates a test ObjectsType entity with sample data
func newObjectsType(suffix string) *parent.ObjectsType {
	return &parent.ObjectsType{
	}
}

// newEntityStateStringType creates a test EntityStateStringType entity with sample data
func newEntityStateStringType(suffix string) *parent.EntityStateStringType {
	return &parent.EntityStateStringType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newTailoringVersionType creates a test TailoringVersionType entity with sample data
func newTailoringVersionType(suffix string) *parent.TailoringVersionType {
	return &parent.TailoringVersionType{
		Time: time.Now(),
	}
}

// newXccdf12CheckType creates a test Xccdf12CheckType entity with sample data
func newXccdf12CheckType(suffix string) *parent.Xccdf12CheckType {
	return &parent.Xccdf12CheckType{
		System: "test_system_" + suffix,
		Negate: boolPtr(true),
		XsdId: stringPtr("test_" + suffix),
		Selector: stringPtr("test_" + suffix),
		MultiCheck: boolPtr(true),
		CheckContentID: int64Ptr(42),
	}
}

// newPostOfficeNameElementType creates a test PostOfficeNameElementType entity with sample data
func newPostOfficeNameElementType(suffix string) *parent.PostOfficeNameElementType {
	return &parent.PostOfficeNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newFunction creates a test Function entity with sample data
func newFunction(suffix string) *parent.Function {
	return &parent.Function{
		Code: stringPtr("test_" + suffix),
	}
}

// newCanonicalizationMethodType creates a test CanonicalizationMethodType entity with sample data
func newCanonicalizationMethodType(suffix string) *parent.CanonicalizationMethodType {
	return &parent.CanonicalizationMethodType{
		Algorithm: "test_algorithm_" + suffix,
	}
}

// newExternalVariableElementType creates a test ExternalVariableElementType entity with sample data
func newExternalVariableElementType(suffix string) *parent.ExternalVariableElementType {
	return &parent.ExternalVariableElementType{
		Possible_valueID: int64Ptr(42),
		Possible_restrictionID: int64Ptr(42),
		ParentID: int64Ptr(42),
	}
}

// newRegexCaptureFunctionType creates a test RegexCaptureFunctionType entity with sample data
func newRegexCaptureFunctionType(suffix string) *parent.RegexCaptureFunctionType {
	return &parent.RegexCaptureFunctionType{
		Pattern: stringPtr("test_" + suffix),
	}
}

// newTargetIdRefType creates a test TargetIdRefType entity with sample data
func newTargetIdRefType(suffix string) *parent.TargetIdRefType {
	return &parent.TargetIdRefType{
		System: "test_system_" + suffix,
		Href: "test_href_" + suffix,
		Name: stringPtr("test_" + suffix),
	}
}

// newDictionary20NotesType creates a test Dictionary20NotesType entity with sample data
func newDictionary20NotesType(suffix string) *parent.Dictionary20NotesType {
	return &parent.Dictionary20NotesType{
		Note: "test_note_" + suffix,
	}
}

// newReportRequestsElementType creates a test ReportRequestsElementType entity with sample data
func newReportRequestsElementType(suffix string) *parent.ReportRequestsElementType {
	return &parent.ReportRequestsElementType{
	}
}

// newServiceType creates a test ServiceType entity with sample data
func newServiceType(suffix string) *parent.ServiceType {
	return &parent.ServiceType{
		Host: stringPtr("test_" + suffix),
		Port: stringPtr("test_" + suffix),
		PortRange: stringPtr("test_" + suffix),
		Protocol: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newXccdf12TextType creates a test Xccdf12TextType entity with sample data
func newXccdf12TextType(suffix string) *parent.Xccdf12TextType {
	return &parent.Xccdf12TextType{
		Override: boolPtr(true),
	}
}

// newSelChoicesType creates a test SelChoicesType entity with sample data
func newSelChoicesType(suffix string) *parent.SelChoicesType {
	return &parent.SelChoicesType{
		MustMatch: boolPtr(true),
		Selector: stringPtr("test_" + suffix),
		Choice: "test_choice_" + suffix,
		ComplexChoiceID: int64Ptr(42),
	}
}

// newComplexValueType creates a test ComplexValueType entity with sample data
func newComplexValueType(suffix string) *parent.ComplexValueType {
	return &parent.ComplexValueType{
		Item: stringPtr("test_" + suffix),
	}
}

// newXccdf12MetadataType creates a test Xccdf12MetadataType entity with sample data
func newXccdf12MetadataType(suffix string) *parent.Xccdf12MetadataType {
	return &parent.Xccdf12MetadataType{
	}
}

// newCPE2idrefType creates a test CPE2idrefType entity with sample data
func newCPE2idrefType(suffix string) *parent.CPE2idrefType {
	return &parent.CPE2idrefType{
		Idref: "test_idref_" + suffix,
	}
}

// newWebsiteUrl creates a test WebsiteUrl entity with sample data
func newWebsiteUrl(suffix string) *parent.WebsiteUrl {
	return &parent.WebsiteUrl{
	}
}

// newLargeMailUserIdentifierElementType creates a test LargeMailUserIdentifierElementType entity with sample data
func newLargeMailUserIdentifierElementType(suffix string) *parent.LargeMailUserIdentifierElementType {
	return &parent.LargeMailUserIdentifierElementType{
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
	}
}

// newSupplementaryPostalServiceDataElementType creates a test SupplementaryPostalServiceDataElementType entity with sample data
func newSupplementaryPostalServiceDataElementType(suffix string) *parent.SupplementaryPostalServiceDataElementType {
	return &parent.SupplementaryPostalServiceDataElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostBoxNumberPrefixElementType creates a test PostBoxNumberPrefixElementType entity with sample data
func newPostBoxNumberPrefixElementType(suffix string) *parent.PostBoxNumberPrefixElementType {
	return &parent.PostBoxNumberPrefixElementType{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumberSuffix creates a test ThoroughfareNumberSuffix entity with sample data
func newThoroughfareNumberSuffix(suffix string) *parent.ThoroughfareNumberSuffix {
	return &parent.ThoroughfareNumberSuffix{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newGeneralSuffixElementType creates a test GeneralSuffixElementType entity with sample data
func newGeneralSuffixElementType(suffix string) *parent.GeneralSuffixElementType {
	return &parent.GeneralSuffixElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newNameLineType creates a test NameLineType entity with sample data
func newNameLineType(suffix string) *parent.NameLineType {
	return &parent.NameLineType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newCountFunctionType creates a test CountFunctionType entity with sample data
func newCountFunctionType(suffix string) *parent.CountFunctionType {
	return &parent.CountFunctionType{
	}
}

// newThoroughfareNameType creates a test ThoroughfareNameType entity with sample data
func newThoroughfareNameType(suffix string) *parent.ThoroughfareNameType {
	return &parent.ThoroughfareNameType{
		Type: stringPtr("test_" + suffix),
	}
}

// newFormerNameElementType creates a test FormerNameElementType entity with sample data
func newFormerNameElementType(suffix string) *parent.FormerNameElementType {
	return &parent.FormerNameElementType{
		ValidFrom: stringPtr("test_" + suffix),
		ValidTo: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newRelationshipsContainerType creates a test RelationshipsContainerType entity with sample data
func newRelationshipsContainerType(suffix string) *parent.RelationshipsContainerType {
	return &parent.RelationshipsContainerType{
		Relationships: stringPtr("test_" + suffix),
	}
}

// newNotesElementType creates a test NotesElementType entity with sample data
func newNotesElementType(suffix string) *parent.NotesElementType {
	return &parent.NotesElementType{
		Note: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newEntityObjectAnySimpleType creates a test EntityObjectAnySimpleType entity with sample data
func newEntityObjectAnySimpleType(suffix string) *parent.EntityObjectAnySimpleType {
	return &parent.EntityObjectAnySimpleType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newLocalVariableElementType creates a test LocalVariableElementType entity with sample data
func newLocalVariableElementType(suffix string) *parent.LocalVariableElementType {
	return &parent.LocalVariableElementType{
		ParentID: int64Ptr(42),
	}
}

// newTextWithSubType creates a test TextWithSubType entity with sample data
func newTextWithSubType(suffix string) *parent.TextWithSubType {
	return &parent.TextWithSubType{
		Override: boolPtr(true),
	}
}

// newObjectRefElementType creates a test ObjectRefElementType entity with sample data
func newObjectRefElementType(suffix string) *parent.ObjectRefElementType {
	return &parent.ObjectRefElementType{
		RefId: stringPtr("test_" + suffix),
	}
}

// newPremiseNumberRangeToElementType creates a test PremiseNumberRangeToElementType entity with sample data
func newPremiseNumberRangeToElementType(suffix string) *parent.PremiseNumberRangeToElementType {
	return &parent.PremiseNumberRangeToElementType{
	}
}

// newDependencyNameElementType creates a test DependencyNameElementType entity with sample data
func newDependencyNameElementType(suffix string) *parent.DependencyNameElementType {
	return &parent.DependencyNameElementType{
		DependencyType: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newGenerationIdentifierElementType creates a test GenerationIdentifierElementType entity with sample data
func newGenerationIdentifierElementType(suffix string) *parent.GenerationIdentifierElementType {
	return &parent.GenerationIdentifierElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newProfileSetComplexValueType creates a test ProfileSetComplexValueType entity with sample data
func newProfileSetComplexValueType(suffix string) *parent.ProfileSetComplexValueType {
	return &parent.ProfileSetComplexValueType{
		Idref: "test_idref_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newObjectRef creates a test ObjectRef entity with sample data
func newObjectRef(suffix string) *parent.ObjectRef {
	return &parent.ObjectRef{
		RefId: stringPtr("test_" + suffix),
	}
}

// newSystemNameElementType creates a test SystemNameElementType entity with sample data
func newSystemNameElementType(suffix string) *parent.SystemNameElementType {
	return &parent.SystemNameElementType{
	}
}

// newSubAdministrativeAreaElementType creates a test SubAdministrativeAreaElementType entity with sample data
func newSubAdministrativeAreaElementType(suffix string) *parent.SubAdministrativeAreaElementType {
	return &parent.SubAdministrativeAreaElementType{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		SubAdministrativeAreaName: stringPtr("test_" + suffix),
	}
}

// newJointPersonNameElementType creates a test JointPersonNameElementType entity with sample data
func newJointPersonNameElementType(suffix string) *parent.JointPersonNameElementType {
	return &parent.JointPersonNameElementType{
		JointNameConnector: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newEntityStateIPAddressType creates a test EntityStateIPAddressType entity with sample data
func newEntityStateIPAddressType(suffix string) *parent.EntityStateIPAddressType {
	return &parent.EntityStateIPAddressType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newAffectedType creates a test AffectedType entity with sample data
func newAffectedType(suffix string) *parent.AffectedType {
	return &parent.AffectedType{
		Family: "test_family_" + suffix,
		Platform: stringPtr("test_" + suffix),
		Product: stringPtr("test_" + suffix),
	}
}

// newReferencesType creates a test ReferencesType entity with sample data
func newReferencesType(suffix string) *parent.ReferencesType {
	return &parent.ReferencesType{
		Reference: "test_reference_" + suffix,
	}
}

// newWebsiteUrlElementType creates a test WebsiteUrlElementType entity with sample data
func newWebsiteUrlElementType(suffix string) *parent.WebsiteUrlElementType {
	return &parent.WebsiteUrlElementType{
	}
}

// newNetworkInterfaceType creates a test NetworkInterfaceType entity with sample data
func newNetworkInterfaceType(suffix string) *parent.NetworkInterfaceType {
	return &parent.NetworkInterfaceType{
		MacAddress: stringPtr("test_" + suffix),
		Url: stringPtr("test_" + suffix),
		SubnetMaskID: int64Ptr(42),
		DefaultRouteID: int64Ptr(42),
	}
}

// newAssetsType creates a test AssetsType entity with sample data
func newAssetsType(suffix string) *parent.AssetsType {
	return &parent.AssetsType{
		Asset: "test_asset_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newFqdn creates a test Fqdn entity with sample data
func newFqdn(suffix string) *parent.Fqdn {
	return &parent.Fqdn{
	}
}

// newNs09XmldsigObjectType creates a test Ns09XmldsigObjectType entity with sample data
func newNs09XmldsigObjectType(suffix string) *parent.Ns09XmldsigObjectType {
	return &parent.Ns09XmldsigObjectType{
		XsdId: stringPtr("test_" + suffix),
		MimeType: stringPtr("test_" + suffix),
		Encoding: stringPtr("test_" + suffix),
	}
}

// newWarningType creates a test WarningType entity with sample data
func newWarningType(suffix string) *parent.WarningType {
	return &parent.WarningType{
		Category: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newIdrefListType creates a test IdrefListType entity with sample data
func newIdrefListType(suffix string) *parent.IdrefListType {
	return &parent.IdrefListType{
	}
}

// newPortElementType creates a test PortElementType entity with sample data
func newPortElementType(suffix string) *parent.PortElementType {
	return &parent.PortElementType{
		ParentID: int64Ptr(42),
	}
}

// newPostalCodeNumberExtensionElementType creates a test PostalCodeNumberExtensionElementType entity with sample data
func newPostalCodeNumberExtensionElementType(suffix string) *parent.PostalCodeNumberExtensionElementType {
	return &parent.PostalCodeNumberExtensionElementType{
		Type: stringPtr("test_" + suffix),
		NumberExtensionSeparator: stringPtr("test_" + suffix),
	}
}

// newPostalCodeElementType creates a test PostalCodeElementType entity with sample data
func newPostalCodeElementType(suffix string) *parent.PostalCodeElementType {
	return &parent.PostalCodeElementType{
		Type: stringPtr("test_" + suffix),
		PostalCodeNumber: stringPtr("test_" + suffix),
		PostalCodeNumberExtension: stringPtr("test_" + suffix),
		PostTown: stringPtr("test_" + suffix),
	}
}

// newSignedInfoType creates a test SignedInfoType entity with sample data
func newSignedInfoType(suffix string) *parent.SignedInfoType {
	return &parent.SignedInfoType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newOvalDefinitionsElementType creates a test OvalDefinitionsElementType entity with sample data
func newOvalDefinitionsElementType(suffix string) *parent.OvalDefinitionsElementType {
	return &parent.OvalDefinitionsElementType{
		GeneratorID: int64Ptr(42),
		DefinitionsID: int64Ptr(42),
		TestsID: int64Ptr(42),
		ObjectsID: int64Ptr(42),
		StatesID: int64Ptr(42),
		VariablesID: int64Ptr(42),
	}
}

// newSelNumType creates a test SelNumType entity with sample data
func newSelNumType(suffix string) *parent.SelNumType {
	return &parent.SelNumType{
		Selector: stringPtr("test_" + suffix),
	}
}

// newCheckContentRefType creates a test CheckContentRefType entity with sample data
func newCheckContentRefType(suffix string) *parent.CheckContentRefType {
	return &parent.CheckContentRefType{
		Href: "test_href_" + suffix,
		Name: stringPtr("test_" + suffix),
	}
}

// newEmailAddressElementType creates a test EmailAddressElementType entity with sample data
func newEmailAddressElementType(suffix string) *parent.EmailAddressElementType {
	return &parent.EmailAddressElementType{
	}
}

// newAddressLinesType creates a test AddressLinesType entity with sample data
func newAddressLinesType(suffix string) *parent.AddressLinesType {
	return &parent.AddressLinesType{
	}
}

// newThoroughfareNumberToElementType creates a test ThoroughfareNumberToElementType entity with sample data
func newThoroughfareNumberToElementType(suffix string) *parent.ThoroughfareNumberToElementType {
	return &parent.ThoroughfareNumberToElementType{
	}
}

// newNameDetailsElementType creates a test NameDetailsElementType entity with sample data
func newNameDetailsElementType(suffix string) *parent.NameDetailsElementType {
	return &parent.NameDetailsElementType{
		NameDetailsKey: stringPtr("test_" + suffix),
		AddresseeIndicator: stringPtr("test_" + suffix),
		DependencyName: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newVariablesType creates a test VariablesType entity with sample data
func newVariablesType(suffix string) *parent.VariablesType {
	return &parent.VariablesType{
	}
}

// newSetElementType creates a test SetElementType entity with sample data
func newSetElementType(suffix string) *parent.SetElementType {
	return &parent.SetElementType{
		Set_operator: stringPtr("test_" + suffix),
	}
}

// newInstanceResultType creates a test InstanceResultType entity with sample data
func newInstanceResultType(suffix string) *parent.InstanceResultType {
	return &parent.InstanceResultType{
		Context: stringPtr("test_" + suffix),
		ParentContext: stringPtr("test_" + suffix),
	}
}

// newLocationPoint creates a test LocationPoint entity with sample data
func newLocationPoint(suffix string) *parent.LocationPoint {
	return &parent.LocationPoint{
		Latitude: "test_latitude_" + suffix,
		Longitude: "test_longitude_" + suffix,
		Elevation: float64Ptr(3.14),
		Radius: stringPtr("test_" + suffix),
	}
}

// newSubPremiseNumberPrefixElementType creates a test SubPremiseNumberPrefixElementType entity with sample data
func newSubPremiseNumberPrefixElementType(suffix string) *parent.SubPremiseNumberPrefixElementType {
	return &parent.SubPremiseNumberPrefixElementType{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newAddressDetails creates a test AddressDetails entity with sample data
func newAddressDetails(suffix string) *parent.AddressDetails {
	return &parent.AddressDetails{
		AddressType: stringPtr("test_" + suffix),
		CurrentStatus: stringPtr("test_" + suffix),
		ValidFromDate: stringPtr("test_" + suffix),
		ValidToDate: stringPtr("test_" + suffix),
		Usage: stringPtr("test_" + suffix),
		AddressDetailsKey: stringPtr("test_" + suffix),
		PostalServiceElements: stringPtr("test_" + suffix),
		Address: "test_address_" + suffix,
		AddressLinesID: int64Ptr(42),
		Country: "test_country_" + suffix,
	}
}

// newOasisNamesTcCiqXOrganisationNameDetails creates a test OasisNamesTcCiqXOrganisationNameDetails entity with sample data
func newOasisNamesTcCiqXOrganisationNameDetails(suffix string) *parent.OasisNamesTcCiqXOrganisationNameDetails {
	return &parent.OasisNamesTcCiqXOrganisationNameDetails{
		OrganisationFormerName: stringPtr("test_" + suffix),
		OrganisationKnownAs: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newAddresseeIndicatorElementType creates a test AddresseeIndicatorElementType entity with sample data
func newAddresseeIndicatorElementType(suffix string) *parent.AddresseeIndicatorElementType {
	return &parent.AddresseeIndicatorElementType{
		Code: stringPtr("test_" + suffix),
	}
}

// newXccdf12ValueType creates a test Xccdf12ValueType entity with sample data
func newXccdf12ValueType(suffix string) *parent.Xccdf12ValueType {
	return &parent.Xccdf12ValueType{
		XsdId: "test_xsdid_" + suffix,
		Type: stringPtr("test_" + suffix),
		Operator: stringPtr("test_" + suffix),
		Interactive: boolPtr(true),
		InterfaceHint: stringPtr("test_" + suffix),
		SignatureID: int64Ptr(42),
		ValueID: int64Ptr(42),
		ComplexValueID: int64Ptr(42),
		DefaultID: int64Ptr(42),
		ComplexDefaultID: int64Ptr(42),
		ParentID: int64Ptr(42),
	}
}

// newReferenceElementType creates a test ReferenceElementType entity with sample data
func newReferenceElementType(suffix string) *parent.ReferenceElementType {
	return &parent.ReferenceElementType{
		Href: stringPtr("test_" + suffix),
	}
}

// newSyntheticIdElementType creates a test SyntheticIdElementType entity with sample data
func newSyntheticIdElementType(suffix string) *parent.SyntheticIdElementType {
	return &parent.SyntheticIdElementType{
		Resource: "test_resource_" + suffix,
		XsdId: "test_xsdid_" + suffix,
	}
}

// newLocations creates a test Locations entity with sample data
func newLocations(suffix string) *parent.Locations {
	return &parent.Locations{
	}
}

// newThoroughfareLeadingTypeType creates a test ThoroughfareLeadingTypeType entity with sample data
func newThoroughfareLeadingTypeType(suffix string) *parent.ThoroughfareLeadingTypeType {
	return &parent.ThoroughfareLeadingTypeType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPremiseNumberPrefix creates a test PremiseNumberPrefix entity with sample data
func newPremiseNumberPrefix(suffix string) *parent.PremiseNumberPrefix {
	return &parent.PremiseNumberPrefix{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newXNLElementType creates a test XNLElementType entity with sample data
func newXNLElementType(suffix string) *parent.XNLElementType {
	return &parent.XNLElementType{
		Version: stringPtr("test_" + suffix),
	}
}

// newCriterionType creates a test CriterionType entity with sample data
func newCriterionType(suffix string) *parent.CriterionType {
	return &parent.CriterionType{
		Applicability_check: boolPtr(true),
		Test_ref: "test_test_ref_" + suffix,
		Negate: boolPtr(true),
		Comment: stringPtr("test_" + suffix),
	}
}

// newEntityStateIOSVersionType creates a test EntityStateIOSVersionType entity with sample data
func newEntityStateIOSVersionType(suffix string) *parent.EntityStateIOSVersionType {
	return &parent.EntityStateIOSVersionType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newEntityObjectBoolType creates a test EntityObjectBoolType entity with sample data
func newEntityObjectBoolType(suffix string) *parent.EntityObjectBoolType {
	return &parent.EntityObjectBoolType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newCountryNameCodeElementType creates a test CountryNameCodeElementType entity with sample data
func newCountryNameCodeElementType(suffix string) *parent.CountryNameCodeElementType {
	return &parent.CountryNameCodeElementType{
		Scheme: stringPtr("test_" + suffix),
	}
}

// newOrganisationNameDetailsElementType creates a test OrganisationNameDetailsElementType entity with sample data
func newOrganisationNameDetailsElementType(suffix string) *parent.OrganisationNameDetailsElementType {
	return &parent.OrganisationNameDetailsElementType{
		OrganisationFormerName: stringPtr("test_" + suffix),
		OrganisationKnownAs: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newEntityObjectVersionType creates a test EntityObjectVersionType entity with sample data
func newEntityObjectVersionType(suffix string) *parent.EntityObjectVersionType {
	return &parent.EntityObjectVersionType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newEntityStateBinaryType creates a test EntityStateBinaryType entity with sample data
func newEntityStateBinaryType(suffix string) *parent.EntityStateBinaryType {
	return &parent.EntityStateBinaryType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newAddressElementType creates a test AddressElementType entity with sample data
func newAddressElementType(suffix string) *parent.AddressElementType {
	return &parent.AddressElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostalRouteNameElementType creates a test PostalRouteNameElementType entity with sample data
func newPostalRouteNameElementType(suffix string) *parent.PostalRouteNameElementType {
	return &parent.PostalRouteNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newDependentThoroughfareElementType creates a test DependentThoroughfareElementType entity with sample data
func newDependentThoroughfareElementType(suffix string) *parent.DependentThoroughfareElementType {
	return &parent.DependentThoroughfareElementType{
		Type: stringPtr("test_" + suffix),
		ThoroughfarePreDirectionID: int64Ptr(42),
		ThoroughfareLeadingTypeID: int64Ptr(42),
		ThoroughfareTrailingTypeID: int64Ptr(42),
		ThoroughfarePostDirectionID: int64Ptr(42),
	}
}

// newLocality creates a test Locality entity with sample data
func newLocality(suffix string) *parent.Locality {
	return &parent.Locality{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		LocalityName: stringPtr("test_" + suffix),
		DependentLocalityID: int64Ptr(42),
		LargeMailUserID: int64Ptr(42),
		PostalRouteID: int64Ptr(42),
	}
}

// newOvalMitreOrgOvalGeneratorType creates a test OvalMitreOrgOvalGeneratorType entity with sample data
func newOvalMitreOrgOvalGeneratorType(suffix string) *parent.OvalMitreOrgOvalGeneratorType {
	return &parent.OvalMitreOrgOvalGeneratorType{
		Product_name: stringPtr("test_" + suffix),
		Product_version: stringPtr("test_" + suffix),
		Timestamp: time.Now(),
	}
}

// newDefinitionType creates a test DefinitionType entity with sample data
func newDefinitionType(suffix string) *parent.DefinitionType {
	return &parent.DefinitionType{
		XsdId: "test_xsdid_" + suffix,
		Version: 42,
		Class: "test_class_" + suffix,
		Deprecated: boolPtr(true),
		MetadataID: int64Ptr(42),
		CriteriaID: int64Ptr(42),
	}
}

// newEntityObjectFieldType creates a test EntityObjectFieldType entity with sample data
func newEntityObjectFieldType(suffix string) *parent.EntityObjectFieldType {
	return &parent.EntityObjectFieldType{
		Name: "test_name_" + suffix,
		Entity_check: stringPtr("test_" + suffix),
	}
}

// newTelephoneNumberElementType creates a test TelephoneNumberElementType entity with sample data
func newTelephoneNumberElementType(suffix string) *parent.TelephoneNumberElementType {
	return &parent.TelephoneNumberElementType{
		ParentID: int64Ptr(42),
	}
}

// newAssetIdentificationAssetElementType creates a test AssetIdentificationAssetElementType entity with sample data
func newAssetIdentificationAssetElementType(suffix string) *parent.AssetIdentificationAssetElementType {
	return &parent.AssetIdentificationAssetElementType{
		XsdId: "test_xsdid_" + suffix,
	}
}

// newSortingCodeElementType creates a test SortingCodeElementType entity with sample data
func newSortingCodeElementType(suffix string) *parent.SortingCodeElementType {
	return &parent.SortingCodeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newNs09XmldsigReferenceType creates a test Ns09XmldsigReferenceType entity with sample data
func newNs09XmldsigReferenceType(suffix string) *parent.Ns09XmldsigReferenceType {
	return &parent.Ns09XmldsigReferenceType{
		XsdId: stringPtr("test_" + suffix),
		URI: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newTailoringReferenceType creates a test TailoringReferenceType entity with sample data
func newTailoringReferenceType(suffix string) *parent.TailoringReferenceType {
	return &parent.TailoringReferenceType{
		Href: "test_href_" + suffix,
		XsdId: "test_xsdid_" + suffix,
		Version: "test_version_" + suffix,
		Time: time.Now(),
	}
}

// newConnectionsElementType creates a test ConnectionsElementType entity with sample data
func newConnectionsElementType(suffix string) *parent.ConnectionsElementType {
	return &parent.ConnectionsElementType{
	}
}

// newMotherboardGuidElementType creates a test MotherboardGuidElementType entity with sample data
func newMotherboardGuidElementType(suffix string) *parent.MotherboardGuidElementType {
	return &parent.MotherboardGuidElementType{
	}
}

// newDataType creates a test DataType entity with sample data
func newDataType(suffix string) *parent.DataType {
	return &parent.DataType{
		ParentID: int64Ptr(42),
	}
}

// newThoroughfareNumberSuffixElementType creates a test ThoroughfareNumberSuffixElementType entity with sample data
func newThoroughfareNumberSuffixElementType(suffix string) *parent.ThoroughfareNumberSuffixElementType {
	return &parent.ThoroughfareNumberSuffixElementType{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newThoroughfarePreDirectionType creates a test ThoroughfarePreDirectionType entity with sample data
func newThoroughfarePreDirectionType(suffix string) *parent.ThoroughfarePreDirectionType {
	return &parent.ThoroughfarePreDirectionType{
		Type: stringPtr("test_" + suffix),
	}
}

// newAddressLongitudeElementType creates a test AddressLongitudeElementType entity with sample data
func newAddressLongitudeElementType(suffix string) *parent.AddressLongitudeElementType {
	return &parent.AddressLongitudeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPrecedingTitleElementType creates a test PrecedingTitleElementType entity with sample data
func newPrecedingTitleElementType(suffix string) *parent.PrecedingTitleElementType {
	return &parent.PrecedingTitleElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newRSAKeyValueType creates a test RSAKeyValueType entity with sample data
func newRSAKeyValueType(suffix string) *parent.RSAKeyValueType {
	return &parent.RSAKeyValueType{
		ModulusID: int64Ptr(42),
		ExponentID: int64Ptr(42),
	}
}

// newDepartmentElementType creates a test DepartmentElementType entity with sample data
func newDepartmentElementType(suffix string) *parent.DepartmentElementType {
	return &parent.DepartmentElementType{
		Type: stringPtr("test_" + suffix),
		DepartmentName: stringPtr("test_" + suffix),
		MailStopID: int64Ptr(42),
	}
}

// newAddressLineElementType creates a test AddressLineElementType entity with sample data
func newAddressLineElementType(suffix string) *parent.AddressLineElementType {
	return &parent.AddressLineElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newMailStopNumberElementType creates a test MailStopNumberElementType entity with sample data
func newMailStopNumberElementType(suffix string) *parent.MailStopNumberElementType {
	return &parent.MailStopNumberElementType{
		NameNumberSeparator: stringPtr("test_" + suffix),
	}
}

// newOrganisationKnownAsElementType creates a test OrganisationKnownAsElementType entity with sample data
func newOrganisationKnownAsElementType(suffix string) *parent.OrganisationKnownAsElementType {
	return &parent.OrganisationKnownAsElementType{
		ValidFrom: stringPtr("test_" + suffix),
		ValidTo: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPlatformSpecification creates a test PlatformSpecification entity with sample data
func newPlatformSpecification(suffix string) *parent.PlatformSpecification {
	return &parent.PlatformSpecification{
	}
}

// newEntityObjectRecordType creates a test EntityObjectRecordType entity with sample data
func newEntityObjectRecordType(suffix string) *parent.EntityObjectRecordType {
	return &parent.EntityObjectRecordType{
		ParentID: int64Ptr(42),
	}
}

// newEntityObjectStringType creates a test EntityObjectStringType entity with sample data
func newEntityObjectStringType(suffix string) *parent.EntityObjectStringType {
	return &parent.EntityObjectStringType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newOverrideableCPE2idrefType creates a test OverrideableCPE2idrefType entity with sample data
func newOverrideableCPE2idrefType(suffix string) *parent.OverrideableCPE2idrefType {
	return &parent.OverrideableCPE2idrefType{
		Override: boolPtr(true),
		ParentID: int64Ptr(42),
	}
}

// newPersonType creates a test PersonType entity with sample data
func newPersonType(suffix string) *parent.PersonType {
	return &parent.PersonType{
		Birthdate: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newKeyLineCodeElementType creates a test KeyLineCodeElementType entity with sample data
func newKeyLineCodeElementType(suffix string) *parent.KeyLineCodeElementType {
	return &parent.KeyLineCodeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPremise creates a test Premise entity with sample data
func newPremise(suffix string) *parent.Premise {
	return &parent.Premise{
		Type: stringPtr("test_" + suffix),
		PremiseDependency: stringPtr("test_" + suffix),
		PremiseDependencyType: stringPtr("test_" + suffix),
		PremiseThoroughfareConnector: stringPtr("test_" + suffix),
		PremiseName: stringPtr("test_" + suffix),
		MailStopID: int64Ptr(42),
		PremiseLocation: "test_premiselocation_" + suffix,
		PremiseNumberRange: "test_premisenumberrange_" + suffix,
		FirmID: int64Ptr(42),
	}
}

// newX509DataType creates a test X509DataType entity with sample data
func newX509DataType(suffix string) *parent.X509DataType {
	return &parent.X509DataType{
		X509IssuerSerialID: int64Ptr(42),
		X509SKI: []byte("test_data_" + suffix),
		X509SubjectName: "test_x509subjectname_" + suffix,
		X509Certificate: []byte("test_data_" + suffix),
		X509CRL: []byte("test_data_" + suffix),
	}
}

// newVersionType creates a test VersionType entity with sample data
func newVersionType(suffix string) *parent.VersionType {
	return &parent.VersionType{
		Time: timePtr(time.Now()),
		Update: stringPtr("test_" + suffix),
	}
}

// newTailoringType creates a test TailoringType entity with sample data
func newTailoringType(suffix string) *parent.TailoringType {
	return &parent.TailoringType{
		XsdId: "test_xsdid_" + suffix,
		BenchmarkID: int64Ptr(42),
		VersionID: int64Ptr(42),
		SignatureID: int64Ptr(42),
	}
}

// newModel creates a test Model entity with sample data
func newModel(suffix string) *parent.Model {
	return &parent.Model{
		System: "test_system_" + suffix,
	}
}

// newAssetIdentificationType creates a test AssetIdentificationType entity with sample data
func newAssetIdentificationType(suffix string) *parent.AssetIdentificationType {
	return &parent.AssetIdentificationType{
		AssetRef: "test_assetref_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newThoroughfareNumberFromElementType creates a test ThoroughfareNumberFromElementType entity with sample data
func newThoroughfareNumberFromElementType(suffix string) *parent.ThoroughfareNumberFromElementType {
	return &parent.ThoroughfareNumberFromElementType{
	}
}

// newSubAdministrativeAreaNameElementType creates a test SubAdministrativeAreaNameElementType entity with sample data
func newSubAdministrativeAreaNameElementType(suffix string) *parent.SubAdministrativeAreaNameElementType {
	return &parent.SubAdministrativeAreaNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newSubPremiseLocationElementType creates a test SubPremiseLocationElementType entity with sample data
func newSubPremiseLocationElementType(suffix string) *parent.SubPremiseLocationElementType {
	return &parent.SubPremiseLocationElementType{
	}
}

// newAddressIdentifierElementType creates a test AddressIdentifierElementType entity with sample data
func newAddressIdentifierElementType(suffix string) *parent.AddressIdentifierElementType {
	return &parent.AddressIdentifierElementType{
		IdentifierType: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newAddressLatitudeElementType creates a test AddressLatitudeElementType entity with sample data
func newAddressLatitudeElementType(suffix string) *parent.AddressLatitudeElementType {
	return &parent.AddressLatitudeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newMiddleNameElementType creates a test MiddleNameElementType entity with sample data
func newMiddleNameElementType(suffix string) *parent.MiddleNameElementType {
	return &parent.MiddleNameElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newKeyInfoType creates a test KeyInfoType entity with sample data
func newKeyInfoType(suffix string) *parent.KeyInfoType {
	return &parent.KeyInfoType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newLargeMailUserNameElementType creates a test LargeMailUserNameElementType entity with sample data
func newLargeMailUserNameElementType(suffix string) *parent.LargeMailUserNameElementType {
	return &parent.LargeMailUserNameElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newThoroughfare creates a test Thoroughfare entity with sample data
func newThoroughfare(suffix string) *parent.Thoroughfare {
	return &parent.Thoroughfare{
		Type: stringPtr("test_" + suffix),
		DependentThoroughfares: stringPtr("test_" + suffix),
		DependentThoroughfaresIndicator: stringPtr("test_" + suffix),
		DependentThoroughfaresConnector: stringPtr("test_" + suffix),
		DependentThoroughfaresType: stringPtr("test_" + suffix),
		ThoroughfarePreDirectionID: int64Ptr(42),
		ThoroughfareLeadingTypeID: int64Ptr(42),
		ThoroughfareTrailingTypeID: int64Ptr(42),
		ThoroughfarePostDirectionID: int64Ptr(42),
		DependentThoroughfare: stringPtr("test_" + suffix),
		ThoroughfareNumberRange: "test_thoroughfarenumberrange_" + suffix,
		DependentLocalityID: int64Ptr(42),
		FirmID: int64Ptr(42),
	}
}

// newTitleElementType creates a test TitleElementType entity with sample data
func newTitleElementType(suffix string) *parent.TitleElementType {
	return &parent.TitleElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newDSAKeyValueType creates a test DSAKeyValueType entity with sample data
func newDSAKeyValueType(suffix string) *parent.DSAKeyValueType {
	return &parent.DSAKeyValueType{
		GID: int64Ptr(42),
		YID: int64Ptr(42),
		JID: int64Ptr(42),
		PID: int64Ptr(42),
		QID: int64Ptr(42),
		SeedID: int64Ptr(42),
		PgenCounterID: int64Ptr(42),
	}
}

// newOvalMitreOrgOvalMetadataType creates a test OvalMitreOrgOvalMetadataType entity with sample data
func newOvalMitreOrgOvalMetadataType(suffix string) *parent.OvalMitreOrgOvalMetadataType {
	return &parent.OvalMitreOrgOvalMetadataType{
		Title: "test_title_" + suffix,
		Description: "test_description_" + suffix,
	}
}

// newOvalMitreOrgOvalReferenceType creates a test OvalMitreOrgOvalReferenceType entity with sample data
func newOvalMitreOrgOvalReferenceType(suffix string) *parent.OvalMitreOrgOvalReferenceType {
	return &parent.OvalMitreOrgOvalReferenceType{
		Source: "test_source_" + suffix,
		Ref_id: "test_ref_id_" + suffix,
		Ref_url: stringPtr("test_" + suffix),
	}
}

// newRuleResultType creates a test RuleResultType entity with sample data
func newRuleResultType(suffix string) *parent.RuleResultType {
	return &parent.RuleResultType{
		Idref: "test_idref_" + suffix,
		Role: stringPtr("test_" + suffix),
		Severity: stringPtr("test_" + suffix),
		Time: timePtr(time.Now()),
		Version: stringPtr("test_" + suffix),
		Weight: stringPtr("test_" + suffix),
		ResultID: int64Ptr(42),
		ComplexCheckID: int64Ptr(42),
	}
}

// newDictionary20TextType creates a test Dictionary20TextType entity with sample data
func newDictionary20TextType(suffix string) *parent.Dictionary20TextType {
	return &parent.Dictionary20TextType{
	}
}

// newBarcodeElementType creates a test BarcodeElementType entity with sample data
func newBarcodeElementType(suffix string) *parent.BarcodeElementType {
	return &parent.BarcodeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newThoroughfarePostDirectionType creates a test ThoroughfarePostDirectionType entity with sample data
func newThoroughfarePostDirectionType(suffix string) *parent.ThoroughfarePostDirectionType {
	return &parent.ThoroughfarePostDirectionType{
		Type: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumber creates a test ThoroughfareNumber entity with sample data
func newThoroughfareNumber(suffix string) *parent.ThoroughfareNumber {
	return &parent.ThoroughfareNumber{
		NumberType: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberOccurrence: stringPtr("test_" + suffix),
	}
}

// newInstanceFixType creates a test InstanceFixType entity with sample data
func newInstanceFixType(suffix string) *parent.InstanceFixType {
	return &parent.InstanceFixType{
		Context: stringPtr("test_" + suffix),
	}
}

// newTitleEltType creates a test TitleEltType entity with sample data
func newTitleEltType(suffix string) *parent.TitleEltType {
	return &parent.TitleEltType{
	}
}

// newCircuitNameElementType creates a test CircuitNameElementType entity with sample data
func newCircuitNameElementType(suffix string) *parent.CircuitNameElementType {
	return &parent.CircuitNameElementType{
	}
}

// newThoroughfareElementType creates a test ThoroughfareElementType entity with sample data
func newThoroughfareElementType(suffix string) *parent.ThoroughfareElementType {
	return &parent.ThoroughfareElementType{
		Type: stringPtr("test_" + suffix),
		DependentThoroughfares: stringPtr("test_" + suffix),
		DependentThoroughfaresIndicator: stringPtr("test_" + suffix),
		DependentThoroughfaresConnector: stringPtr("test_" + suffix),
		DependentThoroughfaresType: stringPtr("test_" + suffix),
		ThoroughfarePreDirectionID: int64Ptr(42),
		ThoroughfareLeadingTypeID: int64Ptr(42),
		ThoroughfareTrailingTypeID: int64Ptr(42),
		ThoroughfarePostDirectionID: int64Ptr(42),
		DependentThoroughfare: stringPtr("test_" + suffix),
		ThoroughfareNumberRange: "test_thoroughfarenumberrange_" + suffix,
		DependentLocalityID: int64Ptr(42),
		FirmID: int64Ptr(42),
	}
}

// newFixTextType creates a test FixTextType entity with sample data
func newFixTextType(suffix string) *parent.FixTextType {
	return &parent.FixTextType{
		Fixref: stringPtr("test_" + suffix),
		Reboot: boolPtr(true),
		Strategy: stringPtr("test_" + suffix),
		Disruption: stringPtr("test_" + suffix),
		Complexity: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newIdentType creates a test IdentType entity with sample data
func newIdentType(suffix string) *parent.IdentType {
	return &parent.IdentType{
		System: "test_system_" + suffix,
	}
}

// newSelStringType creates a test SelStringType entity with sample data
func newSelStringType(suffix string) *parent.SelStringType {
	return &parent.SelStringType{
		Selector: stringPtr("test_" + suffix),
	}
}

// newDictionary20GeneratorType creates a test Dictionary20GeneratorType entity with sample data
func newDictionary20GeneratorType(suffix string) *parent.Dictionary20GeneratorType {
	return &parent.Dictionary20GeneratorType{
		Product_name: stringPtr("test_" + suffix),
		Product_version: stringPtr("test_" + suffix),
		Schema_version: "test_schema_version_" + suffix,
		Timestamp: time.Now(),
	}
}

// newDictionary20ItemType creates a test Dictionary20ItemType entity with sample data
func newDictionary20ItemType(suffix string) *parent.Dictionary20ItemType {
	return &parent.Dictionary20ItemType{
		Name: "test_name_" + suffix,
		Deprecated: boolPtr(true),
		Deprecated_by: stringPtr("test_" + suffix),
		Deprecation_date: timePtr(time.Now()),
		ReferencesID: int64Ptr(42),
	}
}

// newArcType creates a test ArcType entity with sample data
func newArcType(suffix string) *parent.ArcType {
	return &parent.ArcType{
	}
}

// newPortRangeElementType creates a test PortRangeElementType entity with sample data
func newPortRangeElementType(suffix string) *parent.PortRangeElementType {
	return &parent.PortRangeElementType{
		LowerBound: "test_lowerbound_" + suffix,
		UpperBound: "test_upperbound_" + suffix,
	}
}

// newCidrElementType creates a test CidrElementType entity with sample data
func newCidrElementType(suffix string) *parent.CidrElementType {
	return &parent.CidrElementType{
		ParentID: int64Ptr(42),
	}
}

// newPostBoxNumberExtensionElementType creates a test PostBoxNumberExtensionElementType entity with sample data
func newPostBoxNumberExtensionElementType(suffix string) *parent.PostBoxNumberExtensionElementType {
	return &parent.PostBoxNumberExtensionElementType{
		NumberExtensionSeparator: stringPtr("test_" + suffix),
	}
}

// newPremiseNumber creates a test PremiseNumber entity with sample data
func newPremiseNumber(suffix string) *parent.PremiseNumber {
	return &parent.PremiseNumber{
		NumberType: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberTypeOccurrence: stringPtr("test_" + suffix),
	}
}

// newBeginFunctionType creates a test BeginFunctionType entity with sample data
func newBeginFunctionType(suffix string) *parent.BeginFunctionType {
	return &parent.BeginFunctionType{
		Character: "test_character_" + suffix,
	}
}

// newEntityStateIPAddressStringType creates a test EntityStateIPAddressStringType entity with sample data
func newEntityStateIPAddressStringType(suffix string) *parent.EntityStateIPAddressStringType {
	return &parent.EntityStateIPAddressStringType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newMacAddressElementType creates a test MacAddressElementType entity with sample data
func newMacAddressElementType(suffix string) *parent.MacAddressElementType {
	return &parent.MacAddressElementType{
		ParentID: int64Ptr(42),
	}
}

// newDependentLocalityType creates a test DependentLocalityType entity with sample data
func newDependentLocalityType(suffix string) *parent.DependentLocalityType {
	return &parent.DependentLocalityType{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Connector: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		DependentLocalityName: stringPtr("test_" + suffix),
		DependentLocalityNumber: stringPtr("test_" + suffix),
		DependentLocalityID: int64Ptr(42),
		LargeMailUserID: int64Ptr(42),
		PostalRouteID: int64Ptr(42),
	}
}

// newSubPremiseType creates a test SubPremiseType entity with sample data
func newSubPremiseType(suffix string) *parent.SubPremiseType {
	return &parent.SubPremiseType{
		Type: stringPtr("test_" + suffix),
		SubPremiseName: stringPtr("test_" + suffix),
		SubPremiseNumberPrefix: stringPtr("test_" + suffix),
		SubPremiseNumberSuffix: stringPtr("test_" + suffix),
		FirmID: int64Ptr(42),
		MailStopID: int64Ptr(42),
		SubPremiseID: int64Ptr(42),
		SubPremiseLocation: "test_subpremiselocation_" + suffix,
		SubPremiseNumber: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumberRangeElementType creates a test ThoroughfareNumberRangeElementType entity with sample data
func newThoroughfareNumberRangeElementType(suffix string) *parent.ThoroughfareNumberRangeElementType {
	return &parent.ThoroughfareNumberRangeElementType{
		RangeType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		Separator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberRangeOccurrence: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		ThoroughfareNumberFrom: "test_thoroughfarenumberfrom_" + suffix,
		ThoroughfareNumberTo: "test_thoroughfarenumberto_" + suffix,
	}
}

// newLastNameElementType creates a test LastNameElementType entity with sample data
func newLastNameElementType(suffix string) *parent.LastNameElementType {
	return &parent.LastNameElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newObjectComponentType creates a test ObjectComponentType entity with sample data
func newObjectComponentType(suffix string) *parent.ObjectComponentType {
	return &parent.ObjectComponentType{
		Object_ref: "test_object_ref_" + suffix,
		Item_field: "test_item_field_" + suffix,
		Record_field: stringPtr("test_" + suffix),
	}
}

// newCriteriaType creates a test CriteriaType entity with sample data
func newCriteriaType(suffix string) *parent.CriteriaType {
	return &parent.CriteriaType{
		Applicability_check: boolPtr(true),
		Operator: stringPtr("test_" + suffix),
		Negate: boolPtr(true),
		Comment: stringPtr("test_" + suffix),
		CriteriaID: int64Ptr(42),
		CriterionID: int64Ptr(42),
		Extend_definitionID: int64Ptr(42),
	}
}

// newEntityStateRecordType creates a test EntityStateRecordType entity with sample data
func newEntityStateRecordType(suffix string) *parent.EntityStateRecordType {
	return &parent.EntityStateRecordType{
		ParentID: int64Ptr(42),
	}
}

// newInstanceNameElementType creates a test InstanceNameElementType entity with sample data
func newInstanceNameElementType(suffix string) *parent.InstanceNameElementType {
	return &parent.InstanceNameElementType{
	}
}

// newCountryElementType creates a test CountryElementType entity with sample data
func newCountryElementType(suffix string) *parent.CountryElementType {
	return &parent.CountryElementType{
		CountryNameCode: stringPtr("test_" + suffix),
	}
}

// newTransformsType creates a test TransformsType entity with sample data
func newTransformsType(suffix string) *parent.TransformsType {
	return &parent.TransformsType{
	}
}

// newSPKIDataType creates a test SPKIDataType entity with sample data
func newSPKIDataType(suffix string) *parent.SPKIDataType {
	return &parent.SPKIDataType{
		SPKISexp: []byte("test_data_" + suffix),
	}
}

// newStateType creates a test StateType entity with sample data
func newStateType(suffix string) *parent.StateType {
	return &parent.StateType{
		XsdId: "test_xsdid_" + suffix,
		Version: 42,
		Operator: stringPtr("test_" + suffix),
		Comment: stringPtr("test_" + suffix),
		Deprecated: boolPtr(true),
	}
}

// newStatesType creates a test StatesType entity with sample data
func newStatesType(suffix string) *parent.StatesType {
	return &parent.StatesType{
	}
}

// newPossibleValueType creates a test PossibleValueType entity with sample data
func newPossibleValueType(suffix string) *parent.PossibleValueType {
	return &parent.PossibleValueType{
		Hint: "test_hint_" + suffix,
	}
}

// newVariableComponentType creates a test VariableComponentType entity with sample data
func newVariableComponentType(suffix string) *parent.VariableComponentType {
	return &parent.VariableComponentType{
		Var_ref: "test_var_ref_" + suffix,
	}
}

// newEntityStateFileSetRevisionType creates a test EntityStateFileSetRevisionType entity with sample data
func newEntityStateFileSetRevisionType(suffix string) *parent.EntityStateFileSetRevisionType {
	return &parent.EntityStateFileSetRevisionType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newContentElementType1 creates a test ContentElementType1 entity with sample data
func newContentElementType1(suffix string) *parent.ContentElementType1 {
	return &parent.ContentElementType1{
	}
}

// newContentElementType creates a test ContentElementType entity with sample data
func newContentElementType(suffix string) *parent.ContentElementType {
	return &parent.ContentElementType{
		DataValidStartDate: timePtr(time.Now()),
		DataValidEndDate: timePtr(time.Now()),
	}
}

// newLocationRegionElementType creates a test LocationRegionElementType entity with sample data
func newLocationRegionElementType(suffix string) *parent.LocationRegionElementType {
	return &parent.LocationRegionElementType{
	}
}

// newPostTownElementType creates a test PostTownElementType entity with sample data
func newPostTownElementType(suffix string) *parent.PostTownElementType {
	return &parent.PostTownElementType{
		Type: stringPtr("test_" + suffix),
		PostTownName: stringPtr("test_" + suffix),
		PostTownSuffix: stringPtr("test_" + suffix),
	}
}

// newObjectRefType creates a test ObjectRefType entity with sample data
func newObjectRefType(suffix string) *parent.ObjectRefType {
	return &parent.ObjectRefType{
		Object_ref: "test_object_ref_" + suffix,
	}
}

// newFilter creates a test Filter entity with sample data
func newFilter(suffix string) *parent.Filter {
	return &parent.Filter{
		Action: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPlainTextType creates a test PlainTextType entity with sample data
func newPlainTextType(suffix string) *parent.PlainTextType {
	return &parent.PlainTextType{
		XsdId: "test_xsdid_" + suffix,
	}
}

// newComplexCheckType creates a test ComplexCheckType entity with sample data
func newComplexCheckType(suffix string) *parent.ComplexCheckType {
	return &parent.ComplexCheckType{
		Operator: "test_operator_" + suffix,
		Negate: boolPtr(true),
		CheckID: int64Ptr(42),
		ComplexCheckID: int64Ptr(42),
	}
}

// newProfileType creates a test ProfileType entity with sample data
func newProfileType(suffix string) *parent.ProfileType {
	return &parent.ProfileType{
		XsdId: "test_xsdid_" + suffix,
		ProhibitChanges: boolPtr(true),
		Abstract: boolPtr(true),
		NoteTag: stringPtr("test_" + suffix),
		Extends: stringPtr("test_" + suffix),
		VersionID: int64Ptr(42),
		SignatureID: int64Ptr(42),
		SelectID: int64Ptr(42),
		SetComplexValueID: int64Ptr(42),
		SetValueID: int64Ptr(42),
		RefineValueID: int64Ptr(42),
		RefineRuleID: int64Ptr(42),
	}
}

// newIpV4ElementType creates a test IpV4ElementType entity with sample data
func newIpV4ElementType(suffix string) *parent.IpV4ElementType {
	return &parent.IpV4ElementType{
		ParentID: int64Ptr(42),
	}
}

// newFirmType creates a test FirmType entity with sample data
func newFirmType(suffix string) *parent.FirmType {
	return &parent.FirmType{
		Type: stringPtr("test_" + suffix),
		FirmName: stringPtr("test_" + suffix),
		MailStopID: int64Ptr(42),
	}
}

// newEntityObjectIntType creates a test EntityObjectIntType entity with sample data
func newEntityObjectIntType(suffix string) *parent.EntityObjectIntType {
	return &parent.EntityObjectIntType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newVariableType creates a test VariableType entity with sample data
func newVariableType(suffix string) *parent.VariableType {
	return &parent.VariableType{
		XsdId: "test_xsdid_" + suffix,
		Version: 42,
		Datatype: "test_datatype_" + suffix,
		Comment: "test_comment_" + suffix,
		Deprecated: boolPtr(true),
	}
}

// newProfileRefineRuleType creates a test ProfileRefineRuleType entity with sample data
func newProfileRefineRuleType(suffix string) *parent.ProfileRefineRuleType {
	return &parent.ProfileRefineRuleType{
		Idref: "test_idref_" + suffix,
		Weight: stringPtr("test_" + suffix),
		Selector: stringPtr("test_" + suffix),
		Severity: stringPtr("test_" + suffix),
		Role: stringPtr("test_" + suffix),
	}
}

// newProfileNoteType creates a test ProfileNoteType entity with sample data
func newProfileNoteType(suffix string) *parent.ProfileNoteType {
	return &parent.ProfileNoteType{
		Tag: "test_tag_" + suffix,
		SubID: int64Ptr(42),
	}
}

// newXccdf12MessageType creates a test Xccdf12MessageType entity with sample data
func newXccdf12MessageType(suffix string) *parent.Xccdf12MessageType {
	return &parent.Xccdf12MessageType{
		Severity: "test_severity_" + suffix,
	}
}

// newAssetReportCollectionElementType creates a test AssetReportCollectionElementType entity with sample data
func newAssetReportCollectionElementType(suffix string) *parent.AssetReportCollectionElementType {
	return &parent.AssetReportCollectionElementType{
		XsdId: stringPtr("test_" + suffix),
		ReportRequests: stringPtr("test_" + suffix),
		Assets: stringPtr("test_" + suffix),
		Reports: "test_reports_" + suffix,
		ExtendedInfos: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newLocationPointElementType creates a test LocationPointElementType entity with sample data
func newLocationPointElementType(suffix string) *parent.LocationPointElementType {
	return &parent.LocationPointElementType{
		Latitude: "test_latitude_" + suffix,
		Longitude: "test_longitude_" + suffix,
		Elevation: float64Ptr(3.14),
		Radius: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumberElementType creates a test ThoroughfareNumberElementType entity with sample data
func newThoroughfareNumberElementType(suffix string) *parent.ThoroughfareNumberElementType {
	return &parent.ThoroughfareNumberElementType{
		NumberType: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberOccurrence: stringPtr("test_" + suffix),
	}
}

// newOasisNamesTcCiqXPersonName creates a test OasisNamesTcCiqXPersonName entity with sample data
func newOasisNamesTcCiqXPersonName(suffix string) *parent.OasisNamesTcCiqXPersonName {
	return &parent.OasisNamesTcCiqXPersonName{
		FormerName: stringPtr("test_" + suffix),
		KnownAs: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newEntityObjectFloatType creates a test EntityObjectFloatType entity with sample data
func newEntityObjectFloatType(suffix string) *parent.EntityObjectFloatType {
	return &parent.EntityObjectFloatType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newProfileRefineValueType creates a test ProfileRefineValueType entity with sample data
func newProfileRefineValueType(suffix string) *parent.ProfileRefineValueType {
	return &parent.ProfileRefineValueType{
		Idref: "test_idref_" + suffix,
		Selector: stringPtr("test_" + suffix),
		Operator: stringPtr("test_" + suffix),
	}
}

// newModelElementType creates a test ModelElementType entity with sample data
func newModelElementType(suffix string) *parent.ModelElementType {
	return &parent.ModelElementType{
		System: "test_system_" + suffix,
	}
}

// newSelComplexValueType creates a test SelComplexValueType entity with sample data
func newSelComplexValueType(suffix string) *parent.SelComplexValueType {
	return &parent.SelComplexValueType{
		Selector: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newExtendedInfoElementType creates a test ExtendedInfoElementType entity with sample data
func newExtendedInfoElementType(suffix string) *parent.ExtendedInfoElementType {
	return &parent.ExtendedInfoElementType{
		XsdId: "test_xsdid_" + suffix,
	}
}

// newLocationsElementType creates a test LocationsElementType entity with sample data
func newLocationsElementType(suffix string) *parent.LocationsElementType {
	return &parent.LocationsElementType{
	}
}

// newBirthdateElementType creates a test BirthdateElementType entity with sample data
func newBirthdateElementType(suffix string) *parent.BirthdateElementType {
	return &parent.BirthdateElementType{
	}
}

// newSubPremiseNumberSuffixElementType creates a test SubPremiseNumberSuffixElementType entity with sample data
func newSubPremiseNumberSuffixElementType(suffix string) *parent.SubPremiseNumberSuffixElementType {
	return &parent.SubPremiseNumberSuffixElementType{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newOrganisationFormerNameElementType creates a test OrganisationFormerNameElementType entity with sample data
func newOrganisationFormerNameElementType(suffix string) *parent.OrganisationFormerNameElementType {
	return &parent.OrganisationFormerNameElementType{
		ValidFrom: stringPtr("test_" + suffix),
		ValidTo: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newExtendDefinitionType creates a test ExtendDefinitionType entity with sample data
func newExtendDefinitionType(suffix string) *parent.ExtendDefinitionType {
	return &parent.ExtendDefinitionType{
		Applicability_check: boolPtr(true),
		Definition_ref: "test_definition_ref_" + suffix,
		Negate: boolPtr(true),
		Comment: stringPtr("test_" + suffix),
	}
}

// newRestrictionType creates a test RestrictionType entity with sample data
func newRestrictionType(suffix string) *parent.RestrictionType {
	return &parent.RestrictionType{
		Operation: "test_operation_" + suffix,
	}
}

// newIdentityType creates a test IdentityType entity with sample data
func newIdentityType(suffix string) *parent.IdentityType {
	return &parent.IdentityType{
		Authenticated: true,
		Privileged: true,
	}
}

// newDcStatusType creates a test DcStatusType entity with sample data
func newDcStatusType(suffix string) *parent.DcStatusType {
	return &parent.DcStatusType{
	}
}

// newPostalRouteType creates a test PostalRouteType entity with sample data
func newPostalRouteType(suffix string) *parent.PostalRouteType {
	return &parent.PostalRouteType{
		Type: stringPtr("test_" + suffix),
		PostalRouteName: "test_postalroutename_" + suffix,
		PostalRouteNumber: "test_postalroutenumber_" + suffix,
	}
}

// newPostOfficeNumberElementType creates a test PostOfficeNumberElementType entity with sample data
func newPostOfficeNumberElementType(suffix string) *parent.PostOfficeNumberElementType {
	return &parent.PostOfficeNumberElementType{
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
	}
}

// newKnownAsElementType creates a test KnownAsElementType entity with sample data
func newKnownAsElementType(suffix string) *parent.KnownAsElementType {
	return &parent.KnownAsElementType{
		ValidFrom: stringPtr("test_" + suffix),
		ValidTo: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newDeprecatedInfoType creates a test DeprecatedInfoType entity with sample data
func newDeprecatedInfoType(suffix string) *parent.DeprecatedInfoType {
	return &parent.DeprecatedInfoType{
		Version: "test_version_" + suffix,
		Reason: "test_reason_" + suffix,
		Comment: stringPtr("test_" + suffix),
	}
}

// newSignatureMethodType creates a test SignatureMethodType entity with sample data
func newSignatureMethodType(suffix string) *parent.SignatureMethodType {
	return &parent.SignatureMethodType{
		Algorithm: "test_algorithm_" + suffix,
		HMACOutputLengthID: int64Ptr(42),
	}
}

// newEscapeRegexFunctionType creates a test EscapeRegexFunctionType entity with sample data
func newEscapeRegexFunctionType(suffix string) *parent.EscapeRegexFunctionType {
	return &parent.EscapeRegexFunctionType{
	}
}

// newEntityObjectIPAddressStringType creates a test EntityObjectIPAddressStringType entity with sample data
func newEntityObjectIPAddressStringType(suffix string) *parent.EntityObjectIPAddressStringType {
	return &parent.EntityObjectIPAddressStringType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newCountryNameElementType creates a test CountryNameElementType entity with sample data
func newCountryNameElementType(suffix string) *parent.CountryNameElementType {
	return &parent.CountryNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostBox creates a test PostBox entity with sample data
func newPostBox(suffix string) *parent.PostBox {
	return &parent.PostBox{
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		PostBoxNumber: "test_postboxnumber_" + suffix,
		PostBoxNumberPrefix: stringPtr("test_" + suffix),
		PostBoxNumberSuffix: stringPtr("test_" + suffix),
		PostBoxNumberExtension: stringPtr("test_" + suffix),
		FirmID: int64Ptr(42),
	}
}

// newPossibleRestrictionType creates a test PossibleRestrictionType entity with sample data
func newPossibleRestrictionType(suffix string) *parent.PossibleRestrictionType {
	return &parent.PossibleRestrictionType{
		Operator: stringPtr("test_" + suffix),
		Hint: "test_hint_" + suffix,
	}
}

// newSimple creates a test Simple entity with sample data
func newSimple(suffix string) *parent.Simple {
	return &parent.Simple{
	}
}

// newInstallationIdElementType creates a test InstallationIdElementType entity with sample data
func newInstallationIdElementType(suffix string) *parent.InstallationIdElementType {
	return &parent.InstallationIdElementType{
	}
}

// newLocalityElementType creates a test LocalityElementType entity with sample data
func newLocalityElementType(suffix string) *parent.LocalityElementType {
	return &parent.LocalityElementType{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		LocalityName: stringPtr("test_" + suffix),
		DependentLocalityID: int64Ptr(42),
		LargeMailUserID: int64Ptr(42),
		PostalRouteID: int64Ptr(42),
	}
}

// newPostalCode creates a test PostalCode entity with sample data
func newPostalCode(suffix string) *parent.PostalCode {
	return &parent.PostalCode{
		Type: stringPtr("test_" + suffix),
		PostalCodeNumber: stringPtr("test_" + suffix),
		PostalCodeNumberExtension: stringPtr("test_" + suffix),
		PostTown: stringPtr("test_" + suffix),
	}
}

// newPlatformType creates a test PlatformType entity with sample data
func newPlatformType(suffix string) *parent.PlatformType {
	return &parent.PlatformType{
		XsdId: "test_xsdid_" + suffix,
		LogicalTestID: int64Ptr(42),
	}
}

// newCheckImportType creates a test CheckImportType entity with sample data
func newCheckImportType(suffix string) *parent.CheckImportType {
	return &parent.CheckImportType{
		ImportName: "test_importname_" + suffix,
		ImportXpath: stringPtr("test_" + suffix),
	}
}

// newStatus creates a test Status entity with sample data
func newStatus(suffix string) *parent.Status {
	return &parent.Status{
		Date: timePtr(time.Now()),
		ParentID: int64Ptr(42),
	}
}

// newExtendedInfosElementType creates a test ExtendedInfosElementType entity with sample data
func newExtendedInfosElementType(suffix string) *parent.ExtendedInfosElementType {
	return &parent.ExtendedInfosElementType{
		ExtendedInfo: "test_extendedinfo_" + suffix,
	}
}

// newReportType creates a test ReportType entity with sample data
func newReportType(suffix string) *parent.ReportType {
	return &parent.ReportType{
		XsdId: "test_xsdid_" + suffix,
		Content: "test_content_" + suffix,
	}
}

// newWebsiteType creates a test WebsiteType entity with sample data
func newWebsiteType(suffix string) *parent.WebsiteType {
	return &parent.WebsiteType{
		DocumentRoot: stringPtr("test_" + suffix),
		Locale: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newElementMapItemType creates a test ElementMapItemType entity with sample data
func newElementMapItemType(suffix string) *parent.ElementMapItemType {
	return &parent.ElementMapItemType{
		Target_namespace: stringPtr("test_" + suffix),
	}
}

// newDigestMethodType creates a test DigestMethodType entity with sample data
func newDigestMethodType(suffix string) *parent.DigestMethodType {
	return &parent.DigestMethodType{
		Algorithm: "test_algorithm_" + suffix,
	}
}

// newEntityStateFieldType creates a test EntityStateFieldType entity with sample data
func newEntityStateFieldType(suffix string) *parent.EntityStateFieldType {
	return &parent.EntityStateFieldType{
		Name: "test_name_" + suffix,
		Entity_check: stringPtr("test_" + suffix),
	}
}

// newIdrefType creates a test IdrefType entity with sample data
func newIdrefType(suffix string) *parent.IdrefType {
	return &parent.IdrefType{
		Idref: "test_idref_" + suffix,
	}
}

// newReportsElementType creates a test ReportsElementType entity with sample data
func newReportsElementType(suffix string) *parent.ReportsElementType {
	return &parent.ReportsElementType{
	}
}

// newSuffixElementType creates a test SuffixElementType entity with sample data
func newSuffixElementType(suffix string) *parent.SuffixElementType {
	return &parent.SuffixElementType{
		Type: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newX509IssuerSerialType creates a test X509IssuerSerialType entity with sample data
func newX509IssuerSerialType(suffix string) *parent.X509IssuerSerialType {
	return &parent.X509IssuerSerialType{
		X509IssuerName: "test_x509issuername_" + suffix,
		X509SerialNumber: 42,
	}
}

// newDocumentRootElementType creates a test DocumentRootElementType entity with sample data
func newDocumentRootElementType(suffix string) *parent.DocumentRootElementType {
	return &parent.DocumentRootElementType{
	}
}

// newPremiseElementType creates a test PremiseElementType entity with sample data
func newPremiseElementType(suffix string) *parent.PremiseElementType {
	return &parent.PremiseElementType{
		Type: stringPtr("test_" + suffix),
		PremiseDependency: stringPtr("test_" + suffix),
		PremiseDependencyType: stringPtr("test_" + suffix),
		PremiseThoroughfareConnector: stringPtr("test_" + suffix),
		PremiseName: stringPtr("test_" + suffix),
		MailStopID: int64Ptr(42),
		PremiseLocation: "test_premiselocation_" + suffix,
		PremiseNumberRange: "test_premisenumberrange_" + suffix,
		FirmID: int64Ptr(42),
	}
}

// newPremiseNameElementType creates a test PremiseNameElementType entity with sample data
func newPremiseNameElementType(suffix string) *parent.PremiseNameElementType {
	return &parent.PremiseNameElementType{
		Type: stringPtr("test_" + suffix),
		TypeOccurrence: stringPtr("test_" + suffix),
	}
}

// newNamePrefixElementType creates a test NamePrefixElementType entity with sample data
func newNamePrefixElementType(suffix string) *parent.NamePrefixElementType {
	return &parent.NamePrefixElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newOverrideType creates a test OverrideType entity with sample data
func newOverrideType(suffix string) *parent.OverrideType {
	return &parent.OverrideType{
		Time: time.Now(),
		Authority: "test_authority_" + suffix,
		OldResultID: int64Ptr(42),
		NewResultID: int64Ptr(42),
		RemarkID: int64Ptr(42),
	}
}

// newEmailAddress creates a test EmailAddress entity with sample data
func newEmailAddress(suffix string) *parent.EmailAddress {
	return &parent.EmailAddress{
	}
}

// newEntityStateEVRStringType creates a test EntityStateEVRStringType entity with sample data
func newEntityStateEVRStringType(suffix string) *parent.EntityStateEVRStringType {
	return &parent.EntityStateEVRStringType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newGroupType creates a test GroupType entity with sample data
func newGroupType(suffix string) *parent.GroupType {
	return &parent.GroupType{
		XsdId: "test_xsdid_" + suffix,
		SignatureID: int64Ptr(42),
		ParentID: int64Ptr(42),
	}
}

// newCpeElementType creates a test CpeElementType entity with sample data
func newCpeElementType(suffix string) *parent.CpeElementType {
	return &parent.CpeElementType{
		ParentID: int64Ptr(42),
	}
}

// newDependentLocalityNumberElementType creates a test DependentLocalityNumberElementType entity with sample data
func newDependentLocalityNumberElementType(suffix string) *parent.DependentLocalityNumberElementType {
	return &parent.DependentLocalityNumberElementType{
		NameNumberOccurrence: stringPtr("test_" + suffix),
	}
}

// newPremiseNumberPrefixElementType creates a test PremiseNumberPrefixElementType entity with sample data
func newPremiseNumberPrefixElementType(suffix string) *parent.PremiseNumberPrefixElementType {
	return &parent.PremiseNumberPrefixElementType{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newPostTownSuffixElementType creates a test PostTownSuffixElementType entity with sample data
func newPostTownSuffixElementType(suffix string) *parent.PostTownSuffixElementType {
	return &parent.PostTownSuffixElementType{
	}
}

// newOtherNameElementType creates a test OtherNameElementType entity with sample data
func newOtherNameElementType(suffix string) *parent.OtherNameElementType {
	return &parent.OtherNameElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newPersonNameElementType creates a test PersonNameElementType entity with sample data
func newPersonNameElementType(suffix string) *parent.PersonNameElementType {
	return &parent.PersonNameElementType{
		FormerName: stringPtr("test_" + suffix),
		KnownAs: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newRelationshipsElementType creates a test RelationshipsElementType entity with sample data
func newRelationshipsElementType(suffix string) *parent.RelationshipsElementType {
	return &parent.RelationshipsElementType{
	}
}

// newScoreType creates a test ScoreType entity with sample data
func newScoreType(suffix string) *parent.ScoreType {
	return &parent.ScoreType{
		System: stringPtr("test_" + suffix),
		Maximum: stringPtr("test_" + suffix),
	}
}

// newDatabaseType creates a test DatabaseType entity with sample data
func newDatabaseType(suffix string) *parent.DatabaseType {
	return &parent.DatabaseType{
		InstanceName: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPremiseNumberRangeElementType creates a test PremiseNumberRangeElementType entity with sample data
func newPremiseNumberRangeElementType(suffix string) *parent.PremiseNumberRangeElementType {
	return &parent.PremiseNumberRangeElementType{
		RangeType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		Separator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		IndicatorOccurence: stringPtr("test_" + suffix),
		NumberRangeOccurence: stringPtr("test_" + suffix),
		PremiseNumberRangeFrom: "test_premisenumberrangefrom_" + suffix,
		PremiseNumberRangeTo: "test_premisenumberrangeto_" + suffix,
	}
}

// newOvalMitreOrgOvalValueType creates a test OvalMitreOrgOvalValueType entity with sample data
func newOvalMitreOrgOvalValueType(suffix string) *parent.OvalMitreOrgOvalValueType {
	return &parent.OvalMitreOrgOvalValueType{
	}
}

// newSubstringFunctionType creates a test SubstringFunctionType entity with sample data
func newSubstringFunctionType(suffix string) *parent.SubstringFunctionType {
	return &parent.SubstringFunctionType{
		Substring_start: 42,
		Substring_length: 42,
	}
}

// newFixType creates a test FixType entity with sample data
func newFixType(suffix string) *parent.FixType {
	return &parent.FixType{
		XsdId: stringPtr("test_" + suffix),
		Reboot: boolPtr(true),
		Strategy: stringPtr("test_" + suffix),
		Disruption: stringPtr("test_" + suffix),
		Complexity: stringPtr("test_" + suffix),
		System: stringPtr("test_" + suffix),
		Platform: stringPtr("test_" + suffix),
		SubID: int64Ptr(42),
		InstanceID: int64Ptr(42),
	}
}

// newBenchmark creates a test Benchmark entity with sample data
func newBenchmark(suffix string) *parent.Benchmark {
	return &parent.Benchmark{
		XsdId: "test_xsdid_" + suffix,
		Resolved: boolPtr(true),
		Style: stringPtr("test_" + suffix),
		StyleHref: stringPtr("test_" + suffix),
		VersionID: int64Ptr(42),
		SignatureID: int64Ptr(42),
	}
}

// newIpNetRangeElementType creates a test IpNetRangeElementType entity with sample data
func newIpNetRangeElementType(suffix string) *parent.IpNetRangeElementType {
	return &parent.IpNetRangeElementType{
		IpNetRangeStartID: int64Ptr(42),
		IpNetRangeEndID: int64Ptr(42),
	}
}

// newNetworkNameElementType creates a test NetworkNameElementType entity with sample data
func newNetworkNameElementType(suffix string) *parent.NetworkNameElementType {
	return &parent.NetworkNameElementType{
	}
}

// newDepartment creates a test Department entity with sample data
func newDepartment(suffix string) *parent.Department {
	return &parent.Department{
		Type: stringPtr("test_" + suffix),
		DepartmentName: stringPtr("test_" + suffix),
		MailStopID: int64Ptr(42),
	}
}

// newAddressLine creates a test AddressLine entity with sample data
func newAddressLine(suffix string) *parent.AddressLine {
	return &parent.AddressLine{
		Type: stringPtr("test_" + suffix),
	}
}

// newTestType creates a test TestType entity with sample data
func newTestType(suffix string) *parent.TestType {
	return &parent.TestType{
		XsdId: "test_xsdid_" + suffix,
		Version: 42,
		Check_existence: stringPtr("test_" + suffix),
		Check: "test_check_" + suffix,
		State_operator: stringPtr("test_" + suffix),
		Comment: "test_comment_" + suffix,
		Deprecated: boolPtr(true),
	}
}

// newEntityStateVersionType creates a test EntityStateVersionType entity with sample data
func newEntityStateVersionType(suffix string) *parent.EntityStateVersionType {
	return &parent.EntityStateVersionType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newAssetsElementType creates a test AssetsElementType entity with sample data
func newAssetsElementType(suffix string) *parent.AssetsElementType {
	return &parent.AssetsElementType{
		Asset: "test_asset_" + suffix,
	}
}

// newLicenseElementType creates a test LicenseElementType entity with sample data
func newLicenseElementType(suffix string) *parent.LicenseElementType {
	return &parent.LicenseElementType{
	}
}

// newOasisNamesTcCiqXNameDetails creates a test OasisNamesTcCiqXNameDetails entity with sample data
func newOasisNamesTcCiqXNameDetails(suffix string) *parent.OasisNamesTcCiqXNameDetails {
	return &parent.OasisNamesTcCiqXNameDetails{
		NameDetailsKey: stringPtr("test_" + suffix),
		AddresseeIndicator: stringPtr("test_" + suffix),
		DependencyName: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newSignaturePropertyType creates a test SignaturePropertyType entity with sample data
func newSignaturePropertyType(suffix string) *parent.SignaturePropertyType {
	return &parent.SignaturePropertyType{
		Target: "test_target_" + suffix,
		XsdId: stringPtr("test_" + suffix),
	}
}

// newEntityStateFloatType creates a test EntityStateFloatType entity with sample data
func newEntityStateFloatType(suffix string) *parent.EntityStateFloatType {
	return &parent.EntityStateFloatType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newStateRefType creates a test StateRefType entity with sample data
func newStateRefType(suffix string) *parent.StateRefType {
	return &parent.StateRefType{
		State_ref: "test_state_ref_" + suffix,
	}
}

// newConstantVariableElementType creates a test ConstantVariableElementType entity with sample data
func newConstantVariableElementType(suffix string) *parent.ConstantVariableElementType {
	return &parent.ConstantVariableElementType{
		ParentID: int64Ptr(42),
	}
}

// newNs09XmldsigSignatureType creates a test Ns09XmldsigSignatureType entity with sample data
func newNs09XmldsigSignatureType(suffix string) *parent.Ns09XmldsigSignatureType {
	return &parent.Ns09XmldsigSignatureType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newHostElementType creates a test HostElementType entity with sample data
func newHostElementType(suffix string) *parent.HostElementType {
	return &parent.HostElementType{
	}
}

// newExtendedInformationElementType creates a test ExtendedInformationElementType entity with sample data
func newExtendedInformationElementType(suffix string) *parent.ExtendedInformationElementType {
	return &parent.ExtendedInformationElementType{
	}
}

// newOrganisationTypeElementType creates a test OrganisationTypeElementType entity with sample data
func newOrganisationTypeElementType(suffix string) *parent.OrganisationTypeElementType {
	return &parent.OrganisationTypeElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newFirstNameElementType creates a test FirstNameElementType entity with sample data
func newFirstNameElementType(suffix string) *parent.FirstNameElementType {
	return &parent.FirstNameElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newAliasElementType creates a test AliasElementType entity with sample data
func newAliasElementType(suffix string) *parent.AliasElementType {
	return &parent.AliasElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newManifestType creates a test ManifestType entity with sample data
func newManifestType(suffix string) *parent.ManifestType {
	return &parent.ManifestType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newRemoteResource creates a test RemoteResource entity with sample data
func newRemoteResource(suffix string) *parent.RemoteResource {
	return &parent.RemoteResource{
	}
}

// newSignaturePropertiesType creates a test SignaturePropertiesType entity with sample data
func newSignaturePropertiesType(suffix string) *parent.SignaturePropertiesType {
	return &parent.SignaturePropertiesType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newTestResultType creates a test TestResultType entity with sample data
func newTestResultType(suffix string) *parent.TestResultType {
	return &parent.TestResultType{
		XsdId: "test_xsdid_" + suffix,
		StartTime: timePtr(time.Now()),
		EndTime: time.Now(),
		TestSystem: stringPtr("test_" + suffix),
		Version: stringPtr("test_" + suffix),
		BenchmarkID: int64Ptr(42),
		TailoringFileID: int64Ptr(42),
		Organization: stringPtr("test_" + suffix),
		IdentityID: int64Ptr(42),
		ProfileID: int64Ptr(42),
		Target: "test_target_" + suffix,
		TargetAddress: stringPtr("test_" + suffix),
		TargetFactsID: int64Ptr(42),
		SignatureID: int64Ptr(42),
		TargetIdRefID: int64Ptr(42),
		SetValueID: int64Ptr(42),
		SetComplexValueID: int64Ptr(42),
	}
}

// newStatusElementType creates a test StatusElementType entity with sample data
func newStatusElementType(suffix string) *parent.StatusElementType {
	return &parent.StatusElementType{
		Date: timePtr(time.Now()),
		ParentID: int64Ptr(42),
	}
}

// newNetworkType creates a test NetworkType entity with sample data
func newNetworkType(suffix string) *parent.NetworkType {
	return &parent.NetworkType{
		NetworkName: stringPtr("test_" + suffix),
		IpNetRange: "test_ipnetrange_" + suffix,
		Cidr: "test_cidr_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newPremiseNumberElementType creates a test PremiseNumberElementType entity with sample data
func newPremiseNumberElementType(suffix string) *parent.PremiseNumberElementType {
	return &parent.PremiseNumberElementType{
		NumberType: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberTypeOccurrence: stringPtr("test_" + suffix),
	}
}

// newOvalMitreOrgOvalMessageType creates a test OvalMitreOrgOvalMessageType entity with sample data
func newOvalMitreOrgOvalMessageType(suffix string) *parent.OvalMitreOrgOvalMessageType {
	return &parent.OvalMitreOrgOvalMessageType{
		Level: stringPtr("test_" + suffix),
	}
}

// newTestsType creates a test TestsType entity with sample data
func newTestsType(suffix string) *parent.TestsType {
	return &parent.TestsType{
	}
}

// newVersionElementType creates a test VersionElementType entity with sample data
func newVersionElementType(suffix string) *parent.VersionElementType {
	return &parent.VersionElementType{
	}
}

// newOvalMitreOrgOvalNotesType creates a test OvalMitreOrgOvalNotesType entity with sample data
func newOvalMitreOrgOvalNotesType(suffix string) *parent.OvalMitreOrgOvalNotesType {
	return &parent.OvalMitreOrgOvalNotesType{
		Note: stringPtr("test_" + suffix),
	}
}

// newSoftwareType creates a test SoftwareType entity with sample data
func newSoftwareType(suffix string) *parent.SoftwareType {
	return &parent.SoftwareType{
		InstallationId: stringPtr("test_" + suffix),
		License: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newLocationRegion creates a test LocationRegion entity with sample data
func newLocationRegion(suffix string) *parent.LocationRegion {
	return &parent.LocationRegion{
	}
}

// newParamType creates a test ParamType entity with sample data
func newParamType(suffix string) *parent.ParamType {
	return &parent.ParamType{
		Name: "test_name_" + suffix,
	}
}

// newFqdnElementType creates a test FqdnElementType entity with sample data
func newFqdnElementType(suffix string) *parent.FqdnElementType {
	return &parent.FqdnElementType{
	}
}

// newPostalCodeNumberElementType creates a test PostalCodeNumberElementType entity with sample data
func newPostalCodeNumberElementType(suffix string) *parent.PostalCodeNumberElementType {
	return &parent.PostalCodeNumberElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newAdministrativeAreaNameElementType creates a test AdministrativeAreaNameElementType entity with sample data
func newAdministrativeAreaNameElementType(suffix string) *parent.AdministrativeAreaNameElementType {
	return &parent.AdministrativeAreaNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostBoxElementType creates a test PostBoxElementType entity with sample data
func newPostBoxElementType(suffix string) *parent.PostBoxElementType {
	return &parent.PostBoxElementType{
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		PostBoxNumber: "test_postboxnumber_" + suffix,
		PostBoxNumberPrefix: stringPtr("test_" + suffix),
		PostBoxNumberSuffix: stringPtr("test_" + suffix),
		PostBoxNumberExtension: stringPtr("test_" + suffix),
		FirmID: int64Ptr(42),
	}
}

// newMailStopNameElementType creates a test MailStopNameElementType entity with sample data
func newMailStopNameElementType(suffix string) *parent.MailStopNameElementType {
	return &parent.MailStopNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostOffice creates a test PostOffice entity with sample data
func newPostOffice(suffix string) *parent.PostOffice {
	return &parent.PostOffice{
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		PostalRouteID: int64Ptr(42),
		PostOfficeName: stringPtr("test_" + suffix),
		PostOfficeNumber: stringPtr("test_" + suffix),
	}
}

// newAdministrativeArea creates a test AdministrativeArea entity with sample data
func newAdministrativeArea(suffix string) *parent.AdministrativeArea {
	return &parent.AdministrativeArea{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		AdministrativeAreaName: stringPtr("test_" + suffix),
		SubAdministrativeArea: stringPtr("test_" + suffix),
	}
}

// newNoticeType creates a test NoticeType entity with sample data
func newNoticeType(suffix string) *parent.NoticeType {
	return &parent.NoticeType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newAddressLatitudeDirectionElementType creates a test AddressLatitudeDirectionElementType entity with sample data
func newAddressLatitudeDirectionElementType(suffix string) *parent.AddressLatitudeDirectionElementType {
	return &parent.AddressLatitudeDirectionElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostalRouteNumberElementType creates a test PostalRouteNumberElementType entity with sample data
func newPostalRouteNumberElementType(suffix string) *parent.PostalRouteNumberElementType {
	return &parent.PostalRouteNumberElementType{
	}
}

// newOrganisationNameElementType creates a test OrganisationNameElementType entity with sample data
func newOrganisationNameElementType(suffix string) *parent.OrganisationNameElementType {
	return &parent.OrganisationNameElementType{
		Type: stringPtr("test_" + suffix),
		NameType: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newSchemaVersionType creates a test SchemaVersionType entity with sample data
func newSchemaVersionType(suffix string) *parent.SchemaVersionType {
	return &parent.SchemaVersionType{
		Platform: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newLanguage20TextType creates a test Language20TextType entity with sample data
func newLanguage20TextType(suffix string) *parent.Language20TextType {
	return &parent.Language20TextType{
	}
}

// newCheckExportType creates a test CheckExportType entity with sample data
func newCheckExportType(suffix string) *parent.CheckExportType {
	return &parent.CheckExportType{
		ValueId: "test_valueid_" + suffix,
		ExportName: "test_exportname_" + suffix,
	}
}

// newReportRequestType creates a test ReportRequestType entity with sample data
func newReportRequestType(suffix string) *parent.ReportRequestType {
	return &parent.ReportRequestType{
		XsdId: "test_xsdid_" + suffix,
		Content: "test_content_" + suffix,
	}
}

// newIpV6ElementType creates a test IpV6ElementType entity with sample data
func newIpV6ElementType(suffix string) *parent.IpV6ElementType {
	return &parent.IpV6ElementType{
		ParentID: int64Ptr(42),
	}
}

// newLocalityNameElementType creates a test LocalityNameElementType entity with sample data
func newLocalityNameElementType(suffix string) *parent.LocalityNameElementType {
	return &parent.LocalityNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPremiseLocationElementType creates a test PremiseLocationElementType entity with sample data
func newPremiseLocationElementType(suffix string) *parent.PremiseLocationElementType {
	return &parent.PremiseLocationElementType{
	}
}

// newJointPersonName creates a test JointPersonName entity with sample data
func newJointPersonName(suffix string) *parent.JointPersonName {
	return &parent.JointPersonName{
		JointNameConnector: stringPtr("test_" + suffix),
		Code: stringPtr("test_" + suffix),
	}
}

// newDefinitionsType creates a test DefinitionsType entity with sample data
func newDefinitionsType(suffix string) *parent.DefinitionsType {
	return &parent.DefinitionsType{
	}
}

// newTimeDifferenceFunctionType creates a test TimeDifferenceFunctionType entity with sample data
func newTimeDifferenceFunctionType(suffix string) *parent.TimeDifferenceFunctionType {
	return &parent.TimeDifferenceFunctionType{
		Format_1: stringPtr("test_" + suffix),
		Format_2: stringPtr("test_" + suffix),
	}
}

// newEntityStateIntType creates a test EntityStateIntType entity with sample data
func newEntityStateIntType(suffix string) *parent.EntityStateIntType {
	return &parent.EntityStateIntType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newExternalVariable creates a test ExternalVariable entity with sample data
func newExternalVariable(suffix string) *parent.ExternalVariable {
	return &parent.ExternalVariable{
		Possible_valueID: int64Ptr(42),
		Possible_restrictionID: int64Ptr(42),
		ParentID: int64Ptr(42),
	}
}

// newProtocolElementType creates a test ProtocolElementType entity with sample data
func newProtocolElementType(suffix string) *parent.ProtocolElementType {
	return &parent.ProtocolElementType{
	}
}

// newIpAddressType creates a test IpAddressType entity with sample data
func newIpAddressType(suffix string) *parent.IpAddressType {
	return &parent.IpAddressType{
		IpV4: stringPtr("test_" + suffix),
		IpV6: stringPtr("test_" + suffix),
	}
}

// newSyntheticId creates a test SyntheticId entity with sample data
func newSyntheticId(suffix string) *parent.SyntheticId {
	return &parent.SyntheticId{
		Resource: "test_resource_" + suffix,
		XsdId: "test_xsdid_" + suffix,
	}
}

// newEntityStateBoolType creates a test EntityStateBoolType entity with sample data
func newEntityStateBoolType(suffix string) *parent.EntityStateBoolType {
	return &parent.EntityStateBoolType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newHtmlTextType creates a test HtmlTextType entity with sample data
func newHtmlTextType(suffix string) *parent.HtmlTextType {
	return &parent.HtmlTextType{
		Override: boolPtr(true),
	}
}

// newProfileSetValueType creates a test ProfileSetValueType entity with sample data
func newProfileSetValueType(suffix string) *parent.ProfileSetValueType {
	return &parent.ProfileSetValueType{
		Idref: "test_idref_" + suffix,
	}
}

// newXccdf12SignatureType creates a test Xccdf12SignatureType entity with sample data
func newXccdf12SignatureType(suffix string) *parent.Xccdf12SignatureType {
	return &parent.Xccdf12SignatureType{
	}
}

// newProfileSelectType creates a test ProfileSelectType entity with sample data
func newProfileSelectType(suffix string) *parent.ProfileSelectType {
	return &parent.ProfileSelectType{
		Idref: "test_idref_" + suffix,
		Selected: true,
	}
}

// newSystemType creates a test SystemType entity with sample data
func newSystemType(suffix string) *parent.SystemType {
	return &parent.SystemType{
		SystemName: stringPtr("test_" + suffix),
		Version: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newLocaleElementType creates a test LocaleElementType entity with sample data
func newLocaleElementType(suffix string) *parent.LocaleElementType {
	return &parent.LocaleElementType{
		ParentID: int64Ptr(42),
	}
}

// newDependentLocalityNameElementType creates a test DependentLocalityNameElementType entity with sample data
func newDependentLocalityNameElementType(suffix string) *parent.DependentLocalityNameElementType {
	return &parent.DependentLocalityNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newSubPremiseNumberElementType creates a test SubPremiseNumberElementType entity with sample data
func newSubPremiseNumberElementType(suffix string) *parent.SubPremiseNumberElementType {
	return &parent.SubPremiseNumberElementType{
		Indicator: stringPtr("test_" + suffix),
		IndicatorOccurrence: stringPtr("test_" + suffix),
		NumberTypeOccurrence: stringPtr("test_" + suffix),
		PremiseNumberSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newKeyValueType creates a test KeyValueType entity with sample data
func newKeyValueType(suffix string) *parent.KeyValueType {
	return &parent.KeyValueType{
	}
}

// newRemoteResourceElementType creates a test RemoteResourceElementType entity with sample data
func newRemoteResourceElementType(suffix string) *parent.RemoteResourceElementType {
	return &parent.RemoteResourceElementType{
	}
}

// newAssetReportCollection creates a test AssetReportCollection entity with sample data
func newAssetReportCollection(suffix string) *parent.AssetReportCollection {
	return &parent.AssetReportCollection{
		XsdId: stringPtr("test_" + suffix),
		ReportRequests: stringPtr("test_" + suffix),
		Assets: stringPtr("test_" + suffix),
		Reports: "test_reports_" + suffix,
		ExtendedInfos: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPostBoxNumberSuffixElementType creates a test PostBoxNumberSuffixElementType entity with sample data
func newPostBoxNumberSuffixElementType(suffix string) *parent.PostBoxNumberSuffixElementType {
	return &parent.PostBoxNumberSuffixElementType{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
	}
}

// newAddressLongitudeDirectionElementType creates a test AddressLongitudeDirectionElementType entity with sample data
func newAddressLongitudeDirectionElementType(suffix string) *parent.AddressLongitudeDirectionElementType {
	return &parent.AddressLongitudeDirectionElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newThoroughfareTrailingTypeType creates a test ThoroughfareTrailingTypeType entity with sample data
func newThoroughfareTrailingTypeType(suffix string) *parent.ThoroughfareTrailingTypeType {
	return &parent.ThoroughfareTrailingTypeType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPremiseNumberSuffix creates a test PremiseNumberSuffix entity with sample data
func newPremiseNumberSuffix(suffix string) *parent.PremiseNumberSuffix {
	return &parent.PremiseNumberSuffix{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newSet creates a test Set entity with sample data
func newSet(suffix string) *parent.Set {
	return &parent.Set{
		Set_operator: stringPtr("test_" + suffix),
	}
}

// newXccdf12ReferenceType creates a test Xccdf12ReferenceType entity with sample data
func newXccdf12ReferenceType(suffix string) *parent.Xccdf12ReferenceType {
	return &parent.Xccdf12ReferenceType{
		Href: stringPtr("test_" + suffix),
		Override: boolPtr(true),
	}
}

// newListType creates a test ListType entity with sample data
func newListType(suffix string) *parent.ListType {
	return &parent.ListType{
		GeneratorID: int64Ptr(42),
	}
}

// newDictionary20CheckType creates a test Dictionary20CheckType entity with sample data
func newDictionary20CheckType(suffix string) *parent.Dictionary20CheckType {
	return &parent.Dictionary20CheckType{
		System: "test_system_" + suffix,
		Href: stringPtr("test_" + suffix),
	}
}

// newDistinguishedNameElementType creates a test DistinguishedNameElementType entity with sample data
func newDistinguishedNameElementType(suffix string) *parent.DistinguishedNameElementType {
	return &parent.DistinguishedNameElementType{
	}
}

// newComputingDeviceType creates a test ComputingDeviceType entity with sample data
func newComputingDeviceType(suffix string) *parent.ComputingDeviceType {
	return &parent.ComputingDeviceType{
		DistinguishedName: stringPtr("test_" + suffix),
		Connections: stringPtr("test_" + suffix),
		Hostname: stringPtr("test_" + suffix),
		MotherboardGuid: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newSubType creates a test SubType entity with sample data
func newSubType(suffix string) *parent.SubType {
	return &parent.SubType{
		Use: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newBenchmarkReferenceType creates a test BenchmarkReferenceType entity with sample data
func newBenchmarkReferenceType(suffix string) *parent.BenchmarkReferenceType {
	return &parent.BenchmarkReferenceType{
		Href: "test_href_" + suffix,
		XsdId: stringPtr("test_" + suffix),
	}
}

// newEntityObjectIPAddressType creates a test EntityObjectIPAddressType entity with sample data
func newEntityObjectIPAddressType(suffix string) *parent.EntityObjectIPAddressType {
	return &parent.EntityObjectIPAddressType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newHtmlTextWithSubType creates a test HtmlTextWithSubType entity with sample data
func newHtmlTextWithSubType(suffix string) *parent.HtmlTextWithSubType {
	return &parent.HtmlTextWithSubType{
		Override: boolPtr(true),
		SubID: int64Ptr(42),
	}
}

// newUriRefType creates a test UriRefType entity with sample data
func newUriRefType(suffix string) *parent.UriRefType {
	return &parent.UriRefType{
		Uri: "test_uri_" + suffix,
	}
}

// newTargetFactsType creates a test TargetFactsType entity with sample data
func newTargetFactsType(suffix string) *parent.TargetFactsType {
	return &parent.TargetFactsType{
	}
}

// newAssetReportingFormAssetElementType creates a test AssetReportingFormAssetElementType entity with sample data
func newAssetReportingFormAssetElementType(suffix string) *parent.AssetReportingFormAssetElementType {
	return &parent.AssetReportingFormAssetElementType{
		XsdId: "test_xsdid_" + suffix,
	}
}

// newXAL creates a test XAL entity with sample data
func newXAL(suffix string) *parent.XAL {
	return &parent.XAL{
		Version: stringPtr("test_" + suffix),
	}
}

// newEntityStateDebianEVRStringType creates a test EntityStateDebianEVRStringType entity with sample data
func newEntityStateDebianEVRStringType(suffix string) *parent.EntityStateDebianEVRStringType {
	return &parent.EntityStateDebianEVRStringType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newEndFunctionType creates a test EndFunctionType entity with sample data
func newEndFunctionType(suffix string) *parent.EndFunctionType {
	return &parent.EndFunctionType{
		Character: "test_character_" + suffix,
	}
}

// newExtended creates a test Extended entity with sample data
func newExtended(suffix string) *parent.Extended {
	return &parent.Extended{
	}
}

// newCpe creates a test Cpe entity with sample data
func newCpe(suffix string) *parent.Cpe {
	return &parent.Cpe{
		ParentID: int64Ptr(42),
	}
}

// newEndorsementLineCodeElementType creates a test EndorsementLineCodeElementType entity with sample data
func newEndorsementLineCodeElementType(suffix string) *parent.EndorsementLineCodeElementType {
	return &parent.EndorsementLineCodeElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newXNL creates a test XNL entity with sample data
func newXNL(suffix string) *parent.XNL {
	return &parent.XNL{
		Version: stringPtr("test_" + suffix),
	}
}

// newPlatformSpecificationElementType creates a test PlatformSpecificationElementType entity with sample data
func newPlatformSpecificationElementType(suffix string) *parent.PlatformSpecificationElementType {
	return &parent.PlatformSpecificationElementType{
	}
}

// newFilterElementType creates a test FilterElementType entity with sample data
func newFilterElementType(suffix string) *parent.FilterElementType {
	return &parent.FilterElementType{
		Action: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newOvalMitreOrgOvalObjectType creates a test OvalMitreOrgOvalObjectType entity with sample data
func newOvalMitreOrgOvalObjectType(suffix string) *parent.OvalMitreOrgOvalObjectType {
	return &parent.OvalMitreOrgOvalObjectType{
		XsdId: "test_xsdid_" + suffix,
		Version: 42,
		Comment: stringPtr("test_" + suffix),
		Deprecated: boolPtr(true),
	}
}

// newEntityObjectBinaryType creates a test EntityObjectBinaryType entity with sample data
func newEntityObjectBinaryType(suffix string) *parent.EntityObjectBinaryType {
	return &parent.EntityObjectBinaryType{
		Datatype: "test_datatype_" + suffix,
		ParentID: int64Ptr(42),
	}
}

// newLocatorType creates a test LocatorType entity with sample data
func newLocatorType(suffix string) *parent.LocatorType {
	return &parent.LocatorType{
	}
}

// newBuildingNameType creates a test BuildingNameType entity with sample data
func newBuildingNameType(suffix string) *parent.BuildingNameType {
	return &parent.BuildingNameType{
		Type: stringPtr("test_" + suffix),
		TypeOccurrence: stringPtr("test_" + suffix),
	}
}

// newPostBoxNumberElementType creates a test PostBoxNumberElementType entity with sample data
func newPostBoxNumberElementType(suffix string) *parent.PostBoxNumberElementType {
	return &parent.PostBoxNumberElementType{
	}
}

// newSignatureValueType creates a test SignatureValueType entity with sample data
func newSignatureValueType(suffix string) *parent.SignatureValueType {
	return &parent.SignatureValueType{
		XsdId: stringPtr("test_" + suffix),
	}
}

// newGlobToRegexFunctionType creates a test GlobToRegexFunctionType entity with sample data
func newGlobToRegexFunctionType(suffix string) *parent.GlobToRegexFunctionType {
	return &parent.GlobToRegexFunctionType{
		Glob_noescape: boolPtr(true),
	}
}

// newFactType creates a test FactType entity with sample data
func newFactType(suffix string) *parent.FactType {
	return &parent.FactType{
		Name: "test_name_" + suffix,
		Type: stringPtr("test_" + suffix),
	}
}

// newHostnameElementType creates a test HostnameElementType entity with sample data
func newHostnameElementType(suffix string) *parent.HostnameElementType {
	return &parent.HostnameElementType{
		ParentID: int64Ptr(42),
	}
}

// newPostOfficeElementType creates a test PostOfficeElementType entity with sample data
func newPostOfficeElementType(suffix string) *parent.PostOfficeElementType {
	return &parent.PostOfficeElementType{
		Type: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		PostalRouteID: int64Ptr(42),
		PostOfficeName: stringPtr("test_" + suffix),
		PostOfficeNumber: stringPtr("test_" + suffix),
	}
}

// newAdministrativeAreaElementType creates a test AdministrativeAreaElementType entity with sample data
func newAdministrativeAreaElementType(suffix string) *parent.AdministrativeAreaElementType {
	return &parent.AdministrativeAreaElementType{
		Type: stringPtr("test_" + suffix),
		UsageType: stringPtr("test_" + suffix),
		Indicator: stringPtr("test_" + suffix),
		AdministrativeAreaName: stringPtr("test_" + suffix),
		SubAdministrativeArea: stringPtr("test_" + suffix),
	}
}

// newPremiseNumberRangeFromElementType creates a test PremiseNumberRangeFromElementType entity with sample data
func newPremiseNumberRangeFromElementType(suffix string) *parent.PremiseNumberRangeFromElementType {
	return &parent.PremiseNumberRangeFromElementType{
	}
}

// newCountryName creates a test CountryName entity with sample data
func newCountryName(suffix string) *parent.CountryName {
	return &parent.CountryName{
		Type: stringPtr("test_" + suffix),
	}
}

// newRetrievalMethodType creates a test RetrievalMethodType entity with sample data
func newRetrievalMethodType(suffix string) *parent.RetrievalMethodType {
	return &parent.RetrievalMethodType{
		URI: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newLogicalTestType creates a test LogicalTestType entity with sample data
func newLogicalTestType(suffix string) *parent.LogicalTestType {
	return &parent.LogicalTestType{
		Operator: "test_operator_" + suffix,
		Negate: true,
	}
}

// newEntityStateAnySimpleType creates a test EntityStateAnySimpleType entity with sample data
func newEntityStateAnySimpleType(suffix string) *parent.EntityStateAnySimpleType {
	return &parent.EntityStateAnySimpleType{
		Datatype: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPremiseNumberSuffixElementType creates a test PremiseNumberSuffixElementType entity with sample data
func newPremiseNumberSuffixElementType(suffix string) *parent.PremiseNumberSuffixElementType {
	return &parent.PremiseNumberSuffixElementType{
		NumberSuffixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newMailStopType creates a test MailStopType entity with sample data
func newMailStopType(suffix string) *parent.MailStopType {
	return &parent.MailStopType{
		Type: stringPtr("test_" + suffix),
		MailStopName: stringPtr("test_" + suffix),
		MailStopNumber: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumberPrefix creates a test ThoroughfareNumberPrefix entity with sample data
func newThoroughfareNumberPrefix(suffix string) *parent.ThoroughfareNumberPrefix {
	return &parent.ThoroughfareNumberPrefix{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newUniqueFunctionType creates a test UniqueFunctionType entity with sample data
func newUniqueFunctionType(suffix string) *parent.UniqueFunctionType {
	return &parent.UniqueFunctionType{
	}
}

// newArithmeticFunctionType creates a test ArithmeticFunctionType entity with sample data
func newArithmeticFunctionType(suffix string) *parent.ArithmeticFunctionType {
	return &parent.ArithmeticFunctionType{
		Arithmetic_operation: "test_arithmetic_operation_" + suffix,
	}
}

// newConstantVariable creates a test ConstantVariable entity with sample data
func newConstantVariable(suffix string) *parent.ConstantVariable {
	return &parent.ConstantVariable{
		ParentID: int64Ptr(42),
	}
}

// newLocalVariable creates a test LocalVariable entity with sample data
func newLocalVariable(suffix string) *parent.LocalVariable {
	return &parent.LocalVariable{
		ParentID: int64Ptr(42),
	}
}

// newBenchmarkElementType creates a test BenchmarkElementType entity with sample data
func newBenchmarkElementType(suffix string) *parent.BenchmarkElementType {
	return &parent.BenchmarkElementType{
		XsdId: "test_xsdid_" + suffix,
		Resolved: boolPtr(true),
		Style: stringPtr("test_" + suffix),
		StyleHref: stringPtr("test_" + suffix),
		VersionID: int64Ptr(42),
		SignatureID: int64Ptr(42),
	}
}

// newXALElementType creates a test XALElementType entity with sample data
func newXALElementType(suffix string) *parent.XALElementType {
	return &parent.XALElementType{
		Version: stringPtr("test_" + suffix),
	}
}

// newThoroughfareNumberPrefixElementType creates a test ThoroughfareNumberPrefixElementType entity with sample data
func newThoroughfareNumberPrefixElementType(suffix string) *parent.ThoroughfareNumberPrefixElementType {
	return &parent.ThoroughfareNumberPrefixElementType{
		NumberPrefixSeparator: stringPtr("test_" + suffix),
		Type: stringPtr("test_" + suffix),
	}
}

// newLargeMailUserType creates a test LargeMailUserType entity with sample data
func newLargeMailUserType(suffix string) *parent.LargeMailUserType {
	return &parent.LargeMailUserType{
		Type: stringPtr("test_" + suffix),
		LargeMailUserName: stringPtr("test_" + suffix),
		LargeMailUserIdentifier: stringPtr("test_" + suffix),
	}
}

// newSubPremiseNameElementType creates a test SubPremiseNameElementType entity with sample data
func newSubPremiseNameElementType(suffix string) *parent.SubPremiseNameElementType {
	return &parent.SubPremiseNameElementType{
		Type: stringPtr("test_" + suffix),
		TypeOccurrence: stringPtr("test_" + suffix),
	}
}

// newTransformType creates a test TransformType entity with sample data
func newTransformType(suffix string) *parent.TransformType {
	return &parent.TransformType{
		Algorithm: "test_algorithm_" + suffix,
		XPath: "test_xpath_" + suffix,
	}
}

// newOvalDefinitions creates a test OvalDefinitions entity with sample data
func newOvalDefinitions(suffix string) *parent.OvalDefinitions {
	return &parent.OvalDefinitions{
		GeneratorID: int64Ptr(42),
		DefinitionsID: int64Ptr(42),
		TestsID: int64Ptr(42),
		ObjectsID: int64Ptr(42),
		StatesID: int64Ptr(42),
		VariablesID: int64Ptr(42),
	}
}

// newNotes creates a test Notes entity with sample data
func newNotes(suffix string) *parent.Notes {
	return &parent.Notes{
		Note: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newResourceType creates a test ResourceType entity with sample data
func newResourceType(suffix string) *parent.ResourceType {
	return &parent.ResourceType{
	}
}

// newCircuitType creates a test CircuitType entity with sample data
func newCircuitType(suffix string) *parent.CircuitType {
	return &parent.CircuitType{
		CircuitName: stringPtr("test_" + suffix),
		ParentID: int64Ptr(42),
	}
}

// newPostTownNameElementType creates a test PostTownNameElementType entity with sample data
func newPostTownNameElementType(suffix string) *parent.PostTownNameElementType {
	return &parent.PostTownNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newPostalServiceElementsElementType creates a test PostalServiceElementsElementType entity with sample data
func newPostalServiceElementsElementType(suffix string) *parent.PostalServiceElementsElementType {
	return &parent.PostalServiceElementsElementType{
		Type: stringPtr("test_" + suffix),
		AddressIdentifier: stringPtr("test_" + suffix),
		EndorsementLineCode: stringPtr("test_" + suffix),
		KeyLineCode: stringPtr("test_" + suffix),
		Barcode: stringPtr("test_" + suffix),
		SortingCode: stringPtr("test_" + suffix),
		AddressLatitude: stringPtr("test_" + suffix),
		AddressLatitudeDirection: stringPtr("test_" + suffix),
		AddressLongitude: stringPtr("test_" + suffix),
		AddressLongitudeDirection: stringPtr("test_" + suffix),
		SupplementaryPostalServiceData: stringPtr("test_" + suffix),
	}
}

// newDepartmentNameElementType creates a test DepartmentNameElementType entity with sample data
func newDepartmentNameElementType(suffix string) *parent.DepartmentNameElementType {
	return &parent.DepartmentNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// newLiteralComponentType creates a test LiteralComponentType entity with sample data
func newLiteralComponentType(suffix string) *parent.LiteralComponentType {
	return &parent.LiteralComponentType{
		Datatype: stringPtr("test_" + suffix),
	}
}

// newSplitFunctionType creates a test SplitFunctionType entity with sample data
func newSplitFunctionType(suffix string) *parent.SplitFunctionType {
	return &parent.SplitFunctionType{
		Delimiter: "test_delimiter_" + suffix,
	}
}

// newConcatFunctionType creates a test ConcatFunctionType entity with sample data
func newConcatFunctionType(suffix string) *parent.ConcatFunctionType {
	return &parent.ConcatFunctionType{
	}
}

// newRuleType creates a test RuleType entity with sample data
func newRuleType(suffix string) *parent.RuleType {
	return &parent.RuleType{
		XsdId: "test_xsdid_" + suffix,
		Role: stringPtr("test_" + suffix),
		Severity: stringPtr("test_" + suffix),
		Multiple: boolPtr(true),
		ImpactMetric: stringPtr("test_" + suffix),
		SignatureID: int64Ptr(42),
		ComplexCheckID: int64Ptr(42),
		ParentID: int64Ptr(42),
	}
}

// newTelephoneNumber creates a test TelephoneNumber entity with sample data
func newTelephoneNumber(suffix string) *parent.TelephoneNumber {
	return &parent.TelephoneNumber{
		ParentID: int64Ptr(42),
	}
}

// newFirmNameElementType creates a test FirmNameElementType entity with sample data
func newFirmNameElementType(suffix string) *parent.FirmNameElementType {
	return &parent.FirmNameElementType{
		Type: stringPtr("test_" + suffix),
	}
}

// TestSqliteConnection tests database connection and schema creation
func TestSqliteConnection(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()

	// Test schema creation
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	// Test schema drop
	if err := dal.DropSchema(ctx); err != nil {
		t.Fatalf("Failed to drop schema: %v", err)
	}

	t.Log("SQLite connection and schema operations successful")
}

// TestSqliteTransaction tests transaction support
func TestSqliteTransaction(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	// Test transaction commit
	tx, err := dal.BeginTx(ctx)
	if err != nil {
		t.Fatalf("Failed to begin transaction: %v", err)
	}
	if err := tx.Commit(); err != nil {
		t.Fatalf("Failed to commit transaction: %v", err)
	}

	// Test transaction rollback
	tx2, err := dal.BeginTx(ctx)
	if err != nil {
		t.Fatalf("Failed to begin transaction: %v", err)
	}
	if err := tx2.Rollback(); err != nil {
		t.Fatalf("Failed to rollback transaction: %v", err)
	}

	t.Log("Transaction support verified")
}

// TestSqliteAddressDetailsRepository tests CRUD operations for address_details table
func TestSqliteAddressDetailsRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressDetails()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressDetails("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressDetails("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressDetails(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressDetails("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Address = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Address != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Address)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressDetails("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressDetails, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressDetails(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressDetails(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressElementTypeRepository tests CRUD operations for address_element_type table
func TestSqliteAddressElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressIdentifierElementTypeRepository tests CRUD operations for address_identifier_element_type table
func TestSqliteAddressIdentifierElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressIdentifierElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressIdentifierElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressIdentifierElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressIdentifierElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressIdentifierElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.IdentifierType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.IdentifierType == nil || *updated.IdentifierType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressIdentifierElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressIdentifierElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressIdentifierElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressIdentifierElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLatitudeDirectionElementTypeRepository tests CRUD operations for address_latitude_direction_element_type table
func TestSqliteAddressLatitudeDirectionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLatitudeDirectionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLatitudeDirectionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLatitudeDirectionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLatitudeDirectionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLatitudeDirectionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLatitudeDirectionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLatitudeDirectionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLatitudeDirectionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLatitudeDirectionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLatitudeElementTypeRepository tests CRUD operations for address_latitude_element_type table
func TestSqliteAddressLatitudeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLatitudeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLatitudeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLatitudeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLatitudeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLatitudeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLatitudeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLatitudeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLatitudeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLatitudeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLineRepository tests CRUD operations for address_line table
func TestSqliteAddressLineRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLine()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLine("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLine("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLine(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLine("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLine("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLine, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLine(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLine(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLineElementTypeRepository tests CRUD operations for address_line_element_type table
func TestSqliteAddressLineElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLineElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLineElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLineElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLineElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLineElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLineElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLineElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLineElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLineElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLinesTypeRepository tests CRUD operations for address_lines_type table
func TestSqliteAddressLinesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLinesType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLinesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLinesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLinesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLinesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLinesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLinesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLinesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLinesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLongitudeDirectionElementTypeRepository tests CRUD operations for address_longitude_direction_element_type table
func TestSqliteAddressLongitudeDirectionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLongitudeDirectionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLongitudeDirectionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLongitudeDirectionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLongitudeDirectionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLongitudeDirectionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLongitudeDirectionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLongitudeDirectionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLongitudeDirectionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLongitudeDirectionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddressLongitudeElementTypeRepository tests CRUD operations for address_longitude_element_type table
func TestSqliteAddressLongitudeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddressLongitudeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddressLongitudeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddressLongitudeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddressLongitudeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddressLongitudeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddressLongitudeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddressLongitudeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddressLongitudeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddressLongitudeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAddresseeIndicatorElementTypeRepository tests CRUD operations for addressee_indicator_element_type table
func TestSqliteAddresseeIndicatorElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AddresseeIndicatorElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAddresseeIndicatorElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAddresseeIndicatorElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAddresseeIndicatorElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAddresseeIndicatorElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Code = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Code == nil || *updated.Code != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAddresseeIndicatorElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AddresseeIndicatorElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAddresseeIndicatorElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAddresseeIndicatorElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAdministrativeAreaRepository tests CRUD operations for administrative_area table
func TestSqliteAdministrativeAreaRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AdministrativeArea()

	t.Run("Create", func(t *testing.T) {
		entity := newAdministrativeArea("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAdministrativeArea("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAdministrativeArea(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeArea("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeArea("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AdministrativeArea, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAdministrativeArea(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAdministrativeArea(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAdministrativeAreaElementTypeRepository tests CRUD operations for administrative_area_element_type table
func TestSqliteAdministrativeAreaElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AdministrativeAreaElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAdministrativeAreaElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAdministrativeAreaElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAdministrativeAreaElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeAreaElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeAreaElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AdministrativeAreaElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAdministrativeAreaElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAdministrativeAreaElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAdministrativeAreaNameElementTypeRepository tests CRUD operations for administrative_area_name_element_type table
func TestSqliteAdministrativeAreaNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AdministrativeAreaNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAdministrativeAreaNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAdministrativeAreaNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAdministrativeAreaNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeAreaNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAdministrativeAreaNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AdministrativeAreaNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAdministrativeAreaNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAdministrativeAreaNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAffectedTypeRepository tests CRUD operations for affected_type table
func TestSqliteAffectedTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AffectedType()

	t.Run("Create", func(t *testing.T) {
		entity := newAffectedType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAffectedType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAffectedType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAffectedType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Family = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Family != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Family)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAffectedType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AffectedType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAffectedType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAffectedType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAliasElementTypeRepository tests CRUD operations for alias_element_type table
func TestSqliteAliasElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AliasElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAliasElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAliasElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAliasElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAliasElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAliasElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AliasElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAliasElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAliasElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteArcTypeRepository tests CRUD operations for arc_type table
func TestSqliteArcTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ArcType()

	t.Run("Create", func(t *testing.T) {
		entity := newArcType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newArcType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newArcType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newArcType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newArcType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ArcType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newArcType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newArcType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteArithmeticFunctionTypeRepository tests CRUD operations for arithmetic_function_type table
func TestSqliteArithmeticFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ArithmeticFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newArithmeticFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newArithmeticFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newArithmeticFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newArithmeticFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Arithmetic_operation = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Arithmetic_operation != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Arithmetic_operation)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newArithmeticFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ArithmeticFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newArithmeticFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newArithmeticFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetIdentificationAssetElementTypeRepository tests CRUD operations for asset_identification_asset_element_type table
func TestSqliteAssetIdentificationAssetElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetIdentificationAssetElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetIdentificationAssetElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetIdentificationAssetElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetIdentificationAssetElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetIdentificationAssetElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetIdentificationAssetElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetIdentificationAssetElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetIdentificationAssetElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetIdentificationAssetElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetIdentificationTypeRepository tests CRUD operations for asset_identification_type table
func TestSqliteAssetIdentificationTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetIdentificationType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetIdentificationType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetIdentificationType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetIdentificationType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetIdentificationType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.AssetRef = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.AssetRef != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.AssetRef)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetIdentificationType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetIdentificationType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetIdentificationType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetIdentificationType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetReportCollectionRepository tests CRUD operations for asset_report_collection table
func TestSqliteAssetReportCollectionRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetReportCollection()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetReportCollection("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetReportCollection("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetReportCollection(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportCollection("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Reports = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Reports != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Reports)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportCollection("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetReportCollection, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetReportCollection(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetReportCollection(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetReportCollectionElementTypeRepository tests CRUD operations for asset_report_collection_element_type table
func TestSqliteAssetReportCollectionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetReportCollectionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetReportCollectionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetReportCollectionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetReportCollectionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportCollectionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Reports = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Reports != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Reports)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportCollectionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetReportCollectionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetReportCollectionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetReportCollectionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetReportingFormAssetElementTypeRepository tests CRUD operations for asset_reporting_form_asset_element_type table
func TestSqliteAssetReportingFormAssetElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetReportingFormAssetElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetReportingFormAssetElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetReportingFormAssetElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetReportingFormAssetElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportingFormAssetElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetReportingFormAssetElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetReportingFormAssetElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetReportingFormAssetElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetReportingFormAssetElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetsElementTypeRepository tests CRUD operations for assets_element_type table
func TestSqliteAssetsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Asset = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Asset != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Asset)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteAssetsTypeRepository tests CRUD operations for assets_type table
func TestSqliteAssetsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.AssetsType()

	t.Run("Create", func(t *testing.T) {
		entity := newAssetsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newAssetsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newAssetsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newAssetsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Asset = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Asset != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Asset)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newAssetsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.AssetsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newAssetsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newAssetsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBarcodeElementTypeRepository tests CRUD operations for barcode_element_type table
func TestSqliteBarcodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BarcodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newBarcodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBarcodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBarcodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBarcodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBarcodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BarcodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBarcodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBarcodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBeginFunctionTypeRepository tests CRUD operations for begin_function_type table
func TestSqliteBeginFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BeginFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newBeginFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBeginFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBeginFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBeginFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Character = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Character != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Character)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBeginFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BeginFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBeginFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBeginFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBenchmarkRepository tests CRUD operations for benchmark table
func TestSqliteBenchmarkRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Benchmark()

	t.Run("Create", func(t *testing.T) {
		entity := newBenchmark("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBenchmark("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBenchmark(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBenchmark("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBenchmark("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Benchmark, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBenchmark(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBenchmark(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBenchmarkElementTypeRepository tests CRUD operations for benchmark_element_type table
func TestSqliteBenchmarkElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BenchmarkElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newBenchmarkElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBenchmarkElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBenchmarkElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBenchmarkElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBenchmarkElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BenchmarkElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBenchmarkElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBenchmarkElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBenchmarkReferenceTypeRepository tests CRUD operations for benchmark_reference_type table
func TestSqliteBenchmarkReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BenchmarkReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newBenchmarkReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBenchmarkReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBenchmarkReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBenchmarkReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Href = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Href != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Href)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBenchmarkReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BenchmarkReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBenchmarkReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBenchmarkReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBirthdateElementTypeRepository tests CRUD operations for birthdate_element_type table
func TestSqliteBirthdateElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BirthdateElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newBirthdateElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBirthdateElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBirthdateElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBirthdateElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBirthdateElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BirthdateElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBirthdateElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBirthdateElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteBuildingNameTypeRepository tests CRUD operations for building_name_type table
func TestSqliteBuildingNameTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.BuildingNameType()

	t.Run("Create", func(t *testing.T) {
		entity := newBuildingNameType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newBuildingNameType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newBuildingNameType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newBuildingNameType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newBuildingNameType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.BuildingNameType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newBuildingNameType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newBuildingNameType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCPE2idrefTypeRepository tests CRUD operations for c_p_e2idref_type table
func TestSqliteCPE2idrefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CPE2idrefType()

	t.Run("Create", func(t *testing.T) {
		entity := newCPE2idrefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCPE2idrefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCPE2idrefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCPE2idrefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCPE2idrefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CPE2idrefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCPE2idrefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCPE2idrefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCanonicalizationMethodTypeRepository tests CRUD operations for canonicalization_method_type table
func TestSqliteCanonicalizationMethodTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CanonicalizationMethodType()

	t.Run("Create", func(t *testing.T) {
		entity := newCanonicalizationMethodType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCanonicalizationMethodType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCanonicalizationMethodType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCanonicalizationMethodType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Algorithm = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Algorithm != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Algorithm)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCanonicalizationMethodType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CanonicalizationMethodType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCanonicalizationMethodType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCanonicalizationMethodType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCheckContentRefTypeRepository tests CRUD operations for check_content_ref_type table
func TestSqliteCheckContentRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CheckContentRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newCheckContentRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCheckContentRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCheckContentRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCheckContentRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Href = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Href != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Href)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCheckContentRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CheckContentRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCheckContentRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCheckContentRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCheckContentTypeRepository tests CRUD operations for check_content_type table
func TestSqliteCheckContentTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CheckContentType()

	t.Run("Create", func(t *testing.T) {
		entity := newCheckContentType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCheckContentType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCheckContentType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCheckContentType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCheckContentType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CheckContentType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCheckContentType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCheckContentType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCheckExportTypeRepository tests CRUD operations for check_export_type table
func TestSqliteCheckExportTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CheckExportType()

	t.Run("Create", func(t *testing.T) {
		entity := newCheckExportType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCheckExportType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCheckExportType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCheckExportType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ValueId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ValueId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ValueId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCheckExportType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CheckExportType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCheckExportType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCheckExportType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCheckImportTypeRepository tests CRUD operations for check_import_type table
func TestSqliteCheckImportTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CheckImportType()

	t.Run("Create", func(t *testing.T) {
		entity := newCheckImportType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCheckImportType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCheckImportType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCheckImportType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ImportName = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ImportName != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ImportName)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCheckImportType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CheckImportType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCheckImportType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCheckImportType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCidrElementTypeRepository tests CRUD operations for cidr_element_type table
func TestSqliteCidrElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CidrElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCidrElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCidrElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCidrElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCidrElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCidrElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CidrElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCidrElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCidrElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCircuitNameElementTypeRepository tests CRUD operations for circuit_name_element_type table
func TestSqliteCircuitNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CircuitNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCircuitNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCircuitNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCircuitNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCircuitNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCircuitNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CircuitNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCircuitNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCircuitNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCircuitTypeRepository tests CRUD operations for circuit_type table
func TestSqliteCircuitTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CircuitType()

	t.Run("Create", func(t *testing.T) {
		entity := newCircuitType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCircuitType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCircuitType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCircuitType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.CircuitName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.CircuitName == nil || *updated.CircuitName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCircuitType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CircuitType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCircuitType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCircuitType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteComplexCheckTypeRepository tests CRUD operations for complex_check_type table
func TestSqliteComplexCheckTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ComplexCheckType()

	t.Run("Create", func(t *testing.T) {
		entity := newComplexCheckType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newComplexCheckType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newComplexCheckType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newComplexCheckType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Operator = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Operator != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Operator)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newComplexCheckType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ComplexCheckType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newComplexCheckType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newComplexCheckType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteComplexValueTypeRepository tests CRUD operations for complex_value_type table
func TestSqliteComplexValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ComplexValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newComplexValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newComplexValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newComplexValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newComplexValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Item = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Item == nil || *updated.Item != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newComplexValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ComplexValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newComplexValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newComplexValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteComputingDeviceTypeRepository tests CRUD operations for computing_device_type table
func TestSqliteComputingDeviceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ComputingDeviceType()

	t.Run("Create", func(t *testing.T) {
		entity := newComputingDeviceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newComputingDeviceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newComputingDeviceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newComputingDeviceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.DistinguishedName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.DistinguishedName == nil || *updated.DistinguishedName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newComputingDeviceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ComputingDeviceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newComputingDeviceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newComputingDeviceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteConcatFunctionTypeRepository tests CRUD operations for concat_function_type table
func TestSqliteConcatFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ConcatFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newConcatFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newConcatFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newConcatFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newConcatFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newConcatFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ConcatFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newConcatFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newConcatFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteConnectionsElementTypeRepository tests CRUD operations for connections_element_type table
func TestSqliteConnectionsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ConnectionsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newConnectionsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newConnectionsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newConnectionsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newConnectionsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newConnectionsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ConnectionsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newConnectionsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newConnectionsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteConstantVariableRepository tests CRUD operations for constant_variable table
func TestSqliteConstantVariableRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ConstantVariable()

	t.Run("Create", func(t *testing.T) {
		entity := newConstantVariable("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newConstantVariable("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newConstantVariable(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newConstantVariable("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newConstantVariable("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ConstantVariable, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newConstantVariable(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newConstantVariable(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteConstantVariableElementTypeRepository tests CRUD operations for constant_variable_element_type table
func TestSqliteConstantVariableElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ConstantVariableElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newConstantVariableElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newConstantVariableElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newConstantVariableElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newConstantVariableElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newConstantVariableElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ConstantVariableElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newConstantVariableElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newConstantVariableElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteContentElementTypeRepository tests CRUD operations for content_element_type table
func TestSqliteContentElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ContentElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newContentElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newContentElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newContentElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newContentElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newContentElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ContentElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newContentElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newContentElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteContentElementType1Repository tests CRUD operations for content_element_type1 table
func TestSqliteContentElementType1Repository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ContentElementType1()

	t.Run("Create", func(t *testing.T) {
		entity := newContentElementType1("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newContentElementType1("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newContentElementType1(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newContentElementType1("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newContentElementType1("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ContentElementType1, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newContentElementType1(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newContentElementType1(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCountFunctionTypeRepository tests CRUD operations for count_function_type table
func TestSqliteCountFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CountFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newCountFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCountFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCountFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCountFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCountFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CountFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCountFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCountFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCountryElementTypeRepository tests CRUD operations for country_element_type table
func TestSqliteCountryElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CountryElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCountryElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCountryElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCountryElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCountryElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.CountryNameCode = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.CountryNameCode == nil || *updated.CountryNameCode != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCountryElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CountryElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCountryElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCountryElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCountryNameRepository tests CRUD operations for country_name table
func TestSqliteCountryNameRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CountryName()

	t.Run("Create", func(t *testing.T) {
		entity := newCountryName("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCountryName("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCountryName(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCountryName("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCountryName("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CountryName, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCountryName(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCountryName(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCountryNameCodeElementTypeRepository tests CRUD operations for country_name_code_element_type table
func TestSqliteCountryNameCodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CountryNameCodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCountryNameCodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCountryNameCodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCountryNameCodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCountryNameCodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Scheme = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Scheme == nil || *updated.Scheme != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCountryNameCodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CountryNameCodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCountryNameCodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCountryNameCodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCountryNameElementTypeRepository tests CRUD operations for country_name_element_type table
func TestSqliteCountryNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CountryNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCountryNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCountryNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCountryNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCountryNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCountryNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CountryNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCountryNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCountryNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCpeRepository tests CRUD operations for cpe table
func TestSqliteCpeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Cpe()

	t.Run("Create", func(t *testing.T) {
		entity := newCpe("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCpe("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCpe(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCpe("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCpe("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Cpe, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCpe(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCpe(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCpeElementTypeRepository tests CRUD operations for cpe_element_type table
func TestSqliteCpeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CpeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newCpeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCpeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCpeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCpeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCpeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CpeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCpeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCpeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCriteriaTypeRepository tests CRUD operations for criteria_type table
func TestSqliteCriteriaTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CriteriaType()

	t.Run("Create", func(t *testing.T) {
		entity := newCriteriaType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCriteriaType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCriteriaType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCriteriaType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Operator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Operator == nil || *updated.Operator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCriteriaType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CriteriaType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCriteriaType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCriteriaType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteCriterionTypeRepository tests CRUD operations for criterion_type table
func TestSqliteCriterionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.CriterionType()

	t.Run("Create", func(t *testing.T) {
		entity := newCriterionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newCriterionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newCriterionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newCriterionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Test_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Test_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Test_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newCriterionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.CriterionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newCriterionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newCriterionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDSAKeyValueTypeRepository tests CRUD operations for d_s_a_key_value_type table
func TestSqliteDSAKeyValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DSAKeyValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newDSAKeyValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDSAKeyValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDSAKeyValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDSAKeyValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDSAKeyValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DSAKeyValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDSAKeyValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDSAKeyValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDataTypeRepository tests CRUD operations for data_type table
func TestSqliteDataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DataType()

	t.Run("Create", func(t *testing.T) {
		entity := newDataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDatabaseTypeRepository tests CRUD operations for database_type table
func TestSqliteDatabaseTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DatabaseType()

	t.Run("Create", func(t *testing.T) {
		entity := newDatabaseType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDatabaseType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDatabaseType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDatabaseType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.InstanceName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.InstanceName == nil || *updated.InstanceName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDatabaseType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DatabaseType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDatabaseType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDatabaseType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDcStatusTypeRepository tests CRUD operations for dc_status_type table
func TestSqliteDcStatusTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DcStatusType()

	t.Run("Create", func(t *testing.T) {
		entity := newDcStatusType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDcStatusType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDcStatusType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDcStatusType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDcStatusType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DcStatusType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDcStatusType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDcStatusType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDefinitionTypeRepository tests CRUD operations for definition_type table
func TestSqliteDefinitionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DefinitionType()

	t.Run("Create", func(t *testing.T) {
		entity := newDefinitionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDefinitionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDefinitionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDefinitionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDefinitionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DefinitionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDefinitionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDefinitionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDefinitionsTypeRepository tests CRUD operations for definitions_type table
func TestSqliteDefinitionsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DefinitionsType()

	t.Run("Create", func(t *testing.T) {
		entity := newDefinitionsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDefinitionsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDefinitionsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDefinitionsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDefinitionsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DefinitionsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDefinitionsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDefinitionsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDepartmentRepository tests CRUD operations for department table
func TestSqliteDepartmentRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Department()

	t.Run("Create", func(t *testing.T) {
		entity := newDepartment("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDepartment("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDepartment(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDepartment("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDepartment("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Department, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDepartment(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDepartment(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDepartmentElementTypeRepository tests CRUD operations for department_element_type table
func TestSqliteDepartmentElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DepartmentElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDepartmentElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDepartmentElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDepartmentElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDepartmentElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDepartmentElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DepartmentElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDepartmentElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDepartmentElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDepartmentNameElementTypeRepository tests CRUD operations for department_name_element_type table
func TestSqliteDepartmentNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DepartmentNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDepartmentNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDepartmentNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDepartmentNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDepartmentNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDepartmentNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DepartmentNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDepartmentNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDepartmentNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDependencyNameElementTypeRepository tests CRUD operations for dependency_name_element_type table
func TestSqliteDependencyNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DependencyNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDependencyNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDependencyNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDependencyNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDependencyNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.DependencyType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.DependencyType == nil || *updated.DependencyType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDependencyNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DependencyNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDependencyNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDependencyNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDependentLocalityNameElementTypeRepository tests CRUD operations for dependent_locality_name_element_type table
func TestSqliteDependentLocalityNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DependentLocalityNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDependentLocalityNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDependentLocalityNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DependentLocalityNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDependentLocalityNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDependentLocalityNumberElementTypeRepository tests CRUD operations for dependent_locality_number_element_type table
func TestSqliteDependentLocalityNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DependentLocalityNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDependentLocalityNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDependentLocalityNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NameNumberOccurrence = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NameNumberOccurrence == nil || *updated.NameNumberOccurrence != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DependentLocalityNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDependentLocalityNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDependentLocalityTypeRepository tests CRUD operations for dependent_locality_type table
func TestSqliteDependentLocalityTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DependentLocalityType()

	t.Run("Create", func(t *testing.T) {
		entity := newDependentLocalityType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDependentLocalityType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDependentLocalityType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DependentLocalityType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDependentLocalityType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDependentLocalityType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDependentThoroughfareElementTypeRepository tests CRUD operations for dependent_thoroughfare_element_type table
func TestSqliteDependentThoroughfareElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DependentThoroughfareElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDependentThoroughfareElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDependentThoroughfareElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDependentThoroughfareElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDependentThoroughfareElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDependentThoroughfareElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DependentThoroughfareElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDependentThoroughfareElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDependentThoroughfareElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDeprecatedInfoTypeRepository tests CRUD operations for deprecated_info_type table
func TestSqliteDeprecatedInfoTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DeprecatedInfoType()

	t.Run("Create", func(t *testing.T) {
		entity := newDeprecatedInfoType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDeprecatedInfoType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDeprecatedInfoType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDeprecatedInfoType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Version)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDeprecatedInfoType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DeprecatedInfoType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDeprecatedInfoType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDeprecatedInfoType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDictionary20CheckTypeRepository tests CRUD operations for dictionary_2_0_check_type table
func TestSqliteDictionary20CheckTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Dictionary20CheckType()

	t.Run("Create", func(t *testing.T) {
		entity := newDictionary20CheckType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDictionary20CheckType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDictionary20CheckType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20CheckType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20CheckType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Dictionary20CheckType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDictionary20CheckType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDictionary20CheckType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDictionary20GeneratorTypeRepository tests CRUD operations for dictionary_2_0_generator_type table
func TestSqliteDictionary20GeneratorTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Dictionary20GeneratorType()

	t.Run("Create", func(t *testing.T) {
		entity := newDictionary20GeneratorType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDictionary20GeneratorType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDictionary20GeneratorType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20GeneratorType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Schema_version = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Schema_version != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Schema_version)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20GeneratorType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Dictionary20GeneratorType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDictionary20GeneratorType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDictionary20GeneratorType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDictionary20ItemTypeRepository tests CRUD operations for dictionary_2_0_item_type table
func TestSqliteDictionary20ItemTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Dictionary20ItemType()

	t.Run("Create", func(t *testing.T) {
		entity := newDictionary20ItemType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDictionary20ItemType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDictionary20ItemType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20ItemType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20ItemType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Dictionary20ItemType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDictionary20ItemType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDictionary20ItemType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDictionary20NotesTypeRepository tests CRUD operations for dictionary_2_0_notes_type table
func TestSqliteDictionary20NotesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Dictionary20NotesType()

	t.Run("Create", func(t *testing.T) {
		entity := newDictionary20NotesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDictionary20NotesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDictionary20NotesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20NotesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Note = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Note != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Note)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20NotesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Dictionary20NotesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDictionary20NotesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDictionary20NotesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDictionary20TextTypeRepository tests CRUD operations for dictionary_2_0_text_type table
func TestSqliteDictionary20TextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Dictionary20TextType()

	t.Run("Create", func(t *testing.T) {
		entity := newDictionary20TextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDictionary20TextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDictionary20TextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20TextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDictionary20TextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Dictionary20TextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDictionary20TextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDictionary20TextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDigestMethodTypeRepository tests CRUD operations for digest_method_type table
func TestSqliteDigestMethodTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DigestMethodType()

	t.Run("Create", func(t *testing.T) {
		entity := newDigestMethodType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDigestMethodType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDigestMethodType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDigestMethodType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Algorithm = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Algorithm != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Algorithm)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDigestMethodType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DigestMethodType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDigestMethodType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDigestMethodType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDistinguishedNameElementTypeRepository tests CRUD operations for distinguished_name_element_type table
func TestSqliteDistinguishedNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DistinguishedNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDistinguishedNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDistinguishedNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDistinguishedNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDistinguishedNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDistinguishedNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DistinguishedNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDistinguishedNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDistinguishedNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteDocumentRootElementTypeRepository tests CRUD operations for document_root_element_type table
func TestSqliteDocumentRootElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.DocumentRootElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newDocumentRootElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newDocumentRootElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newDocumentRootElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newDocumentRootElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newDocumentRootElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.DocumentRootElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newDocumentRootElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newDocumentRootElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteElementMapItemTypeRepository tests CRUD operations for element_map_item_type table
func TestSqliteElementMapItemTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ElementMapItemType()

	t.Run("Create", func(t *testing.T) {
		entity := newElementMapItemType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newElementMapItemType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newElementMapItemType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newElementMapItemType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Target_namespace = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Target_namespace == nil || *updated.Target_namespace != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newElementMapItemType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ElementMapItemType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newElementMapItemType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newElementMapItemType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteElementMapTypeRepository tests CRUD operations for element_map_type table
func TestSqliteElementMapTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ElementMapType()

	t.Run("Create", func(t *testing.T) {
		entity := newElementMapType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newElementMapType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newElementMapType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newElementMapType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newElementMapType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ElementMapType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newElementMapType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newElementMapType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEmailAddressRepository tests CRUD operations for email_address table
func TestSqliteEmailAddressRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EmailAddress()

	t.Run("Create", func(t *testing.T) {
		entity := newEmailAddress("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEmailAddress("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEmailAddress(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEmailAddress("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEmailAddress("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EmailAddress, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEmailAddress(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEmailAddress(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEmailAddressElementTypeRepository tests CRUD operations for email_address_element_type table
func TestSqliteEmailAddressElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EmailAddressElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newEmailAddressElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEmailAddressElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEmailAddressElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEmailAddressElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEmailAddressElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EmailAddressElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEmailAddressElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEmailAddressElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEndFunctionTypeRepository tests CRUD operations for end_function_type table
func TestSqliteEndFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EndFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEndFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEndFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEndFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEndFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Character = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Character != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Character)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEndFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EndFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEndFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEndFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEndorsementLineCodeElementTypeRepository tests CRUD operations for endorsement_line_code_element_type table
func TestSqliteEndorsementLineCodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EndorsementLineCodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newEndorsementLineCodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEndorsementLineCodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEndorsementLineCodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEndorsementLineCodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEndorsementLineCodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EndorsementLineCodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEndorsementLineCodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEndorsementLineCodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectAnySimpleTypeRepository tests CRUD operations for entity_object_any_simple_type table
func TestSqliteEntityObjectAnySimpleTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectAnySimpleType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectAnySimpleType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectAnySimpleType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectAnySimpleType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectAnySimpleType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectAnySimpleType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectAnySimpleType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectAnySimpleType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectAnySimpleType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectBinaryTypeRepository tests CRUD operations for entity_object_binary_type table
func TestSqliteEntityObjectBinaryTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectBinaryType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectBinaryType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectBinaryType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectBinaryType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectBinaryType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectBinaryType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectBinaryType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectBinaryType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectBinaryType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectBoolTypeRepository tests CRUD operations for entity_object_bool_type table
func TestSqliteEntityObjectBoolTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectBoolType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectBoolType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectBoolType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectBoolType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectBoolType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectBoolType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectBoolType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectBoolType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectBoolType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectFieldTypeRepository tests CRUD operations for entity_object_field_type table
func TestSqliteEntityObjectFieldTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectFieldType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectFieldType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectFieldType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectFieldType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectFieldType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectFieldType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectFieldType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectFieldType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectFieldType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectFloatTypeRepository tests CRUD operations for entity_object_float_type table
func TestSqliteEntityObjectFloatTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectFloatType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectFloatType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectFloatType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectFloatType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectFloatType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectFloatType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectFloatType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectFloatType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectFloatType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectIPAddressStringTypeRepository tests CRUD operations for entity_object_i_p_address_string_type table
func TestSqliteEntityObjectIPAddressStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectIPAddressStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectIPAddressStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectIPAddressStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIPAddressStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIPAddressStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIPAddressStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectIPAddressStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectIPAddressStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIPAddressStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectIPAddressTypeRepository tests CRUD operations for entity_object_i_p_address_type table
func TestSqliteEntityObjectIPAddressTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectIPAddressType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectIPAddressType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectIPAddressType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIPAddressType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIPAddressType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIPAddressType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectIPAddressType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectIPAddressType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIPAddressType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectIntTypeRepository tests CRUD operations for entity_object_int_type table
func TestSqliteEntityObjectIntTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectIntType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectIntType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectIntType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIntType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIntType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectIntType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectIntType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectIntType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectIntType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectRecordTypeRepository tests CRUD operations for entity_object_record_type table
func TestSqliteEntityObjectRecordTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectRecordType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectRecordType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectRecordType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectRecordType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectRecordType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectRecordType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectRecordType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectRecordType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectRecordType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectStringTypeRepository tests CRUD operations for entity_object_string_type table
func TestSqliteEntityObjectStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityObjectVersionTypeRepository tests CRUD operations for entity_object_version_type table
func TestSqliteEntityObjectVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityObjectVersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityObjectVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityObjectVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityObjectVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityObjectVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityObjectVersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityObjectVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityObjectVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateAnySimpleTypeRepository tests CRUD operations for entity_state_any_simple_type table
func TestSqliteEntityStateAnySimpleTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateAnySimpleType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateAnySimpleType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateAnySimpleType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateAnySimpleType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateAnySimpleType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateAnySimpleType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateAnySimpleType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateAnySimpleType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateAnySimpleType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateBinaryTypeRepository tests CRUD operations for entity_state_binary_type table
func TestSqliteEntityStateBinaryTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateBinaryType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateBinaryType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateBinaryType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateBinaryType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateBinaryType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateBinaryType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateBinaryType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateBinaryType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateBinaryType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateBoolTypeRepository tests CRUD operations for entity_state_bool_type table
func TestSqliteEntityStateBoolTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateBoolType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateBoolType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateBoolType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateBoolType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateBoolType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateBoolType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateBoolType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateBoolType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateBoolType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateDebianEVRStringTypeRepository tests CRUD operations for entity_state_debian_e_v_r_string_type table
func TestSqliteEntityStateDebianEVRStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateDebianEVRStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateDebianEVRStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateDebianEVRStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateDebianEVRStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateDebianEVRStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateDebianEVRStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateDebianEVRStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateDebianEVRStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateDebianEVRStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateEVRStringTypeRepository tests CRUD operations for entity_state_e_v_r_string_type table
func TestSqliteEntityStateEVRStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateEVRStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateEVRStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateEVRStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateEVRStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateEVRStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateEVRStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateEVRStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateEVRStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateEVRStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateFieldTypeRepository tests CRUD operations for entity_state_field_type table
func TestSqliteEntityStateFieldTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateFieldType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateFieldType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateFieldType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateFieldType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFieldType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFieldType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateFieldType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateFieldType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateFieldType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateFileSetRevisionTypeRepository tests CRUD operations for entity_state_file_set_revision_type table
func TestSqliteEntityStateFileSetRevisionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateFileSetRevisionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateFileSetRevisionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateFileSetRevisionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateFileSetRevisionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFileSetRevisionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFileSetRevisionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateFileSetRevisionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateFileSetRevisionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateFileSetRevisionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateFloatTypeRepository tests CRUD operations for entity_state_float_type table
func TestSqliteEntityStateFloatTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateFloatType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateFloatType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateFloatType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateFloatType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFloatType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateFloatType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateFloatType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateFloatType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateFloatType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateIOSVersionTypeRepository tests CRUD operations for entity_state_i_o_s_version_type table
func TestSqliteEntityStateIOSVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateIOSVersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateIOSVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateIOSVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateIOSVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIOSVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIOSVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateIOSVersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateIOSVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateIOSVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateIPAddressStringTypeRepository tests CRUD operations for entity_state_i_p_address_string_type table
func TestSqliteEntityStateIPAddressStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateIPAddressStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateIPAddressStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateIPAddressStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateIPAddressStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIPAddressStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIPAddressStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateIPAddressStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateIPAddressStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateIPAddressStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateIPAddressTypeRepository tests CRUD operations for entity_state_i_p_address_type table
func TestSqliteEntityStateIPAddressTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateIPAddressType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateIPAddressType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateIPAddressType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateIPAddressType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIPAddressType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIPAddressType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateIPAddressType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateIPAddressType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateIPAddressType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateIntTypeRepository tests CRUD operations for entity_state_int_type table
func TestSqliteEntityStateIntTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateIntType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateIntType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateIntType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateIntType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIntType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateIntType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateIntType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateIntType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateIntType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateRecordTypeRepository tests CRUD operations for entity_state_record_type table
func TestSqliteEntityStateRecordTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateRecordType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateRecordType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateRecordType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateRecordType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateRecordType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateRecordType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateRecordType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateRecordType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateRecordType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateStringTypeRepository tests CRUD operations for entity_state_string_type table
func TestSqliteEntityStateStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEntityStateVersionTypeRepository tests CRUD operations for entity_state_version_type table
func TestSqliteEntityStateVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EntityStateVersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEntityStateVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEntityStateVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEntityStateVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Datatype)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEntityStateVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EntityStateVersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEntityStateVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEntityStateVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteEscapeRegexFunctionTypeRepository tests CRUD operations for escape_regex_function_type table
func TestSqliteEscapeRegexFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.EscapeRegexFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newEscapeRegexFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newEscapeRegexFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newEscapeRegexFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newEscapeRegexFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newEscapeRegexFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.EscapeRegexFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newEscapeRegexFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newEscapeRegexFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExtendDefinitionTypeRepository tests CRUD operations for extend_definition_type table
func TestSqliteExtendDefinitionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExtendDefinitionType()

	t.Run("Create", func(t *testing.T) {
		entity := newExtendDefinitionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExtendDefinitionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExtendDefinitionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExtendDefinitionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Definition_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Definition_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Definition_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExtendDefinitionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExtendDefinitionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExtendDefinitionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExtendDefinitionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExtendedRepository tests CRUD operations for extended table
func TestSqliteExtendedRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Extended()

	t.Run("Create", func(t *testing.T) {
		entity := newExtended("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExtended("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExtended(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExtended("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExtended("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Extended, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExtended(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExtended(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExtendedInfoElementTypeRepository tests CRUD operations for extended_info_element_type table
func TestSqliteExtendedInfoElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExtendedInfoElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newExtendedInfoElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExtendedInfoElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExtendedInfoElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInfoElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInfoElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExtendedInfoElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExtendedInfoElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExtendedInfoElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExtendedInformationElementTypeRepository tests CRUD operations for extended_information_element_type table
func TestSqliteExtendedInformationElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExtendedInformationElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newExtendedInformationElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExtendedInformationElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExtendedInformationElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInformationElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInformationElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExtendedInformationElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExtendedInformationElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExtendedInformationElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExtendedInfosElementTypeRepository tests CRUD operations for extended_infos_element_type table
func TestSqliteExtendedInfosElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExtendedInfosElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newExtendedInfosElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExtendedInfosElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExtendedInfosElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInfosElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ExtendedInfo = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ExtendedInfo != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ExtendedInfo)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExtendedInfosElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExtendedInfosElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExtendedInfosElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExtendedInfosElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExternalVariableRepository tests CRUD operations for external_variable table
func TestSqliteExternalVariableRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExternalVariable()

	t.Run("Create", func(t *testing.T) {
		entity := newExternalVariable("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExternalVariable("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExternalVariable(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExternalVariable("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExternalVariable("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExternalVariable, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExternalVariable(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExternalVariable(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteExternalVariableElementTypeRepository tests CRUD operations for external_variable_element_type table
func TestSqliteExternalVariableElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ExternalVariableElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newExternalVariableElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newExternalVariableElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newExternalVariableElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newExternalVariableElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newExternalVariableElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ExternalVariableElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newExternalVariableElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newExternalVariableElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFactRefTypeRepository tests CRUD operations for fact_ref_type table
func TestSqliteFactRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FactRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newFactRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFactRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFactRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFactRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFactRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FactRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFactRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFactRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFactTypeRepository tests CRUD operations for fact_type table
func TestSqliteFactTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FactType()

	t.Run("Create", func(t *testing.T) {
		entity := newFactType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFactType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFactType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFactType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFactType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FactType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFactType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFactType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFilterRepository tests CRUD operations for filter table
func TestSqliteFilterRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Filter()

	t.Run("Create", func(t *testing.T) {
		entity := newFilter("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFilter("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFilter(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFilter("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Action = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Action == nil || *updated.Action != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFilter("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Filter, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFilter(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFilter(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFilterElementTypeRepository tests CRUD operations for filter_element_type table
func TestSqliteFilterElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FilterElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newFilterElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFilterElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFilterElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFilterElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Action = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Action == nil || *updated.Action != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFilterElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FilterElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFilterElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFilterElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFirmNameElementTypeRepository tests CRUD operations for firm_name_element_type table
func TestSqliteFirmNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FirmNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newFirmNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFirmNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFirmNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFirmNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFirmNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FirmNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFirmNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFirmNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFirmTypeRepository tests CRUD operations for firm_type table
func TestSqliteFirmTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FirmType()

	t.Run("Create", func(t *testing.T) {
		entity := newFirmType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFirmType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFirmType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFirmType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFirmType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FirmType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFirmType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFirmType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFirstNameElementTypeRepository tests CRUD operations for first_name_element_type table
func TestSqliteFirstNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FirstNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newFirstNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFirstNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFirstNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFirstNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFirstNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FirstNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFirstNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFirstNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFixTextTypeRepository tests CRUD operations for fix_text_type table
func TestSqliteFixTextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FixTextType()

	t.Run("Create", func(t *testing.T) {
		entity := newFixTextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFixTextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFixTextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFixTextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Fixref = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Fixref == nil || *updated.Fixref != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFixTextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FixTextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFixTextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFixTextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFixTypeRepository tests CRUD operations for fix_type table
func TestSqliteFixTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FixType()

	t.Run("Create", func(t *testing.T) {
		entity := newFixType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFixType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFixType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFixType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFixType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FixType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFixType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFixType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFormerNameElementTypeRepository tests CRUD operations for former_name_element_type table
func TestSqliteFormerNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FormerNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newFormerNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFormerNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFormerNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFormerNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ValidFrom = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ValidFrom == nil || *updated.ValidFrom != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFormerNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FormerNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFormerNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFormerNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFqdnRepository tests CRUD operations for fqdn table
func TestSqliteFqdnRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Fqdn()

	t.Run("Create", func(t *testing.T) {
		entity := newFqdn("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFqdn("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFqdn(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFqdn("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFqdn("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Fqdn, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFqdn(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFqdn(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFqdnElementTypeRepository tests CRUD operations for fqdn_element_type table
func TestSqliteFqdnElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.FqdnElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newFqdnElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFqdnElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFqdnElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFqdnElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFqdnElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.FqdnElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFqdnElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFqdnElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteFunctionRepository tests CRUD operations for function table
func TestSqliteFunctionRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Function()

	t.Run("Create", func(t *testing.T) {
		entity := newFunction("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newFunction("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newFunction(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newFunction("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Code = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Code == nil || *updated.Code != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newFunction("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Function, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newFunction(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newFunction(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteGeneralSuffixElementTypeRepository tests CRUD operations for general_suffix_element_type table
func TestSqliteGeneralSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.GeneralSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newGeneralSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newGeneralSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newGeneralSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newGeneralSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newGeneralSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.GeneralSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newGeneralSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newGeneralSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteGenerationIdentifierElementTypeRepository tests CRUD operations for generation_identifier_element_type table
func TestSqliteGenerationIdentifierElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.GenerationIdentifierElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newGenerationIdentifierElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newGenerationIdentifierElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newGenerationIdentifierElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newGenerationIdentifierElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newGenerationIdentifierElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.GenerationIdentifierElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newGenerationIdentifierElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newGenerationIdentifierElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteGlobToRegexFunctionTypeRepository tests CRUD operations for glob_to_regex_function_type table
func TestSqliteGlobToRegexFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.GlobToRegexFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newGlobToRegexFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newGlobToRegexFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newGlobToRegexFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newGlobToRegexFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newGlobToRegexFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.GlobToRegexFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newGlobToRegexFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newGlobToRegexFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteGroupTypeRepository tests CRUD operations for group_type table
func TestSqliteGroupTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.GroupType()

	t.Run("Create", func(t *testing.T) {
		entity := newGroupType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newGroupType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newGroupType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newGroupType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newGroupType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.GroupType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newGroupType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newGroupType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteHostElementTypeRepository tests CRUD operations for host_element_type table
func TestSqliteHostElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.HostElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newHostElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newHostElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newHostElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newHostElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newHostElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.HostElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newHostElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newHostElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteHostnameElementTypeRepository tests CRUD operations for hostname_element_type table
func TestSqliteHostnameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.HostnameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newHostnameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newHostnameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newHostnameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newHostnameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newHostnameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.HostnameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newHostnameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newHostnameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteHtmlTextTypeRepository tests CRUD operations for html_text_type table
func TestSqliteHtmlTextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.HtmlTextType()

	t.Run("Create", func(t *testing.T) {
		entity := newHtmlTextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newHtmlTextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newHtmlTextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newHtmlTextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newHtmlTextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.HtmlTextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newHtmlTextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newHtmlTextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteHtmlTextWithSubTypeRepository tests CRUD operations for html_text_with_sub_type table
func TestSqliteHtmlTextWithSubTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.HtmlTextWithSubType()

	t.Run("Create", func(t *testing.T) {
		entity := newHtmlTextWithSubType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newHtmlTextWithSubType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newHtmlTextWithSubType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newHtmlTextWithSubType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newHtmlTextWithSubType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.HtmlTextWithSubType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newHtmlTextWithSubType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newHtmlTextWithSubType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIdentTypeRepository tests CRUD operations for ident_type table
func TestSqliteIdentTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IdentType()

	t.Run("Create", func(t *testing.T) {
		entity := newIdentType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIdentType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIdentType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIdentType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIdentType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IdentType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIdentType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIdentType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIdentityTypeRepository tests CRUD operations for identity_type table
func TestSqliteIdentityTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IdentityType()

	t.Run("Create", func(t *testing.T) {
		entity := newIdentityType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIdentityType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIdentityType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIdentityType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIdentityType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IdentityType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIdentityType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIdentityType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIdrefListTypeRepository tests CRUD operations for idref_list_type table
func TestSqliteIdrefListTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IdrefListType()

	t.Run("Create", func(t *testing.T) {
		entity := newIdrefListType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIdrefListType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIdrefListType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIdrefListType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIdrefListType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IdrefListType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIdrefListType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIdrefListType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIdrefTypeRepository tests CRUD operations for idref_type table
func TestSqliteIdrefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IdrefType()

	t.Run("Create", func(t *testing.T) {
		entity := newIdrefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIdrefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIdrefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIdrefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIdrefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IdrefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIdrefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIdrefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteInstallationIdElementTypeRepository tests CRUD operations for installation_id_element_type table
func TestSqliteInstallationIdElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.InstallationIdElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newInstallationIdElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newInstallationIdElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newInstallationIdElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newInstallationIdElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newInstallationIdElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.InstallationIdElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newInstallationIdElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newInstallationIdElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteInstanceFixTypeRepository tests CRUD operations for instance_fix_type table
func TestSqliteInstanceFixTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.InstanceFixType()

	t.Run("Create", func(t *testing.T) {
		entity := newInstanceFixType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newInstanceFixType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newInstanceFixType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newInstanceFixType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Context = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Context == nil || *updated.Context != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newInstanceFixType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.InstanceFixType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newInstanceFixType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newInstanceFixType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteInstanceNameElementTypeRepository tests CRUD operations for instance_name_element_type table
func TestSqliteInstanceNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.InstanceNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newInstanceNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newInstanceNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newInstanceNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newInstanceNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newInstanceNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.InstanceNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newInstanceNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newInstanceNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteInstanceResultTypeRepository tests CRUD operations for instance_result_type table
func TestSqliteInstanceResultTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.InstanceResultType()

	t.Run("Create", func(t *testing.T) {
		entity := newInstanceResultType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newInstanceResultType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newInstanceResultType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newInstanceResultType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Context = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Context == nil || *updated.Context != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newInstanceResultType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.InstanceResultType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newInstanceResultType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newInstanceResultType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIpAddressTypeRepository tests CRUD operations for ip_address_type table
func TestSqliteIpAddressTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IpAddressType()

	t.Run("Create", func(t *testing.T) {
		entity := newIpAddressType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIpAddressType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIpAddressType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIpAddressType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.IpV4 = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.IpV4 == nil || *updated.IpV4 != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIpAddressType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IpAddressType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIpAddressType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIpAddressType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIpNetRangeElementTypeRepository tests CRUD operations for ip_net_range_element_type table
func TestSqliteIpNetRangeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IpNetRangeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newIpNetRangeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIpNetRangeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIpNetRangeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIpNetRangeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIpNetRangeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IpNetRangeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIpNetRangeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIpNetRangeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIpV4ElementTypeRepository tests CRUD operations for ip_v4_element_type table
func TestSqliteIpV4ElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IpV4ElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newIpV4ElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIpV4ElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIpV4ElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIpV4ElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIpV4ElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IpV4ElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIpV4ElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIpV4ElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteIpV6ElementTypeRepository tests CRUD operations for ip_v6_element_type table
func TestSqliteIpV6ElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.IpV6ElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newIpV6ElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newIpV6ElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newIpV6ElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newIpV6ElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newIpV6ElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.IpV6ElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newIpV6ElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newIpV6ElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteJointPersonNameRepository tests CRUD operations for joint_person_name table
func TestSqliteJointPersonNameRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.JointPersonName()

	t.Run("Create", func(t *testing.T) {
		entity := newJointPersonName("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newJointPersonName("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newJointPersonName(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newJointPersonName("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.JointNameConnector = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.JointNameConnector == nil || *updated.JointNameConnector != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newJointPersonName("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.JointPersonName, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newJointPersonName(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newJointPersonName(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteJointPersonNameElementTypeRepository tests CRUD operations for joint_person_name_element_type table
func TestSqliteJointPersonNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.JointPersonNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newJointPersonNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newJointPersonNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newJointPersonNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newJointPersonNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.JointNameConnector = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.JointNameConnector == nil || *updated.JointNameConnector != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newJointPersonNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.JointPersonNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newJointPersonNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newJointPersonNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteKeyInfoTypeRepository tests CRUD operations for key_info_type table
func TestSqliteKeyInfoTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.KeyInfoType()

	t.Run("Create", func(t *testing.T) {
		entity := newKeyInfoType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newKeyInfoType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newKeyInfoType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newKeyInfoType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newKeyInfoType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.KeyInfoType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newKeyInfoType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newKeyInfoType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteKeyLineCodeElementTypeRepository tests CRUD operations for key_line_code_element_type table
func TestSqliteKeyLineCodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.KeyLineCodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newKeyLineCodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newKeyLineCodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newKeyLineCodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newKeyLineCodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newKeyLineCodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.KeyLineCodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newKeyLineCodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newKeyLineCodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteKeyValueTypeRepository tests CRUD operations for key_value_type table
func TestSqliteKeyValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.KeyValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newKeyValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newKeyValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newKeyValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newKeyValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newKeyValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.KeyValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newKeyValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newKeyValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteKnownAsElementTypeRepository tests CRUD operations for known_as_element_type table
func TestSqliteKnownAsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.KnownAsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newKnownAsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newKnownAsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newKnownAsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newKnownAsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ValidFrom = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ValidFrom == nil || *updated.ValidFrom != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newKnownAsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.KnownAsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newKnownAsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newKnownAsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLanguage20TextTypeRepository tests CRUD operations for language_2_0_text_type table
func TestSqliteLanguage20TextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Language20TextType()

	t.Run("Create", func(t *testing.T) {
		entity := newLanguage20TextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLanguage20TextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLanguage20TextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLanguage20TextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLanguage20TextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Language20TextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLanguage20TextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLanguage20TextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLargeMailUserIdentifierElementTypeRepository tests CRUD operations for large_mail_user_identifier_element_type table
func TestSqliteLargeMailUserIdentifierElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LargeMailUserIdentifierElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLargeMailUserIdentifierElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLargeMailUserIdentifierElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserIdentifierElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserIdentifierElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserIdentifierElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LargeMailUserIdentifierElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLargeMailUserIdentifierElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserIdentifierElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLargeMailUserNameElementTypeRepository tests CRUD operations for large_mail_user_name_element_type table
func TestSqliteLargeMailUserNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LargeMailUserNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLargeMailUserNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLargeMailUserNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LargeMailUserNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLargeMailUserNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLargeMailUserTypeRepository tests CRUD operations for large_mail_user_type table
func TestSqliteLargeMailUserTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LargeMailUserType()

	t.Run("Create", func(t *testing.T) {
		entity := newLargeMailUserType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLargeMailUserType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLargeMailUserType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LargeMailUserType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLargeMailUserType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLargeMailUserType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLastNameElementTypeRepository tests CRUD operations for last_name_element_type table
func TestSqliteLastNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LastNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLastNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLastNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLastNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLastNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLastNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LastNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLastNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLastNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLicenseElementTypeRepository tests CRUD operations for license_element_type table
func TestSqliteLicenseElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LicenseElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLicenseElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLicenseElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLicenseElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLicenseElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLicenseElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LicenseElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLicenseElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLicenseElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteListTypeRepository tests CRUD operations for list_type table
func TestSqliteListTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ListType()

	t.Run("Create", func(t *testing.T) {
		entity := newListType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newListType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newListType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newListType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newListType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ListType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newListType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newListType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLiteralComponentTypeRepository tests CRUD operations for literal_component_type table
func TestSqliteLiteralComponentTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LiteralComponentType()

	t.Run("Create", func(t *testing.T) {
		entity := newLiteralComponentType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLiteralComponentType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLiteralComponentType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLiteralComponentType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Datatype = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Datatype == nil || *updated.Datatype != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLiteralComponentType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LiteralComponentType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLiteralComponentType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLiteralComponentType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocalVariableRepository tests CRUD operations for local_variable table
func TestSqliteLocalVariableRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocalVariable()

	t.Run("Create", func(t *testing.T) {
		entity := newLocalVariable("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocalVariable("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocalVariable(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocalVariable("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocalVariable("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocalVariable, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocalVariable(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocalVariable(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocalVariableElementTypeRepository tests CRUD operations for local_variable_element_type table
func TestSqliteLocalVariableElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocalVariableElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocalVariableElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocalVariableElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocalVariableElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocalVariableElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocalVariableElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocalVariableElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocalVariableElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocalVariableElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocaleElementTypeRepository tests CRUD operations for locale_element_type table
func TestSqliteLocaleElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocaleElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocaleElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocaleElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocaleElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocaleElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocaleElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocaleElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocaleElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocaleElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocalityRepository tests CRUD operations for locality table
func TestSqliteLocalityRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Locality()

	t.Run("Create", func(t *testing.T) {
		entity := newLocality("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocality("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocality(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocality("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocality("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Locality, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocality(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocality(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocalityElementTypeRepository tests CRUD operations for locality_element_type table
func TestSqliteLocalityElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocalityElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocalityElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocalityElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocalityElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocalityElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocalityElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocalityElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocalityElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocalityElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocalityNameElementTypeRepository tests CRUD operations for locality_name_element_type table
func TestSqliteLocalityNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocalityNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocalityNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocalityNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocalityNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocalityNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocalityNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocalityNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocalityNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocalityNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationPointRepository tests CRUD operations for location_point table
func TestSqliteLocationPointRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocationPoint()

	t.Run("Create", func(t *testing.T) {
		entity := newLocationPoint("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocationPoint("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocationPoint(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocationPoint("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Latitude = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Latitude != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Latitude)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocationPoint("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocationPoint, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocationPoint(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocationPoint(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationPointElementTypeRepository tests CRUD operations for location_point_element_type table
func TestSqliteLocationPointElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocationPointElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocationPointElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocationPointElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocationPointElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocationPointElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Latitude = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Latitude != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Latitude)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocationPointElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocationPointElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocationPointElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocationPointElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationRegionRepository tests CRUD operations for location_region table
func TestSqliteLocationRegionRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocationRegion()

	t.Run("Create", func(t *testing.T) {
		entity := newLocationRegion("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocationRegion("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocationRegion(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocationRegion("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocationRegion("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocationRegion, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocationRegion(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocationRegion(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationRegionElementTypeRepository tests CRUD operations for location_region_element_type table
func TestSqliteLocationRegionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocationRegionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocationRegionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocationRegionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocationRegionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocationRegionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocationRegionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocationRegionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocationRegionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocationRegionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationsRepository tests CRUD operations for locations table
func TestSqliteLocationsRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Locations()

	t.Run("Create", func(t *testing.T) {
		entity := newLocations("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocations("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocations(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocations("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocations("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Locations, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocations(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocations(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocationsElementTypeRepository tests CRUD operations for locations_element_type table
func TestSqliteLocationsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocationsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocationsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocationsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocationsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocationsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocationsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocationsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocationsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocationsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLocatorTypeRepository tests CRUD operations for locator_type table
func TestSqliteLocatorTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LocatorType()

	t.Run("Create", func(t *testing.T) {
		entity := newLocatorType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLocatorType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLocatorType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLocatorType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLocatorType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LocatorType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLocatorType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLocatorType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteLogicalTestTypeRepository tests CRUD operations for logical_test_type table
func TestSqliteLogicalTestTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.LogicalTestType()

	t.Run("Create", func(t *testing.T) {
		entity := newLogicalTestType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newLogicalTestType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newLogicalTestType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newLogicalTestType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Operator = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Operator != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Operator)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newLogicalTestType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.LogicalTestType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newLogicalTestType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newLogicalTestType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMacAddressElementTypeRepository tests CRUD operations for mac_address_element_type table
func TestSqliteMacAddressElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MacAddressElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newMacAddressElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMacAddressElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMacAddressElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMacAddressElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMacAddressElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MacAddressElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMacAddressElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMacAddressElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMailStopNameElementTypeRepository tests CRUD operations for mail_stop_name_element_type table
func TestSqliteMailStopNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MailStopNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newMailStopNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMailStopNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMailStopNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMailStopNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMailStopNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MailStopNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMailStopNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMailStopNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMailStopNumberElementTypeRepository tests CRUD operations for mail_stop_number_element_type table
func TestSqliteMailStopNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MailStopNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newMailStopNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMailStopNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMailStopNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMailStopNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NameNumberSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NameNumberSeparator == nil || *updated.NameNumberSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMailStopNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MailStopNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMailStopNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMailStopNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMailStopTypeRepository tests CRUD operations for mail_stop_type table
func TestSqliteMailStopTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MailStopType()

	t.Run("Create", func(t *testing.T) {
		entity := newMailStopType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMailStopType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMailStopType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMailStopType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMailStopType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MailStopType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMailStopType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMailStopType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteManifestTypeRepository tests CRUD operations for manifest_type table
func TestSqliteManifestTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ManifestType()

	t.Run("Create", func(t *testing.T) {
		entity := newManifestType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newManifestType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newManifestType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newManifestType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newManifestType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ManifestType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newManifestType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newManifestType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMiddleNameElementTypeRepository tests CRUD operations for middle_name_element_type table
func TestSqliteMiddleNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MiddleNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newMiddleNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMiddleNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMiddleNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMiddleNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMiddleNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MiddleNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMiddleNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMiddleNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteModelRepository tests CRUD operations for model table
func TestSqliteModelRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Model()

	t.Run("Create", func(t *testing.T) {
		entity := newModel("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newModel("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newModel(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newModel("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newModel("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Model, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newModel(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newModel(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteModelElementTypeRepository tests CRUD operations for model_element_type table
func TestSqliteModelElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ModelElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newModelElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newModelElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newModelElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newModelElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newModelElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ModelElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newModelElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newModelElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteMotherboardGuidElementTypeRepository tests CRUD operations for motherboard_guid_element_type table
func TestSqliteMotherboardGuidElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.MotherboardGuidElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newMotherboardGuidElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newMotherboardGuidElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newMotherboardGuidElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newMotherboardGuidElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newMotherboardGuidElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.MotherboardGuidElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newMotherboardGuidElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newMotherboardGuidElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNameDetailsElementTypeRepository tests CRUD operations for name_details_element_type table
func TestSqliteNameDetailsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NameDetailsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newNameDetailsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNameDetailsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNameDetailsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNameDetailsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NameDetailsKey = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NameDetailsKey == nil || *updated.NameDetailsKey != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNameDetailsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NameDetailsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNameDetailsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNameDetailsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNameLineTypeRepository tests CRUD operations for name_line_type table
func TestSqliteNameLineTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NameLineType()

	t.Run("Create", func(t *testing.T) {
		entity := newNameLineType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNameLineType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNameLineType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNameLineType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNameLineType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NameLineType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNameLineType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNameLineType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNamePrefixElementTypeRepository tests CRUD operations for name_prefix_element_type table
func TestSqliteNamePrefixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NamePrefixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newNamePrefixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNamePrefixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNamePrefixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNamePrefixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNamePrefixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NamePrefixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNamePrefixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNamePrefixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNetworkInterfaceTypeRepository tests CRUD operations for network_interface_type table
func TestSqliteNetworkInterfaceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NetworkInterfaceType()

	t.Run("Create", func(t *testing.T) {
		entity := newNetworkInterfaceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNetworkInterfaceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNetworkInterfaceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNetworkInterfaceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.MacAddress = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.MacAddress == nil || *updated.MacAddress != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNetworkInterfaceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NetworkInterfaceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNetworkInterfaceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNetworkInterfaceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNetworkNameElementTypeRepository tests CRUD operations for network_name_element_type table
func TestSqliteNetworkNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NetworkNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newNetworkNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNetworkNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNetworkNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNetworkNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNetworkNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NetworkNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNetworkNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNetworkNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNetworkTypeRepository tests CRUD operations for network_type table
func TestSqliteNetworkTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NetworkType()

	t.Run("Create", func(t *testing.T) {
		entity := newNetworkType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNetworkType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNetworkType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNetworkType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.IpNetRange = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.IpNetRange != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.IpNetRange)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNetworkType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NetworkType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNetworkType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNetworkType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNotesRepository tests CRUD operations for notes table
func TestSqliteNotesRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Notes()

	t.Run("Create", func(t *testing.T) {
		entity := newNotes("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNotes("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNotes(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNotes("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Note = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Note == nil || *updated.Note != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNotes("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Notes, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNotes(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNotes(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNotesElementTypeRepository tests CRUD operations for notes_element_type table
func TestSqliteNotesElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NotesElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newNotesElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNotesElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNotesElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNotesElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Note = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Note == nil || *updated.Note != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNotesElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NotesElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNotesElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNotesElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNoticeTypeRepository tests CRUD operations for notice_type table
func TestSqliteNoticeTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.NoticeType()

	t.Run("Create", func(t *testing.T) {
		entity := newNoticeType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNoticeType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNoticeType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNoticeType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNoticeType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.NoticeType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNoticeType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNoticeType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNs09XmldsigObjectTypeRepository tests CRUD operations for ns_09_xmldsig_object_type table
func TestSqliteNs09XmldsigObjectTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Ns09XmldsigObjectType()

	t.Run("Create", func(t *testing.T) {
		entity := newNs09XmldsigObjectType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNs09XmldsigObjectType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigObjectType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigObjectType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigObjectType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Ns09XmldsigObjectType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNs09XmldsigObjectType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigObjectType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNs09XmldsigReferenceTypeRepository tests CRUD operations for ns_09_xmldsig_reference_type table
func TestSqliteNs09XmldsigReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Ns09XmldsigReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newNs09XmldsigReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNs09XmldsigReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Ns09XmldsigReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNs09XmldsigReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteNs09XmldsigSignatureTypeRepository tests CRUD operations for ns_09_xmldsig_signature_type table
func TestSqliteNs09XmldsigSignatureTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Ns09XmldsigSignatureType()

	t.Run("Create", func(t *testing.T) {
		entity := newNs09XmldsigSignatureType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newNs09XmldsigSignatureType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigSignatureType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigSignatureType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newNs09XmldsigSignatureType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Ns09XmldsigSignatureType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newNs09XmldsigSignatureType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newNs09XmldsigSignatureType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOasisNamesTcCiqXNameDetailsRepository tests CRUD operations for oasis_names_tc_ciq_x_name_details table
func TestSqliteOasisNamesTcCiqXNameDetailsRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OasisNamesTcCiqXNameDetails()

	t.Run("Create", func(t *testing.T) {
		entity := newOasisNamesTcCiqXNameDetails("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOasisNamesTcCiqXNameDetails("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXNameDetails(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXNameDetails("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NameDetailsKey = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NameDetailsKey == nil || *updated.NameDetailsKey != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXNameDetails("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OasisNamesTcCiqXNameDetails, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOasisNamesTcCiqXNameDetails(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXNameDetails(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOasisNamesTcCiqXOrganisationNameDetailsRepository tests CRUD operations for oasis_names_tc_ciq_x_organisation_name_details table
func TestSqliteOasisNamesTcCiqXOrganisationNameDetailsRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OasisNamesTcCiqXOrganisationNameDetails()

	t.Run("Create", func(t *testing.T) {
		entity := newOasisNamesTcCiqXOrganisationNameDetails("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOasisNamesTcCiqXOrganisationNameDetails("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXOrganisationNameDetails(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXOrganisationNameDetails("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.OrganisationFormerName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.OrganisationFormerName == nil || *updated.OrganisationFormerName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXOrganisationNameDetails("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OasisNamesTcCiqXOrganisationNameDetails, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOasisNamesTcCiqXOrganisationNameDetails(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXOrganisationNameDetails(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOasisNamesTcCiqXPersonNameRepository tests CRUD operations for oasis_names_tc_ciq_x_person_name table
func TestSqliteOasisNamesTcCiqXPersonNameRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OasisNamesTcCiqXPersonName()

	t.Run("Create", func(t *testing.T) {
		entity := newOasisNamesTcCiqXPersonName("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOasisNamesTcCiqXPersonName("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXPersonName(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXPersonName("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.FormerName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.FormerName == nil || *updated.FormerName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOasisNamesTcCiqXPersonName("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OasisNamesTcCiqXPersonName, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOasisNamesTcCiqXPersonName(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOasisNamesTcCiqXPersonName(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteObjectComponentTypeRepository tests CRUD operations for object_component_type table
func TestSqliteObjectComponentTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ObjectComponentType()

	t.Run("Create", func(t *testing.T) {
		entity := newObjectComponentType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newObjectComponentType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newObjectComponentType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newObjectComponentType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Object_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Object_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Object_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newObjectComponentType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ObjectComponentType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newObjectComponentType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newObjectComponentType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteObjectRefRepository tests CRUD operations for object_ref table
func TestSqliteObjectRefRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ObjectRef()

	t.Run("Create", func(t *testing.T) {
		entity := newObjectRef("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newObjectRef("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newObjectRef(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newObjectRef("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.RefId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.RefId == nil || *updated.RefId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newObjectRef("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ObjectRef, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newObjectRef(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newObjectRef(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteObjectRefElementTypeRepository tests CRUD operations for object_ref_element_type table
func TestSqliteObjectRefElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ObjectRefElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newObjectRefElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newObjectRefElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newObjectRefElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newObjectRefElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.RefId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.RefId == nil || *updated.RefId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newObjectRefElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ObjectRefElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newObjectRefElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newObjectRefElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteObjectRefTypeRepository tests CRUD operations for object_ref_type table
func TestSqliteObjectRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ObjectRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newObjectRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newObjectRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newObjectRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newObjectRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Object_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Object_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Object_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newObjectRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ObjectRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newObjectRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newObjectRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteObjectsTypeRepository tests CRUD operations for objects_type table
func TestSqliteObjectsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ObjectsType()

	t.Run("Create", func(t *testing.T) {
		entity := newObjectsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newObjectsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newObjectsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newObjectsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newObjectsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ObjectsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newObjectsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newObjectsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganisationFormerNameElementTypeRepository tests CRUD operations for organisation_former_name_element_type table
func TestSqliteOrganisationFormerNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganisationFormerNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganisationFormerNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganisationFormerNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganisationFormerNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationFormerNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ValidFrom = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ValidFrom == nil || *updated.ValidFrom != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationFormerNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganisationFormerNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganisationFormerNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganisationFormerNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganisationKnownAsElementTypeRepository tests CRUD operations for organisation_known_as_element_type table
func TestSqliteOrganisationKnownAsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganisationKnownAsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganisationKnownAsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganisationKnownAsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganisationKnownAsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationKnownAsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ValidFrom = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ValidFrom == nil || *updated.ValidFrom != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationKnownAsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganisationKnownAsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganisationKnownAsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganisationKnownAsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganisationNameDetailsElementTypeRepository tests CRUD operations for organisation_name_details_element_type table
func TestSqliteOrganisationNameDetailsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganisationNameDetailsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganisationNameDetailsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganisationNameDetailsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganisationNameDetailsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationNameDetailsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.OrganisationFormerName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.OrganisationFormerName == nil || *updated.OrganisationFormerName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationNameDetailsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganisationNameDetailsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganisationNameDetailsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganisationNameDetailsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganisationNameElementTypeRepository tests CRUD operations for organisation_name_element_type table
func TestSqliteOrganisationNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganisationNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganisationNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganisationNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganisationNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganisationNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganisationNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganisationNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganisationTypeElementTypeRepository tests CRUD operations for organisation_type_element_type table
func TestSqliteOrganisationTypeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganisationTypeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganisationTypeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganisationTypeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganisationTypeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationTypeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganisationTypeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganisationTypeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganisationTypeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganisationTypeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOrganizationTypeRepository tests CRUD operations for organization_type table
func TestSqliteOrganizationTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OrganizationType()

	t.Run("Create", func(t *testing.T) {
		entity := newOrganizationType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOrganizationType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOrganizationType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOrganizationType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOrganizationType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OrganizationType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOrganizationType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOrganizationType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOtherNameElementTypeRepository tests CRUD operations for other_name_element_type table
func TestSqliteOtherNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OtherNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOtherNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOtherNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOtherNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOtherNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOtherNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OtherNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOtherNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOtherNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalDefinitionsRepository tests CRUD operations for oval_definitions table
func TestSqliteOvalDefinitionsRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalDefinitions()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalDefinitions("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalDefinitions("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalDefinitions(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalDefinitions("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalDefinitions("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalDefinitions, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalDefinitions(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalDefinitions(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalDefinitionsElementTypeRepository tests CRUD operations for oval_definitions_element_type table
func TestSqliteOvalDefinitionsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalDefinitionsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalDefinitionsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalDefinitionsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalDefinitionsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalDefinitionsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalDefinitionsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalDefinitionsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalDefinitionsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalDefinitionsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalGeneratorTypeRepository tests CRUD operations for oval_mitre_org_oval__generator_type table
func TestSqliteOvalMitreOrgOvalGeneratorTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalGeneratorType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalGeneratorType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalGeneratorType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalGeneratorType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalGeneratorType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Product_name = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Product_name == nil || *updated.Product_name != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalGeneratorType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalGeneratorType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalGeneratorType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalGeneratorType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalMessageTypeRepository tests CRUD operations for oval_mitre_org_oval__message_type table
func TestSqliteOvalMitreOrgOvalMessageTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalMessageType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalMessageType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalMessageType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalMessageType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalMessageType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Level = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Level == nil || *updated.Level != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalMessageType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalMessageType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalMessageType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalMessageType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalMetadataTypeRepository tests CRUD operations for oval_mitre_org_oval__metadata_type table
func TestSqliteOvalMitreOrgOvalMetadataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalMetadataType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalMetadataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalMetadataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalMetadataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalMetadataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Title = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Title != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Title)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalMetadataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalMetadataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalMetadataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalMetadataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalNotesTypeRepository tests CRUD operations for oval_mitre_org_oval__notes_type table
func TestSqliteOvalMitreOrgOvalNotesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalNotesType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalNotesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalNotesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalNotesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalNotesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Note = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Note == nil || *updated.Note != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalNotesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalNotesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalNotesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalNotesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalObjectTypeRepository tests CRUD operations for oval_mitre_org_oval__object_type table
func TestSqliteOvalMitreOrgOvalObjectTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalObjectType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalObjectType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalObjectType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalObjectType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalObjectType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalObjectType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalObjectType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalObjectType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalObjectType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalReferenceTypeRepository tests CRUD operations for oval_mitre_org_oval__reference_type table
func TestSqliteOvalMitreOrgOvalReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Source = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Source != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Source)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOvalMitreOrgOvalValueTypeRepository tests CRUD operations for oval_mitre_org_oval__value_type table
func TestSqliteOvalMitreOrgOvalValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OvalMitreOrgOvalValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newOvalMitreOrgOvalValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOvalMitreOrgOvalValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOvalMitreOrgOvalValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OvalMitreOrgOvalValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOvalMitreOrgOvalValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOvalMitreOrgOvalValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOverrideTypeRepository tests CRUD operations for override_type table
func TestSqliteOverrideTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OverrideType()

	t.Run("Create", func(t *testing.T) {
		entity := newOverrideType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOverrideType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOverrideType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOverrideType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Authority = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Authority != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Authority)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOverrideType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OverrideType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOverrideType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOverrideType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteOverrideableCPE2idrefTypeRepository tests CRUD operations for overrideable_c_p_e2idref_type table
func TestSqliteOverrideableCPE2idrefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.OverrideableCPE2idrefType()

	t.Run("Create", func(t *testing.T) {
		entity := newOverrideableCPE2idrefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newOverrideableCPE2idrefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newOverrideableCPE2idrefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newOverrideableCPE2idrefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newOverrideableCPE2idrefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.OverrideableCPE2idrefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newOverrideableCPE2idrefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newOverrideableCPE2idrefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePGPDataTypeRepository tests CRUD operations for p_g_p_data_type table
func TestSqlitePGPDataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PGPDataType()

	t.Run("Create", func(t *testing.T) {
		entity := newPGPDataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPGPDataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPGPDataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPGPDataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPGPDataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PGPDataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPGPDataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPGPDataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteParamTypeRepository tests CRUD operations for param_type table
func TestSqliteParamTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ParamType()

	t.Run("Create", func(t *testing.T) {
		entity := newParamType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newParamType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newParamType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newParamType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Name = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Name != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Name)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newParamType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ParamType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newParamType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newParamType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePersonNameElementTypeRepository tests CRUD operations for person_name_element_type table
func TestSqlitePersonNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PersonNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPersonNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPersonNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPersonNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPersonNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.FormerName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.FormerName == nil || *updated.FormerName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPersonNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PersonNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPersonNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPersonNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePersonTypeRepository tests CRUD operations for person_type table
func TestSqlitePersonTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PersonType()

	t.Run("Create", func(t *testing.T) {
		entity := newPersonType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPersonType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPersonType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPersonType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Birthdate = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Birthdate == nil || *updated.Birthdate != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPersonType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PersonType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPersonType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPersonType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePlainTextTypeRepository tests CRUD operations for plain_text_type table
func TestSqlitePlainTextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PlainTextType()

	t.Run("Create", func(t *testing.T) {
		entity := newPlainTextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPlainTextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPlainTextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPlainTextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPlainTextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PlainTextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPlainTextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPlainTextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePlatformSpecificationRepository tests CRUD operations for platform_specification table
func TestSqlitePlatformSpecificationRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PlatformSpecification()

	t.Run("Create", func(t *testing.T) {
		entity := newPlatformSpecification("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPlatformSpecification("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPlatformSpecification(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPlatformSpecification("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPlatformSpecification("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PlatformSpecification, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPlatformSpecification(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPlatformSpecification(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePlatformSpecificationElementTypeRepository tests CRUD operations for platform_specification_element_type table
func TestSqlitePlatformSpecificationElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PlatformSpecificationElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPlatformSpecificationElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPlatformSpecificationElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPlatformSpecificationElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPlatformSpecificationElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPlatformSpecificationElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PlatformSpecificationElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPlatformSpecificationElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPlatformSpecificationElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePlatformTypeRepository tests CRUD operations for platform_type table
func TestSqlitePlatformTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PlatformType()

	t.Run("Create", func(t *testing.T) {
		entity := newPlatformType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPlatformType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPlatformType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPlatformType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPlatformType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PlatformType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPlatformType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPlatformType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePortElementTypeRepository tests CRUD operations for port_element_type table
func TestSqlitePortElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PortElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPortElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPortElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPortElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPortElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPortElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PortElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPortElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPortElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePortRangeElementTypeRepository tests CRUD operations for port_range_element_type table
func TestSqlitePortRangeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PortRangeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPortRangeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPortRangeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPortRangeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPortRangeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.LowerBound = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.LowerBound != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.LowerBound)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPortRangeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PortRangeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPortRangeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPortRangeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePossibleRestrictionTypeRepository tests CRUD operations for possible_restriction_type table
func TestSqlitePossibleRestrictionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PossibleRestrictionType()

	t.Run("Create", func(t *testing.T) {
		entity := newPossibleRestrictionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPossibleRestrictionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPossibleRestrictionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPossibleRestrictionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Hint = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Hint != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Hint)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPossibleRestrictionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PossibleRestrictionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPossibleRestrictionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPossibleRestrictionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePossibleValueTypeRepository tests CRUD operations for possible_value_type table
func TestSqlitePossibleValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PossibleValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newPossibleValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPossibleValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPossibleValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPossibleValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Hint = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Hint != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Hint)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPossibleValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PossibleValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPossibleValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPossibleValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxRepository tests CRUD operations for post_box table
func TestSqlitePostBoxRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBox()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBox("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBox("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBox(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBox("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PostBoxNumber = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PostBoxNumber != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PostBoxNumber)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBox("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBox, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBox(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBox(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxElementTypeRepository tests CRUD operations for post_box_element_type table
func TestSqlitePostBoxElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBoxElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBoxElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBoxElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBoxElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PostBoxNumber = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PostBoxNumber != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PostBoxNumber)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBoxElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBoxElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBoxElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxNumberElementTypeRepository tests CRUD operations for post_box_number_element_type table
func TestSqlitePostBoxNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBoxNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBoxNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBoxNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBoxNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBoxNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxNumberExtensionElementTypeRepository tests CRUD operations for post_box_number_extension_element_type table
func TestSqlitePostBoxNumberExtensionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBoxNumberExtensionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBoxNumberExtensionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBoxNumberExtensionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberExtensionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberExtensionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberExtensionSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberExtensionSeparator == nil || *updated.NumberExtensionSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberExtensionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBoxNumberExtensionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBoxNumberExtensionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberExtensionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxNumberPrefixElementTypeRepository tests CRUD operations for post_box_number_prefix_element_type table
func TestSqlitePostBoxNumberPrefixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBoxNumberPrefixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBoxNumberPrefixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBoxNumberPrefixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberPrefixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberPrefixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberPrefixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBoxNumberPrefixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBoxNumberPrefixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberPrefixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostBoxNumberSuffixElementTypeRepository tests CRUD operations for post_box_number_suffix_element_type table
func TestSqlitePostBoxNumberSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostBoxNumberSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostBoxNumberSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostBoxNumberSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostBoxNumberSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostBoxNumberSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostBoxNumberSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostBoxNumberSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostOfficeRepository tests CRUD operations for post_office table
func TestSqlitePostOfficeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostOffice()

	t.Run("Create", func(t *testing.T) {
		entity := newPostOffice("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostOffice("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostOffice(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostOffice("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostOffice("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostOffice, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostOffice(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostOffice(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostOfficeElementTypeRepository tests CRUD operations for post_office_element_type table
func TestSqlitePostOfficeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostOfficeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostOfficeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostOfficeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostOfficeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostOfficeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostOfficeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostOfficeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostOfficeNameElementTypeRepository tests CRUD operations for post_office_name_element_type table
func TestSqlitePostOfficeNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostOfficeNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostOfficeNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostOfficeNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostOfficeNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostOfficeNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostOfficeNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostOfficeNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostOfficeNumberElementTypeRepository tests CRUD operations for post_office_number_element_type table
func TestSqlitePostOfficeNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostOfficeNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostOfficeNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostOfficeNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostOfficeNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Indicator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Indicator == nil || *updated.Indicator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostOfficeNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostOfficeNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostOfficeNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostOfficeNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostTownElementTypeRepository tests CRUD operations for post_town_element_type table
func TestSqlitePostTownElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostTownElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostTownElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostTownElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostTownElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostTownElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostTownElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostTownElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostTownElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostTownElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostTownNameElementTypeRepository tests CRUD operations for post_town_name_element_type table
func TestSqlitePostTownNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostTownNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostTownNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostTownNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostTownNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostTownNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostTownNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostTownNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostTownNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostTownNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostTownSuffixElementTypeRepository tests CRUD operations for post_town_suffix_element_type table
func TestSqlitePostTownSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostTownSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostTownSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostTownSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostTownSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostTownSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostTownSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostTownSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostTownSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostTownSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalCodeRepository tests CRUD operations for postal_code table
func TestSqlitePostalCodeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalCode()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalCode("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalCode("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalCode(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalCode("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalCode("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalCode, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalCode(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalCode(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalCodeElementTypeRepository tests CRUD operations for postal_code_element_type table
func TestSqlitePostalCodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalCodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalCodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalCodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalCodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalCodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalCodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalCodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalCodeNumberElementTypeRepository tests CRUD operations for postal_code_number_element_type table
func TestSqlitePostalCodeNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalCodeNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalCodeNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalCodeNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalCodeNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalCodeNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalCodeNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalCodeNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalCodeNumberExtensionElementTypeRepository tests CRUD operations for postal_code_number_extension_element_type table
func TestSqlitePostalCodeNumberExtensionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalCodeNumberExtensionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalCodeNumberExtensionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalCodeNumberExtensionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalCodeNumberExtensionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeNumberExtensionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalCodeNumberExtensionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalCodeNumberExtensionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalCodeNumberExtensionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalCodeNumberExtensionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalRouteNameElementTypeRepository tests CRUD operations for postal_route_name_element_type table
func TestSqlitePostalRouteNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalRouteNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalRouteNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalRouteNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalRouteNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalRouteNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalRouteNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalRouteNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalRouteNumberElementTypeRepository tests CRUD operations for postal_route_number_element_type table
func TestSqlitePostalRouteNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalRouteNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalRouteNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalRouteNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalRouteNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalRouteNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalRouteNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalRouteNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalRouteTypeRepository tests CRUD operations for postal_route_type table
func TestSqlitePostalRouteTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalRouteType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalRouteType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalRouteType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalRouteType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PostalRouteName = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PostalRouteName != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PostalRouteName)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalRouteType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalRouteType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalRouteType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalRouteType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePostalServiceElementsElementTypeRepository tests CRUD operations for postal_service_elements_element_type table
func TestSqlitePostalServiceElementsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PostalServiceElementsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPostalServiceElementsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPostalServiceElementsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPostalServiceElementsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPostalServiceElementsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPostalServiceElementsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PostalServiceElementsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPostalServiceElementsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPostalServiceElementsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePrecedingTitleElementTypeRepository tests CRUD operations for preceding_title_element_type table
func TestSqlitePrecedingTitleElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PrecedingTitleElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPrecedingTitleElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPrecedingTitleElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPrecedingTitleElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPrecedingTitleElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPrecedingTitleElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PrecedingTitleElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPrecedingTitleElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPrecedingTitleElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseRepository tests CRUD operations for premise table
func TestSqlitePremiseRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Premise()

	t.Run("Create", func(t *testing.T) {
		entity := newPremise("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremise("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremise(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremise("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PremiseLocation = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PremiseLocation != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PremiseLocation)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremise("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Premise, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremise(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremise(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseElementTypeRepository tests CRUD operations for premise_element_type table
func TestSqlitePremiseElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PremiseLocation = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PremiseLocation != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PremiseLocation)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseLocationElementTypeRepository tests CRUD operations for premise_location_element_type table
func TestSqlitePremiseLocationElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseLocationElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseLocationElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseLocationElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseLocationElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseLocationElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseLocationElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseLocationElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseLocationElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseLocationElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNameElementTypeRepository tests CRUD operations for premise_name_element_type table
func TestSqlitePremiseNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberRepository tests CRUD operations for premise_number table
func TestSqlitePremiseNumberRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumber()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumber("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumber("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumber(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumber("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberType == nil || *updated.NumberType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumber("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumber, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumber(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumber(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberElementTypeRepository tests CRUD operations for premise_number_element_type table
func TestSqlitePremiseNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberType == nil || *updated.NumberType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberPrefixRepository tests CRUD operations for premise_number_prefix table
func TestSqlitePremiseNumberPrefixRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberPrefix()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberPrefix("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberPrefix("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberPrefix(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberPrefix("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberPrefix("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberPrefix, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberPrefix(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberPrefix(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberPrefixElementTypeRepository tests CRUD operations for premise_number_prefix_element_type table
func TestSqlitePremiseNumberPrefixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberPrefixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberPrefixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberPrefixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberPrefixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberPrefixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberPrefixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberPrefixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberPrefixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberPrefixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberRangeElementTypeRepository tests CRUD operations for premise_number_range_element_type table
func TestSqlitePremiseNumberRangeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberRangeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberRangeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberRangeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.PremiseNumberRangeFrom = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.PremiseNumberRangeFrom != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.PremiseNumberRangeFrom)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberRangeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberRangeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberRangeFromElementTypeRepository tests CRUD operations for premise_number_range_from_element_type table
func TestSqlitePremiseNumberRangeFromElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberRangeFromElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberRangeFromElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberRangeFromElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeFromElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeFromElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeFromElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberRangeFromElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberRangeFromElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeFromElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberRangeToElementTypeRepository tests CRUD operations for premise_number_range_to_element_type table
func TestSqlitePremiseNumberRangeToElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberRangeToElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberRangeToElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberRangeToElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeToElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeToElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberRangeToElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberRangeToElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberRangeToElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberRangeToElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberSuffixRepository tests CRUD operations for premise_number_suffix table
func TestSqlitePremiseNumberSuffixRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberSuffix()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberSuffix("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberSuffix("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberSuffix(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberSuffix("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberSuffix("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberSuffix, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberSuffix(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberSuffix(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqlitePremiseNumberSuffixElementTypeRepository tests CRUD operations for premise_number_suffix_element_type table
func TestSqlitePremiseNumberSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.PremiseNumberSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newPremiseNumberSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newPremiseNumberSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newPremiseNumberSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.PremiseNumberSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newPremiseNumberSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newPremiseNumberSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileNoteTypeRepository tests CRUD operations for profile_note_type table
func TestSqliteProfileNoteTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileNoteType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileNoteType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileNoteType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileNoteType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileNoteType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Tag = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Tag != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Tag)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileNoteType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileNoteType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileNoteType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileNoteType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileRefineRuleTypeRepository tests CRUD operations for profile_refine_rule_type table
func TestSqliteProfileRefineRuleTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileRefineRuleType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileRefineRuleType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileRefineRuleType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileRefineRuleType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileRefineRuleType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileRefineRuleType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileRefineRuleType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileRefineRuleType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileRefineRuleType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileRefineValueTypeRepository tests CRUD operations for profile_refine_value_type table
func TestSqliteProfileRefineValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileRefineValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileRefineValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileRefineValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileRefineValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileRefineValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileRefineValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileRefineValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileRefineValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileRefineValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileSelectTypeRepository tests CRUD operations for profile_select_type table
func TestSqliteProfileSelectTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileSelectType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileSelectType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileSelectType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileSelectType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileSelectType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileSelectType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileSelectType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileSelectType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileSelectType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileSetComplexValueTypeRepository tests CRUD operations for profile_set_complex_value_type table
func TestSqliteProfileSetComplexValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileSetComplexValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileSetComplexValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileSetComplexValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileSetComplexValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileSetComplexValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileSetComplexValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileSetComplexValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileSetComplexValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileSetComplexValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileSetValueTypeRepository tests CRUD operations for profile_set_value_type table
func TestSqliteProfileSetValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileSetValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileSetValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileSetValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileSetValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileSetValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileSetValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileSetValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileSetValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileSetValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProfileTypeRepository tests CRUD operations for profile_type table
func TestSqliteProfileTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProfileType()

	t.Run("Create", func(t *testing.T) {
		entity := newProfileType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProfileType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProfileType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProfileType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProfileType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProfileType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProfileType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProfileType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteProtocolElementTypeRepository tests CRUD operations for protocol_element_type table
func TestSqliteProtocolElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ProtocolElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newProtocolElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newProtocolElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newProtocolElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newProtocolElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newProtocolElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ProtocolElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newProtocolElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newProtocolElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRSAKeyValueTypeRepository tests CRUD operations for r_s_a_key_value_type table
func TestSqliteRSAKeyValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RSAKeyValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newRSAKeyValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRSAKeyValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRSAKeyValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRSAKeyValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRSAKeyValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RSAKeyValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRSAKeyValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRSAKeyValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReferenceElementTypeRepository tests CRUD operations for reference_element_type table
func TestSqliteReferenceElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReferenceElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newReferenceElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReferenceElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReferenceElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReferenceElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Href = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Href == nil || *updated.Href != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReferenceElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReferenceElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReferenceElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReferenceElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReferencesTypeRepository tests CRUD operations for references_type table
func TestSqliteReferencesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReferencesType()

	t.Run("Create", func(t *testing.T) {
		entity := newReferencesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReferencesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReferencesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReferencesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Reference = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Reference != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Reference)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReferencesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReferencesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReferencesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReferencesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRegexCaptureFunctionTypeRepository tests CRUD operations for regex_capture_function_type table
func TestSqliteRegexCaptureFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RegexCaptureFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newRegexCaptureFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRegexCaptureFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRegexCaptureFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRegexCaptureFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Pattern = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Pattern == nil || *updated.Pattern != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRegexCaptureFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RegexCaptureFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRegexCaptureFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRegexCaptureFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRelationshipTypeRepository tests CRUD operations for relationship_type table
func TestSqliteRelationshipTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RelationshipType()

	t.Run("Create", func(t *testing.T) {
		entity := newRelationshipType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRelationshipType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRelationshipType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Type)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RelationshipType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRelationshipType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRelationshipType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRelationshipsContainerTypeRepository tests CRUD operations for relationships_container_type table
func TestSqliteRelationshipsContainerTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RelationshipsContainerType()

	t.Run("Create", func(t *testing.T) {
		entity := newRelationshipsContainerType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRelationshipsContainerType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRelationshipsContainerType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipsContainerType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Relationships = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Relationships == nil || *updated.Relationships != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipsContainerType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RelationshipsContainerType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRelationshipsContainerType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRelationshipsContainerType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRelationshipsElementTypeRepository tests CRUD operations for relationships_element_type table
func TestSqliteRelationshipsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RelationshipsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newRelationshipsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRelationshipsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRelationshipsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRelationshipsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RelationshipsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRelationshipsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRelationshipsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRemoteResourceRepository tests CRUD operations for remote_resource table
func TestSqliteRemoteResourceRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RemoteResource()

	t.Run("Create", func(t *testing.T) {
		entity := newRemoteResource("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRemoteResource("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRemoteResource(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRemoteResource("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRemoteResource("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RemoteResource, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRemoteResource(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRemoteResource(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRemoteResourceElementTypeRepository tests CRUD operations for remote_resource_element_type table
func TestSqliteRemoteResourceElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RemoteResourceElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newRemoteResourceElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRemoteResourceElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRemoteResourceElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRemoteResourceElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRemoteResourceElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RemoteResourceElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRemoteResourceElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRemoteResourceElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReportRequestTypeRepository tests CRUD operations for report_request_type table
func TestSqliteReportRequestTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReportRequestType()

	t.Run("Create", func(t *testing.T) {
		entity := newReportRequestType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReportRequestType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReportRequestType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReportRequestType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReportRequestType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReportRequestType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReportRequestType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReportRequestType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReportRequestsElementTypeRepository tests CRUD operations for report_requests_element_type table
func TestSqliteReportRequestsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReportRequestsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newReportRequestsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReportRequestsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReportRequestsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReportRequestsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReportRequestsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReportRequestsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReportRequestsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReportRequestsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReportTypeRepository tests CRUD operations for report_type table
func TestSqliteReportTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReportType()

	t.Run("Create", func(t *testing.T) {
		entity := newReportType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReportType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReportType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReportType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReportType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReportType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReportType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReportType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteReportsElementTypeRepository tests CRUD operations for reports_element_type table
func TestSqliteReportsElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ReportsElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newReportsElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newReportsElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newReportsElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newReportsElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newReportsElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ReportsElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newReportsElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newReportsElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteResourceTypeRepository tests CRUD operations for resource_type table
func TestSqliteResourceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ResourceType()

	t.Run("Create", func(t *testing.T) {
		entity := newResourceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newResourceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newResourceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newResourceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newResourceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ResourceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newResourceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newResourceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRestrictionTypeRepository tests CRUD operations for restriction_type table
func TestSqliteRestrictionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RestrictionType()

	t.Run("Create", func(t *testing.T) {
		entity := newRestrictionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRestrictionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRestrictionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRestrictionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Operation = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Operation != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Operation)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRestrictionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RestrictionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRestrictionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRestrictionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRetrievalMethodTypeRepository tests CRUD operations for retrieval_method_type table
func TestSqliteRetrievalMethodTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RetrievalMethodType()

	t.Run("Create", func(t *testing.T) {
		entity := newRetrievalMethodType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRetrievalMethodType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRetrievalMethodType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRetrievalMethodType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.URI = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.URI == nil || *updated.URI != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRetrievalMethodType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RetrievalMethodType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRetrievalMethodType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRetrievalMethodType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRuleResultTypeRepository tests CRUD operations for rule_result_type table
func TestSqliteRuleResultTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RuleResultType()

	t.Run("Create", func(t *testing.T) {
		entity := newRuleResultType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRuleResultType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRuleResultType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRuleResultType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Idref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Idref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Idref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRuleResultType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RuleResultType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRuleResultType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRuleResultType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteRuleTypeRepository tests CRUD operations for rule_type table
func TestSqliteRuleTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.RuleType()

	t.Run("Create", func(t *testing.T) {
		entity := newRuleType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newRuleType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newRuleType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newRuleType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newRuleType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.RuleType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newRuleType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newRuleType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSPKIDataTypeRepository tests CRUD operations for s_p_k_i_data_type table
func TestSqliteSPKIDataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SPKIDataType()

	t.Run("Create", func(t *testing.T) {
		entity := newSPKIDataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSPKIDataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSPKIDataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSPKIDataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSPKIDataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SPKIDataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSPKIDataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSPKIDataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSchemaVersionTypeRepository tests CRUD operations for schema_version_type table
func TestSqliteSchemaVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SchemaVersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newSchemaVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSchemaVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSchemaVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSchemaVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Platform = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Platform == nil || *updated.Platform != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSchemaVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SchemaVersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSchemaVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSchemaVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteScoreTypeRepository tests CRUD operations for score_type table
func TestSqliteScoreTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ScoreType()

	t.Run("Create", func(t *testing.T) {
		entity := newScoreType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newScoreType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newScoreType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newScoreType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System == nil || *updated.System != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newScoreType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ScoreType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newScoreType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newScoreType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSelChoicesTypeRepository tests CRUD operations for sel_choices_type table
func TestSqliteSelChoicesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SelChoicesType()

	t.Run("Create", func(t *testing.T) {
		entity := newSelChoicesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSelChoicesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSelChoicesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSelChoicesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Choice = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Choice != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Choice)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSelChoicesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SelChoicesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSelChoicesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSelChoicesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSelComplexValueTypeRepository tests CRUD operations for sel_complex_value_type table
func TestSqliteSelComplexValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SelComplexValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newSelComplexValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSelComplexValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSelComplexValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSelComplexValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Selector = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Selector == nil || *updated.Selector != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSelComplexValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SelComplexValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSelComplexValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSelComplexValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSelNumTypeRepository tests CRUD operations for sel_num_type table
func TestSqliteSelNumTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SelNumType()

	t.Run("Create", func(t *testing.T) {
		entity := newSelNumType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSelNumType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSelNumType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSelNumType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Selector = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Selector == nil || *updated.Selector != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSelNumType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SelNumType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSelNumType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSelNumType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSelStringTypeRepository tests CRUD operations for sel_string_type table
func TestSqliteSelStringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SelStringType()

	t.Run("Create", func(t *testing.T) {
		entity := newSelStringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSelStringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSelStringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSelStringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Selector = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Selector == nil || *updated.Selector != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSelStringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SelStringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSelStringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSelStringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteServiceTypeRepository tests CRUD operations for service_type table
func TestSqliteServiceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ServiceType()

	t.Run("Create", func(t *testing.T) {
		entity := newServiceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newServiceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newServiceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newServiceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Host = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Host == nil || *updated.Host != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newServiceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ServiceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newServiceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newServiceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSetRepository tests CRUD operations for set table
func TestSqliteSetRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Set()

	t.Run("Create", func(t *testing.T) {
		entity := newSet("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSet("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSet(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSet("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Set_operator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Set_operator == nil || *updated.Set_operator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSet("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Set, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSet(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSet(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSetElementTypeRepository tests CRUD operations for set_element_type table
func TestSqliteSetElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SetElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSetElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSetElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSetElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSetElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Set_operator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Set_operator == nil || *updated.Set_operator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSetElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SetElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSetElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSetElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSignatureMethodTypeRepository tests CRUD operations for signature_method_type table
func TestSqliteSignatureMethodTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SignatureMethodType()

	t.Run("Create", func(t *testing.T) {
		entity := newSignatureMethodType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSignatureMethodType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSignatureMethodType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSignatureMethodType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Algorithm = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Algorithm != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Algorithm)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSignatureMethodType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SignatureMethodType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSignatureMethodType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSignatureMethodType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSignaturePropertiesTypeRepository tests CRUD operations for signature_properties_type table
func TestSqliteSignaturePropertiesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SignaturePropertiesType()

	t.Run("Create", func(t *testing.T) {
		entity := newSignaturePropertiesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSignaturePropertiesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSignaturePropertiesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSignaturePropertiesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSignaturePropertiesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SignaturePropertiesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSignaturePropertiesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSignaturePropertiesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSignaturePropertyTypeRepository tests CRUD operations for signature_property_type table
func TestSqliteSignaturePropertyTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SignaturePropertyType()

	t.Run("Create", func(t *testing.T) {
		entity := newSignaturePropertyType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSignaturePropertyType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSignaturePropertyType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSignaturePropertyType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Target = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Target != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Target)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSignaturePropertyType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SignaturePropertyType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSignaturePropertyType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSignaturePropertyType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSignatureValueTypeRepository tests CRUD operations for signature_value_type table
func TestSqliteSignatureValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SignatureValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newSignatureValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSignatureValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSignatureValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSignatureValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSignatureValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SignatureValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSignatureValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSignatureValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSignedInfoTypeRepository tests CRUD operations for signed_info_type table
func TestSqliteSignedInfoTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SignedInfoType()

	t.Run("Create", func(t *testing.T) {
		entity := newSignedInfoType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSignedInfoType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSignedInfoType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSignedInfoType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId == nil || *updated.XsdId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSignedInfoType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SignedInfoType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSignedInfoType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSignedInfoType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSimpleRepository tests CRUD operations for simple table
func TestSqliteSimpleRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Simple()

	t.Run("Create", func(t *testing.T) {
		entity := newSimple("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSimple("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSimple(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSimple("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSimple("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Simple, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSimple(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSimple(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSoftwareTypeRepository tests CRUD operations for software_type table
func TestSqliteSoftwareTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SoftwareType()

	t.Run("Create", func(t *testing.T) {
		entity := newSoftwareType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSoftwareType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSoftwareType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSoftwareType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.InstallationId = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.InstallationId == nil || *updated.InstallationId != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSoftwareType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SoftwareType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSoftwareType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSoftwareType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSortingCodeElementTypeRepository tests CRUD operations for sorting_code_element_type table
func TestSqliteSortingCodeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SortingCodeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSortingCodeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSortingCodeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSortingCodeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSortingCodeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSortingCodeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SortingCodeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSortingCodeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSortingCodeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSplitFunctionTypeRepository tests CRUD operations for split_function_type table
func TestSqliteSplitFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SplitFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newSplitFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSplitFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSplitFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSplitFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Delimiter = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Delimiter != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Delimiter)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSplitFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SplitFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSplitFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSplitFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteStateRefTypeRepository tests CRUD operations for state_ref_type table
func TestSqliteStateRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.StateRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newStateRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newStateRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newStateRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newStateRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.State_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.State_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.State_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newStateRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.StateRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newStateRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newStateRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteStateTypeRepository tests CRUD operations for state_type table
func TestSqliteStateTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.StateType()

	t.Run("Create", func(t *testing.T) {
		entity := newStateType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newStateType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newStateType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newStateType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newStateType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.StateType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newStateType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newStateType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteStatesTypeRepository tests CRUD operations for states_type table
func TestSqliteStatesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.StatesType()

	t.Run("Create", func(t *testing.T) {
		entity := newStatesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newStatesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newStatesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newStatesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newStatesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.StatesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newStatesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newStatesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteStatusRepository tests CRUD operations for status table
func TestSqliteStatusRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Status()

	t.Run("Create", func(t *testing.T) {
		entity := newStatus("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newStatus("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newStatus(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newStatus("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newStatus("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Status, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newStatus(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newStatus(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteStatusElementTypeRepository tests CRUD operations for status_element_type table
func TestSqliteStatusElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.StatusElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newStatusElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newStatusElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newStatusElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newStatusElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newStatusElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.StatusElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newStatusElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newStatusElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubAdministrativeAreaElementTypeRepository tests CRUD operations for sub_administrative_area_element_type table
func TestSqliteSubAdministrativeAreaElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubAdministrativeAreaElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubAdministrativeAreaElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubAdministrativeAreaElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubAdministrativeAreaElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubAdministrativeAreaElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubAdministrativeAreaElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubAdministrativeAreaElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubAdministrativeAreaElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubAdministrativeAreaElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubAdministrativeAreaNameElementTypeRepository tests CRUD operations for sub_administrative_area_name_element_type table
func TestSqliteSubAdministrativeAreaNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubAdministrativeAreaNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubAdministrativeAreaNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubAdministrativeAreaNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubAdministrativeAreaNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubAdministrativeAreaNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubAdministrativeAreaNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubAdministrativeAreaNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubAdministrativeAreaNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubAdministrativeAreaNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseLocationElementTypeRepository tests CRUD operations for sub_premise_location_element_type table
func TestSqliteSubPremiseLocationElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseLocationElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseLocationElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseLocationElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseLocationElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseLocationElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseLocationElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseLocationElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseLocationElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseLocationElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseNameElementTypeRepository tests CRUD operations for sub_premise_name_element_type table
func TestSqliteSubPremiseNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseNumberElementTypeRepository tests CRUD operations for sub_premise_number_element_type table
func TestSqliteSubPremiseNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Indicator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Indicator == nil || *updated.Indicator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseNumberPrefixElementTypeRepository tests CRUD operations for sub_premise_number_prefix_element_type table
func TestSqliteSubPremiseNumberPrefixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseNumberPrefixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseNumberPrefixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseNumberPrefixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberPrefixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberPrefixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberPrefixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseNumberPrefixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseNumberPrefixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberPrefixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseNumberSuffixElementTypeRepository tests CRUD operations for sub_premise_number_suffix_element_type table
func TestSqliteSubPremiseNumberSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseNumberSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseNumberSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseNumberSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseNumberSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseNumberSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseNumberSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseNumberSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubPremiseTypeRepository tests CRUD operations for sub_premise_type table
func TestSqliteSubPremiseTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubPremiseType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubPremiseType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubPremiseType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubPremiseType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.SubPremiseLocation = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.SubPremiseLocation != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.SubPremiseLocation)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubPremiseType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubPremiseType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubPremiseType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubPremiseType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubTypeRepository tests CRUD operations for sub_type table
func TestSqliteSubTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Use = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Use == nil || *updated.Use != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSubstringFunctionTypeRepository tests CRUD operations for substring_function_type table
func TestSqliteSubstringFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SubstringFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newSubstringFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSubstringFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSubstringFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSubstringFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSubstringFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SubstringFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSubstringFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSubstringFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSuffixElementTypeRepository tests CRUD operations for suffix_element_type table
func TestSqliteSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSupplementaryPostalServiceDataElementTypeRepository tests CRUD operations for supplementary_postal_service_data_element_type table
func TestSqliteSupplementaryPostalServiceDataElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SupplementaryPostalServiceDataElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSupplementaryPostalServiceDataElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSupplementaryPostalServiceDataElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSupplementaryPostalServiceDataElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSupplementaryPostalServiceDataElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSupplementaryPostalServiceDataElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SupplementaryPostalServiceDataElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSupplementaryPostalServiceDataElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSupplementaryPostalServiceDataElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSyntheticIdRepository tests CRUD operations for synthetic_id table
func TestSqliteSyntheticIdRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SyntheticId()

	t.Run("Create", func(t *testing.T) {
		entity := newSyntheticId("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSyntheticId("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSyntheticId(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSyntheticId("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Resource = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Resource != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Resource)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSyntheticId("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SyntheticId, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSyntheticId(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSyntheticId(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSyntheticIdElementTypeRepository tests CRUD operations for synthetic_id_element_type table
func TestSqliteSyntheticIdElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SyntheticIdElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSyntheticIdElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSyntheticIdElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSyntheticIdElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSyntheticIdElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Resource = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Resource != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Resource)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSyntheticIdElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SyntheticIdElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSyntheticIdElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSyntheticIdElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSystemNameElementTypeRepository tests CRUD operations for system_name_element_type table
func TestSqliteSystemNameElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SystemNameElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newSystemNameElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSystemNameElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSystemNameElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSystemNameElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSystemNameElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SystemNameElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSystemNameElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSystemNameElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteSystemTypeRepository tests CRUD operations for system_type table
func TestSqliteSystemTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.SystemType()

	t.Run("Create", func(t *testing.T) {
		entity := newSystemType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newSystemType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newSystemType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newSystemType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.SystemName = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.SystemName == nil || *updated.SystemName != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newSystemType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.SystemType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newSystemType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newSystemType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTailoringBenchmarkReferenceTypeRepository tests CRUD operations for tailoring_benchmark_reference_type table
func TestSqliteTailoringBenchmarkReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TailoringBenchmarkReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newTailoringBenchmarkReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTailoringBenchmarkReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTailoringBenchmarkReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTailoringBenchmarkReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version == nil || *updated.Version != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTailoringBenchmarkReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TailoringBenchmarkReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTailoringBenchmarkReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTailoringBenchmarkReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTailoringReferenceTypeRepository tests CRUD operations for tailoring_reference_type table
func TestSqliteTailoringReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TailoringReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newTailoringReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTailoringReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTailoringReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTailoringReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Href = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Href != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Href)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTailoringReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TailoringReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTailoringReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTailoringReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTailoringTypeRepository tests CRUD operations for tailoring_type table
func TestSqliteTailoringTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TailoringType()

	t.Run("Create", func(t *testing.T) {
		entity := newTailoringType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTailoringType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTailoringType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTailoringType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTailoringType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TailoringType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTailoringType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTailoringType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTailoringVersionTypeRepository tests CRUD operations for tailoring_version_type table
func TestSqliteTailoringVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TailoringVersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newTailoringVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTailoringVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTailoringVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTailoringVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTailoringVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TailoringVersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTailoringVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTailoringVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTargetFactsTypeRepository tests CRUD operations for target_facts_type table
func TestSqliteTargetFactsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TargetFactsType()

	t.Run("Create", func(t *testing.T) {
		entity := newTargetFactsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTargetFactsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTargetFactsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTargetFactsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTargetFactsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TargetFactsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTargetFactsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTargetFactsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTargetIdRefTypeRepository tests CRUD operations for target_id_ref_type table
func TestSqliteTargetIdRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TargetIdRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newTargetIdRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTargetIdRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTargetIdRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTargetIdRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTargetIdRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TargetIdRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTargetIdRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTargetIdRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTelephoneNumberRepository tests CRUD operations for telephone_number table
func TestSqliteTelephoneNumberRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TelephoneNumber()

	t.Run("Create", func(t *testing.T) {
		entity := newTelephoneNumber("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTelephoneNumber("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTelephoneNumber(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTelephoneNumber("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTelephoneNumber("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TelephoneNumber, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTelephoneNumber(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTelephoneNumber(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTelephoneNumberElementTypeRepository tests CRUD operations for telephone_number_element_type table
func TestSqliteTelephoneNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TelephoneNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newTelephoneNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTelephoneNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTelephoneNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTelephoneNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTelephoneNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TelephoneNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTelephoneNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTelephoneNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTestResultTypeRepository tests CRUD operations for test_result_type table
func TestSqliteTestResultTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TestResultType()

	t.Run("Create", func(t *testing.T) {
		entity := newTestResultType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTestResultType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTestResultType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTestResultType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTestResultType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TestResultType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTestResultType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTestResultType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTestTypeRepository tests CRUD operations for test_type table
func TestSqliteTestTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TestType()

	t.Run("Create", func(t *testing.T) {
		entity := newTestType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTestType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTestType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTestType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTestType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TestType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTestType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTestType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTestsTypeRepository tests CRUD operations for tests_type table
func TestSqliteTestsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TestsType()

	t.Run("Create", func(t *testing.T) {
		entity := newTestsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTestsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTestsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTestsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTestsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TestsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTestsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTestsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTextWithSubTypeRepository tests CRUD operations for text_with_sub_type table
func TestSqliteTextWithSubTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TextWithSubType()

	t.Run("Create", func(t *testing.T) {
		entity := newTextWithSubType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTextWithSubType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTextWithSubType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTextWithSubType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTextWithSubType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TextWithSubType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTextWithSubType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTextWithSubType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareRepository tests CRUD operations for thoroughfare table
func TestSqliteThoroughfareRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Thoroughfare()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfare("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfare("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfare(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfare("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ThoroughfareNumberRange = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ThoroughfareNumberRange != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ThoroughfareNumberRange)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfare("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Thoroughfare, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfare(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfare(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareElementTypeRepository tests CRUD operations for thoroughfare_element_type table
func TestSqliteThoroughfareElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ThoroughfareNumberRange = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ThoroughfareNumberRange != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ThoroughfareNumberRange)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareLeadingTypeTypeRepository tests CRUD operations for thoroughfare_leading_type_type table
func TestSqliteThoroughfareLeadingTypeTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareLeadingTypeType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareLeadingTypeType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareLeadingTypeType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareLeadingTypeType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareLeadingTypeType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareLeadingTypeType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareLeadingTypeType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareLeadingTypeType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareLeadingTypeType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNameTypeRepository tests CRUD operations for thoroughfare_name_type table
func TestSqliteThoroughfareNameTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNameType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNameType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNameType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNameType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNameType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNameType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNameType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNameType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNameType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberRepository tests CRUD operations for thoroughfare_number table
func TestSqliteThoroughfareNumberRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumber()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumber("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumber("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumber(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumber("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberType == nil || *updated.NumberType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumber("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumber, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumber(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumber(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberElementTypeRepository tests CRUD operations for thoroughfare_number_element_type table
func TestSqliteThoroughfareNumberElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberType = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberType == nil || *updated.NumberType != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberFromElementTypeRepository tests CRUD operations for thoroughfare_number_from_element_type table
func TestSqliteThoroughfareNumberFromElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberFromElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberFromElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberFromElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberFromElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberFromElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberFromElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberFromElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberFromElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberFromElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberPrefixRepository tests CRUD operations for thoroughfare_number_prefix table
func TestSqliteThoroughfareNumberPrefixRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberPrefix()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberPrefix("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberPrefix("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberPrefix(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberPrefix("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberPrefix("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberPrefix, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberPrefix(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberPrefix(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberPrefixElementTypeRepository tests CRUD operations for thoroughfare_number_prefix_element_type table
func TestSqliteThoroughfareNumberPrefixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberPrefixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberPrefixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberPrefixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberPrefixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberPrefixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberPrefixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberPrefixSeparator == nil || *updated.NumberPrefixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberPrefixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberPrefixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberPrefixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberPrefixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberRangeElementTypeRepository tests CRUD operations for thoroughfare_number_range_element_type table
func TestSqliteThoroughfareNumberRangeElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberRangeElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberRangeElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberRangeElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberRangeElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberRangeElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.ThoroughfareNumberFrom = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.ThoroughfareNumberFrom != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.ThoroughfareNumberFrom)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberRangeElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberRangeElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberRangeElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberRangeElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberSuffixRepository tests CRUD operations for thoroughfare_number_suffix table
func TestSqliteThoroughfareNumberSuffixRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberSuffix()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberSuffix("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberSuffix("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberSuffix(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberSuffix("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberSuffix("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberSuffix, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberSuffix(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberSuffix(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberSuffixElementTypeRepository tests CRUD operations for thoroughfare_number_suffix_element_type table
func TestSqliteThoroughfareNumberSuffixElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberSuffixElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberSuffixElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberSuffixElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberSuffixElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberSuffixElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.NumberSuffixSeparator = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.NumberSuffixSeparator == nil || *updated.NumberSuffixSeparator != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberSuffixElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberSuffixElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberSuffixElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberSuffixElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareNumberToElementTypeRepository tests CRUD operations for thoroughfare_number_to_element_type table
func TestSqliteThoroughfareNumberToElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareNumberToElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareNumberToElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareNumberToElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberToElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberToElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareNumberToElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareNumberToElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareNumberToElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareNumberToElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfarePostDirectionTypeRepository tests CRUD operations for thoroughfare_post_direction_type table
func TestSqliteThoroughfarePostDirectionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfarePostDirectionType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfarePostDirectionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfarePostDirectionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfarePostDirectionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfarePostDirectionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfarePostDirectionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfarePostDirectionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfarePostDirectionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfarePostDirectionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfarePreDirectionTypeRepository tests CRUD operations for thoroughfare_pre_direction_type table
func TestSqliteThoroughfarePreDirectionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfarePreDirectionType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfarePreDirectionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfarePreDirectionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfarePreDirectionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfarePreDirectionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfarePreDirectionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfarePreDirectionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfarePreDirectionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfarePreDirectionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteThoroughfareTrailingTypeTypeRepository tests CRUD operations for thoroughfare_trailing_type_type table
func TestSqliteThoroughfareTrailingTypeTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.ThoroughfareTrailingTypeType()

	t.Run("Create", func(t *testing.T) {
		entity := newThoroughfareTrailingTypeType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newThoroughfareTrailingTypeType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newThoroughfareTrailingTypeType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareTrailingTypeType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newThoroughfareTrailingTypeType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.ThoroughfareTrailingTypeType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newThoroughfareTrailingTypeType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newThoroughfareTrailingTypeType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTimeDifferenceFunctionTypeRepository tests CRUD operations for time_difference_function_type table
func TestSqliteTimeDifferenceFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TimeDifferenceFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newTimeDifferenceFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTimeDifferenceFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTimeDifferenceFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTimeDifferenceFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Format_1 = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Format_1 == nil || *updated.Format_1 != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTimeDifferenceFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TimeDifferenceFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTimeDifferenceFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTimeDifferenceFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTitleElementTypeRepository tests CRUD operations for title_element_type table
func TestSqliteTitleElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TitleElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newTitleElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTitleElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTitleElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTitleElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Type = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Type == nil || *updated.Type != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTitleElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TitleElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTitleElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTitleElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTitleEltTypeRepository tests CRUD operations for title_elt_type table
func TestSqliteTitleEltTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TitleEltType()

	t.Run("Create", func(t *testing.T) {
		entity := newTitleEltType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTitleEltType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTitleEltType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTitleEltType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTitleEltType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TitleEltType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTitleEltType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTitleEltType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTransformTypeRepository tests CRUD operations for transform_type table
func TestSqliteTransformTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TransformType()

	t.Run("Create", func(t *testing.T) {
		entity := newTransformType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTransformType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTransformType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTransformType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Algorithm = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Algorithm != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Algorithm)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTransformType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TransformType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTransformType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTransformType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteTransformsTypeRepository tests CRUD operations for transforms_type table
func TestSqliteTransformsTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.TransformsType()

	t.Run("Create", func(t *testing.T) {
		entity := newTransformsType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newTransformsType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newTransformsType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newTransformsType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newTransformsType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.TransformsType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newTransformsType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newTransformsType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteUniqueFunctionTypeRepository tests CRUD operations for unique_function_type table
func TestSqliteUniqueFunctionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.UniqueFunctionType()

	t.Run("Create", func(t *testing.T) {
		entity := newUniqueFunctionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newUniqueFunctionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newUniqueFunctionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newUniqueFunctionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newUniqueFunctionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.UniqueFunctionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newUniqueFunctionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newUniqueFunctionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteUriRefTypeRepository tests CRUD operations for uri_ref_type table
func TestSqliteUriRefTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.UriRefType()

	t.Run("Create", func(t *testing.T) {
		entity := newUriRefType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newUriRefType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newUriRefType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newUriRefType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Uri = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Uri != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Uri)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newUriRefType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.UriRefType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newUriRefType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newUriRefType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteUrlElementTypeRepository tests CRUD operations for url_element_type table
func TestSqliteUrlElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.UrlElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newUrlElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newUrlElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newUrlElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newUrlElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newUrlElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.UrlElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newUrlElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newUrlElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteVariableComponentTypeRepository tests CRUD operations for variable_component_type table
func TestSqliteVariableComponentTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.VariableComponentType()

	t.Run("Create", func(t *testing.T) {
		entity := newVariableComponentType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newVariableComponentType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newVariableComponentType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newVariableComponentType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Var_ref = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Var_ref != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Var_ref)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newVariableComponentType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.VariableComponentType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newVariableComponentType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newVariableComponentType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteVariableTypeRepository tests CRUD operations for variable_type table
func TestSqliteVariableTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.VariableType()

	t.Run("Create", func(t *testing.T) {
		entity := newVariableType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newVariableType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newVariableType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newVariableType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newVariableType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.VariableType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newVariableType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newVariableType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteVariablesTypeRepository tests CRUD operations for variables_type table
func TestSqliteVariablesTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.VariablesType()

	t.Run("Create", func(t *testing.T) {
		entity := newVariablesType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newVariablesType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newVariablesType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newVariablesType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newVariablesType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.VariablesType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newVariablesType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newVariablesType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteVersionElementTypeRepository tests CRUD operations for version_element_type table
func TestSqliteVersionElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.VersionElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newVersionElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newVersionElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newVersionElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newVersionElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newVersionElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.VersionElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newVersionElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newVersionElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteVersionTypeRepository tests CRUD operations for version_type table
func TestSqliteVersionTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.VersionType()

	t.Run("Create", func(t *testing.T) {
		entity := newVersionType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newVersionType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newVersionType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newVersionType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Update = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Update == nil || *updated.Update != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newVersionType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.VersionType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newVersionType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newVersionType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteWarningTypeRepository tests CRUD operations for warning_type table
func TestSqliteWarningTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.WarningType()

	t.Run("Create", func(t *testing.T) {
		entity := newWarningType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newWarningType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newWarningType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newWarningType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Category = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Category == nil || *updated.Category != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newWarningType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.WarningType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newWarningType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newWarningType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteWebsiteTypeRepository tests CRUD operations for website_type table
func TestSqliteWebsiteTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.WebsiteType()

	t.Run("Create", func(t *testing.T) {
		entity := newWebsiteType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newWebsiteType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newWebsiteType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.DocumentRoot = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.DocumentRoot == nil || *updated.DocumentRoot != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.WebsiteType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newWebsiteType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newWebsiteType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteWebsiteUrlRepository tests CRUD operations for website_url table
func TestSqliteWebsiteUrlRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.WebsiteUrl()

	t.Run("Create", func(t *testing.T) {
		entity := newWebsiteUrl("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newWebsiteUrl("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newWebsiteUrl(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteUrl("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteUrl("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.WebsiteUrl, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newWebsiteUrl(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newWebsiteUrl(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteWebsiteUrlElementTypeRepository tests CRUD operations for website_url_element_type table
func TestSqliteWebsiteUrlElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.WebsiteUrlElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newWebsiteUrlElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newWebsiteUrlElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newWebsiteUrlElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteUrlElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newWebsiteUrlElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.WebsiteUrlElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newWebsiteUrlElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newWebsiteUrlElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteX509DataTypeRepository tests CRUD operations for x509_data_type table
func TestSqliteX509DataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.X509DataType()

	t.Run("Create", func(t *testing.T) {
		entity := newX509DataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newX509DataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newX509DataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newX509DataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.X509SubjectName = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.X509SubjectName != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.X509SubjectName)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newX509DataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.X509DataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newX509DataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newX509DataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteX509IssuerSerialTypeRepository tests CRUD operations for x509_issuer_serial_type table
func TestSqliteX509IssuerSerialTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.X509IssuerSerialType()

	t.Run("Create", func(t *testing.T) {
		entity := newX509IssuerSerialType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newX509IssuerSerialType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newX509IssuerSerialType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newX509IssuerSerialType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.X509IssuerName = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.X509IssuerName != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.X509IssuerName)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newX509IssuerSerialType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.X509IssuerSerialType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newX509IssuerSerialType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newX509IssuerSerialType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXALRepository tests CRUD operations for x_a_l table
func TestSqliteXALRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.XAL()

	t.Run("Create", func(t *testing.T) {
		entity := newXAL("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXAL("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXAL(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXAL("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version == nil || *updated.Version != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXAL("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.XAL, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXAL(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXAL(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXALElementTypeRepository tests CRUD operations for x_a_l_element_type table
func TestSqliteXALElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.XALElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newXALElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXALElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXALElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXALElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version == nil || *updated.Version != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXALElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.XALElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXALElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXALElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXNLRepository tests CRUD operations for x_n_l table
func TestSqliteXNLRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.XNL()

	t.Run("Create", func(t *testing.T) {
		entity := newXNL("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXNL("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXNL(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXNL("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version == nil || *updated.Version != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXNL("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.XNL, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXNL(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXNL(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXNLElementTypeRepository tests CRUD operations for x_n_l_element_type table
func TestSqliteXNLElementTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.XNLElementType()

	t.Run("Create", func(t *testing.T) {
		entity := newXNLElementType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXNLElementType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXNLElementType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXNLElementType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Version = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Version == nil || *updated.Version != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXNLElementType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.XNLElementType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXNLElementType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXNLElementType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12CheckTypeRepository tests CRUD operations for xccdf_1_2_check_type table
func TestSqliteXccdf12CheckTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12CheckType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12CheckType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12CheckType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12CheckType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12CheckType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.System = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.System != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.System)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12CheckType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12CheckType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12CheckType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12CheckType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12MessageTypeRepository tests CRUD operations for xccdf_1_2_message_type table
func TestSqliteXccdf12MessageTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12MessageType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12MessageType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12MessageType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12MessageType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12MessageType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Severity = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Severity != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.Severity)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12MessageType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12MessageType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12MessageType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12MessageType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12MetadataTypeRepository tests CRUD operations for xccdf_1_2_metadata_type table
func TestSqliteXccdf12MetadataTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12MetadataType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12MetadataType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12MetadataType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12MetadataType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12MetadataType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12MetadataType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12MetadataType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12MetadataType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12MetadataType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12ReferenceTypeRepository tests CRUD operations for xccdf_1_2_reference_type table
func TestSqliteXccdf12ReferenceTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12ReferenceType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12ReferenceType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12ReferenceType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12ReferenceType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12ReferenceType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.Href = stringPtr("updated_value")
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.Href == nil || *updated.Href != "updated_value" {
			t.Error("Expected updated value")
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12ReferenceType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12ReferenceType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12ReferenceType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12ReferenceType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12SignatureTypeRepository tests CRUD operations for xccdf_1_2_signature_type table
func TestSqliteXccdf12SignatureTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12SignatureType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12SignatureType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12SignatureType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12SignatureType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12SignatureType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12SignatureType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12SignatureType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12SignatureType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12SignatureType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12TextTypeRepository tests CRUD operations for xccdf_1_2_text_type table
func TestSqliteXccdf12TextTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12TextType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12TextType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12TextType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12TextType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12TextType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12TextType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12TextType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12TextType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12TextType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// TestSqliteXccdf12ValueTypeRepository tests CRUD operations for xccdf_1_2_value_type table
func TestSqliteXccdf12ValueTypeRepository(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	repo := dal.Xccdf12ValueType()

	t.Run("Create", func(t *testing.T) {
		entity := newXccdf12ValueType("create")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}
		if id <= 0 {
			t.Errorf("Expected positive ID, got %d", id)
		}
		t.Logf("Created entity with ID: %d", id)
	})

	t.Run("GetByID", func(t *testing.T) {
		// First create an entity
		entity := newXccdf12ValueType("getbyid")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Then retrieve it
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		if retrieved == nil {
			t.Fatal("Expected entity, got nil")
		}
		if retrieved.ID != id {
			t.Errorf("Expected ID %d, got %d", id, retrieved.ID)
		}
	})

	t.Run("GetAll", func(t *testing.T) {
		// Create multiple entities
		for i := 0; i < 3; i++ {
			entity := newXccdf12ValueType(fmt.Sprintf("getall_%d", i))
			_, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
		}

		// Get all
		entities, err := repo.GetAll(ctx, 100, 0)
		if err != nil {
			t.Fatalf("GetAll failed: %v", err)
		}
		if len(entities) < 3 {
			t.Errorf("Expected at least 3 entities, got %d", len(entities))
		}
	})

	t.Run("Update", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12ValueType("update_orig")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Retrieve and update
		retrieved, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID failed: %v", err)
		}
		// Modify a field
		retrieved.XsdId = "updated_value"
		// Update
		if err := repo.Update(ctx, retrieved); err != nil {
			t.Fatalf("Update failed: %v", err)
		}

		// Verify update
		updated, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after update failed: %v", err)
		}
		if updated.XsdId != "updated_value" {
			t.Errorf("Expected updated value, got %s", updated.XsdId)
		}
	})

	t.Run("Delete", func(t *testing.T) {
		// Create an entity
		entity := newXccdf12ValueType("delete")
		id, err := repo.Create(ctx, entity)
		if err != nil {
			t.Fatalf("Create failed: %v", err)
		}

		// Delete it
		if err := repo.Delete(ctx, id); err != nil {
			t.Fatalf("Delete failed: %v", err)
		}

		// Verify deletion - GetByID returns nil, nil for non-existent entities
		deleted, err := repo.GetByID(ctx, id)
		if err != nil {
			t.Fatalf("GetByID after delete failed: %v", err)
		}
		if deleted != nil {
			t.Error("Expected nil entity after delete, got non-nil")
		}
	})

	t.Run("Count", func(t *testing.T) {
		count, err := repo.Count(ctx)
		if err != nil {
			t.Fatalf("Count failed: %v", err)
		}
		t.Logf("Table has %d records", count)
	})

	t.Run("CreateBatch", func(t *testing.T) {
		entities := make([]*parent.Xccdf12ValueType, 5)
		for i := 0; i < 5; i++ {
			entities[i] = newXccdf12ValueType(fmt.Sprintf("batch_%d", i))
		}

		ids, err := repo.CreateBatch(ctx, entities)
		if err != nil {
			t.Fatalf("CreateBatch failed: %v", err)
		}
		if len(ids) != 5 {
			t.Errorf("Expected 5 IDs, got %d", len(ids))
		}
	})

	t.Run("DeleteBatch", func(t *testing.T) {
		// Create entities to delete
		var ids []int64
		for i := 0; i < 3; i++ {
			entity := newXccdf12ValueType(fmt.Sprintf("deletebatch_%d", i))
			id, err := repo.Create(ctx, entity)
			if err != nil {
				t.Fatalf("Create failed: %v", err)
			}
			ids = append(ids, id)
		}

		// Delete batch
		if err := repo.DeleteBatch(ctx, ids); err != nil {
			t.Fatalf("DeleteBatch failed: %v", err)
		}

		// Verify all deleted - GetByID returns nil, nil for non-existent entities
		for _, id := range ids {
			deleted, err := repo.GetByID(ctx, id)
			if err != nil {
				t.Fatalf("GetByID after delete failed: %v", err)
			}
			if deleted != nil {
				t.Errorf("Expected nil entity for deleted ID %d", id)
			}
		}
	})
}

// =============================================================================
// GraphSaver Tests - SaveGraph and LoadGraph
// =============================================================================

// TestSqliteGraphSaver_NewGraphSaver tests creating a GraphSaver instance
func TestSqliteGraphSaver_NewGraphSaver(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	gs := dal.NewGraphSaver()
	if gs == nil {
		t.Fatal("NewGraphSaver returned nil")
	}
	t.Log("GraphSaver created successfully")
}

// TestSqliteGraphSaver_SaveGraph_NilEntity tests SaveGraph with nil entity
func TestSqliteGraphSaver_SaveGraph_NilEntity(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	gs := dal.NewGraphSaver()

	// Try to save nil
	err = gs.SaveGraph(ctx, nil)
	// Should handle nil gracefully (either error or no-op)
	t.Logf("SaveGraph(nil) result: %v", err)
}

// TestSqliteGraphSaver_LoadGraph_UnknownType tests LoadGraph with unknown type
func TestSqliteGraphSaver_LoadGraph_UnknownType(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	gs := dal.NewGraphSaver()

	// Try to load unknown type
	_, err = gs.LoadGraph(ctx, "UnknownTypeXYZ", 1)
	if err == nil {
		t.Error("Expected error for unknown type")
	}
	t.Logf("LoadGraph unknown type error: %v", err)
}

// TestSqliteGraphSaver_LoadGraph_NonExistentID tests LoadGraph with non-existent ID
func TestSqliteGraphSaver_LoadGraph_NonExistentID(t *testing.T) {
	dal, err := New(":memory:")
	if err != nil {
		t.Fatalf("Failed to create DAL: %v", err)
	}
	defer dal.Close()

	ctx := context.Background()
	if err := dal.CreateSchema(ctx); err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	defer dal.DropSchema(ctx)

	gs := dal.NewGraphSaver()

	// Try to load non-existent ID
	result, err := gs.LoadGraph(ctx, "VariableType", 999999)
	if err != nil {
		t.Logf("LoadGraph non-existent ID error: %v", err)
	}
	if result != nil {
		t.Logf("LoadGraph non-existent ID returned: %T", result)
	} else {
		t.Log("LoadGraph correctly returned nil for non-existent ID")
	}
}

