// Package asset_identification1_1 - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package asset_identification1_1

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestAssetElement_MarshalUnmarshal tests XML round-trip for AssetElement
func TestAssetElement_MarshalUnmarshal(t *testing.T) {
	original := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAssetElement_MarshalIndentClean(t *testing.T) {
	elem := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAssetElement_ToBytes tests the ToBytes method
func TestAssetElement_ToBytes(t *testing.T) {
	elem := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAssetElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAssetElement_SetElementPrefixes(t *testing.T) {
	elem := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAssetElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAssetElement_SetElementsWithXmlns(t *testing.T) {
	elem := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAssetElement_SaveAndLoad tests SaveToFile and LoadAssetFromFile
func TestAssetElement_SaveAndLoad(t *testing.T) {
	elem := &AssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAssetFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAssetElement_LoadFromBytes tests the LoadAssetFromBytes function
func TestAssetElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<asset xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></asset>`)

	loaded, err := LoadAssetFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAssetElementType_MarshalUnmarshal tests XML round-trip for AssetElementType
func TestAssetElementType_MarshalUnmarshal(t *testing.T) {
	original := &AssetElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetIdentificationType_MarshalUnmarshal tests XML round-trip for AssetIdentificationType
func TestAssetIdentificationType_MarshalUnmarshal(t *testing.T) {
	original := &AssetIdentificationType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetIdentificationType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetRelatedElement_MarshalUnmarshal tests XML round-trip for AssetRelatedElement
func TestAssetRelatedElement_MarshalUnmarshal(t *testing.T) {
	original := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetRelatedElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetRelatedElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAssetRelatedElement_MarshalIndentClean(t *testing.T) {
	elem := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAssetRelatedElement_ToBytes tests the ToBytes method
func TestAssetRelatedElement_ToBytes(t *testing.T) {
	elem := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAssetRelatedElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAssetRelatedElement_SetElementPrefixes(t *testing.T) {
	elem := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAssetRelatedElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAssetRelatedElement_SetElementsWithXmlns(t *testing.T) {
	elem := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAssetRelatedElement_SaveAndLoad tests SaveToFile and LoadAssetRelatedFromFile
func TestAssetRelatedElement_SaveAndLoad(t *testing.T) {
	elem := &AssetRelatedElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "asset-related"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAssetRelatedFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAssetRelatedElement_LoadFromBytes tests the LoadAssetRelatedFromBytes function
func TestAssetRelatedElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<asset-related xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></asset-related>`)

	loaded, err := LoadAssetRelatedFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAssetType_MarshalUnmarshal tests XML round-trip for AssetType
func TestAssetType_MarshalUnmarshal(t *testing.T) {
	original := &AssetType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetsElement_MarshalUnmarshal tests XML round-trip for AssetsElement
func TestAssetsElement_MarshalUnmarshal(t *testing.T) {
	original := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetsElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetsElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAssetsElement_MarshalIndentClean(t *testing.T) {
	elem := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAssetsElement_ToBytes tests the ToBytes method
func TestAssetsElement_ToBytes(t *testing.T) {
	elem := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAssetsElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAssetsElement_SetElementPrefixes(t *testing.T) {
	elem := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAssetsElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAssetsElement_SetElementsWithXmlns(t *testing.T) {
	elem := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAssetsElement_SaveAndLoad tests SaveToFile and LoadAssetsFromFile
func TestAssetsElement_SaveAndLoad(t *testing.T) {
	elem := &AssetsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "assets"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAssetsFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAssetsElement_LoadFromBytes tests the LoadAssetsFromBytes function
func TestAssetsElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<assets xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></assets>`)

	loaded, err := LoadAssetsFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAssetsType_MarshalUnmarshal tests XML round-trip for AssetsType
func TestAssetsType_MarshalUnmarshal(t *testing.T) {
	original := &AssetsType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetsType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestBirthdateElementType_MarshalUnmarshal tests XML round-trip for BirthdateElementType
func TestBirthdateElementType_MarshalUnmarshal(t *testing.T) {
	original := &BirthdateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded BirthdateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCidrElementType_MarshalUnmarshal tests XML round-trip for CidrElementType
func TestCidrElementType_MarshalUnmarshal(t *testing.T) {
	original := &CidrElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CidrElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCircuitElement_MarshalUnmarshal tests XML round-trip for CircuitElement
func TestCircuitElement_MarshalUnmarshal(t *testing.T) {
	original := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CircuitElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCircuitElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCircuitElement_MarshalIndentClean(t *testing.T) {
	elem := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCircuitElement_ToBytes tests the ToBytes method
func TestCircuitElement_ToBytes(t *testing.T) {
	elem := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCircuitElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCircuitElement_SetElementPrefixes(t *testing.T) {
	elem := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCircuitElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCircuitElement_SetElementsWithXmlns(t *testing.T) {
	elem := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCircuitElement_SaveAndLoad tests SaveToFile and LoadCircuitFromFile
func TestCircuitElement_SaveAndLoad(t *testing.T) {
	elem := &CircuitElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "circuit"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCircuitFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCircuitElement_LoadFromBytes tests the LoadCircuitFromBytes function
func TestCircuitElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<circuit xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></circuit>`)

	loaded, err := LoadCircuitFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCircuitNameElementType_MarshalUnmarshal tests XML round-trip for CircuitNameElementType
func TestCircuitNameElementType_MarshalUnmarshal(t *testing.T) {
	original := &CircuitNameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CircuitNameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCircuitType_MarshalUnmarshal tests XML round-trip for CircuitType
func TestCircuitType_MarshalUnmarshal(t *testing.T) {
	original := &CircuitType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CircuitType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestComputingDeviceElement_MarshalUnmarshal tests XML round-trip for ComputingDeviceElement
func TestComputingDeviceElement_MarshalUnmarshal(t *testing.T) {
	original := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ComputingDeviceElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestComputingDeviceElement_MarshalIndentClean tests the MarshalIndentClean method
func TestComputingDeviceElement_MarshalIndentClean(t *testing.T) {
	elem := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestComputingDeviceElement_ToBytes tests the ToBytes method
func TestComputingDeviceElement_ToBytes(t *testing.T) {
	elem := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestComputingDeviceElement_SetElementPrefixes tests the SetElementPrefixes method
func TestComputingDeviceElement_SetElementPrefixes(t *testing.T) {
	elem := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestComputingDeviceElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestComputingDeviceElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestComputingDeviceElement_SaveAndLoad tests SaveToFile and LoadComputingDeviceFromFile
func TestComputingDeviceElement_SaveAndLoad(t *testing.T) {
	elem := &ComputingDeviceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "computing-device"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadComputingDeviceFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestComputingDeviceElement_LoadFromBytes tests the LoadComputingDeviceFromBytes function
func TestComputingDeviceElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<computing-device xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></computing-device>`)

	loaded, err := LoadComputingDeviceFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestComputingDeviceType_MarshalUnmarshal tests XML round-trip for ComputingDeviceType
func TestComputingDeviceType_MarshalUnmarshal(t *testing.T) {
	original := &ComputingDeviceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ComputingDeviceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestConnectionsElementType_MarshalUnmarshal tests XML round-trip for ConnectionsElementType
func TestConnectionsElementType_MarshalUnmarshal(t *testing.T) {
	original := &ConnectionsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ConnectionsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCpeElement_MarshalUnmarshal tests XML round-trip for CpeElement
func TestCpeElement_MarshalUnmarshal(t *testing.T) {
	original := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CpeElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCpeElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCpeElement_MarshalIndentClean(t *testing.T) {
	elem := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCpeElement_ToBytes tests the ToBytes method
func TestCpeElement_ToBytes(t *testing.T) {
	elem := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCpeElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCpeElement_SetElementPrefixes(t *testing.T) {
	elem := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCpeElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCpeElement_SetElementsWithXmlns(t *testing.T) {
	elem := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCpeElement_SaveAndLoad tests SaveToFile and LoadCpeFromFile
func TestCpeElement_SaveAndLoad(t *testing.T) {
	elem := &CpeElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "cpe"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCpeFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCpeElement_LoadFromBytes tests the LoadCpeFromBytes function
func TestCpeElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<cpe xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></cpe>`)

	loaded, err := LoadCpeFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCpeElementType_MarshalUnmarshal tests XML round-trip for CpeElementType
func TestCpeElementType_MarshalUnmarshal(t *testing.T) {
	original := &CpeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CpeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCpeType_MarshalUnmarshal tests XML round-trip for CpeType
func TestCpeType_MarshalUnmarshal(t *testing.T) {
	original := &CpeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CpeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDataElement_MarshalUnmarshal tests XML round-trip for DataElement
func TestDataElement_MarshalUnmarshal(t *testing.T) {
	original := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DataElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDataElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDataElement_MarshalIndentClean(t *testing.T) {
	elem := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDataElement_ToBytes tests the ToBytes method
func TestDataElement_ToBytes(t *testing.T) {
	elem := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDataElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDataElement_SetElementPrefixes(t *testing.T) {
	elem := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDataElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDataElement_SetElementsWithXmlns(t *testing.T) {
	elem := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDataElement_SaveAndLoad tests SaveToFile and LoadDataFromFile
func TestDataElement_SaveAndLoad(t *testing.T) {
	elem := &DataElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "data"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDataFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDataElement_LoadFromBytes tests the LoadDataFromBytes function
func TestDataElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<data xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></data>`)

	loaded, err := LoadDataFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDataType_MarshalUnmarshal tests XML round-trip for DataType
func TestDataType_MarshalUnmarshal(t *testing.T) {
	original := &DataType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DataType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDatabaseElement_MarshalUnmarshal tests XML round-trip for DatabaseElement
func TestDatabaseElement_MarshalUnmarshal(t *testing.T) {
	original := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DatabaseElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDatabaseElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDatabaseElement_MarshalIndentClean(t *testing.T) {
	elem := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDatabaseElement_ToBytes tests the ToBytes method
func TestDatabaseElement_ToBytes(t *testing.T) {
	elem := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDatabaseElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDatabaseElement_SetElementPrefixes(t *testing.T) {
	elem := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDatabaseElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDatabaseElement_SetElementsWithXmlns(t *testing.T) {
	elem := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDatabaseElement_SaveAndLoad tests SaveToFile and LoadDatabaseFromFile
func TestDatabaseElement_SaveAndLoad(t *testing.T) {
	elem := &DatabaseElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "database"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDatabaseFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDatabaseElement_LoadFromBytes tests the LoadDatabaseFromBytes function
func TestDatabaseElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<database xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></database>`)

	loaded, err := LoadDatabaseFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDatabaseType_MarshalUnmarshal tests XML round-trip for DatabaseType
func TestDatabaseType_MarshalUnmarshal(t *testing.T) {
	original := &DatabaseType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DatabaseType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDistinguishedNameElementType_MarshalUnmarshal tests XML round-trip for DistinguishedNameElementType
func TestDistinguishedNameElementType_MarshalUnmarshal(t *testing.T) {
	original := &DistinguishedNameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DistinguishedNameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDocumentRootElementType_MarshalUnmarshal tests XML round-trip for DocumentRootElementType
func TestDocumentRootElementType_MarshalUnmarshal(t *testing.T) {
	original := &DocumentRootElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded DocumentRootElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEmailAddressElement_MarshalUnmarshal tests XML round-trip for EmailAddressElement
func TestEmailAddressElement_MarshalUnmarshal(t *testing.T) {
	original := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EmailAddressElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEmailAddressElement_MarshalIndentClean tests the MarshalIndentClean method
func TestEmailAddressElement_MarshalIndentClean(t *testing.T) {
	elem := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestEmailAddressElement_ToBytes tests the ToBytes method
func TestEmailAddressElement_ToBytes(t *testing.T) {
	elem := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestEmailAddressElement_SetElementPrefixes tests the SetElementPrefixes method
func TestEmailAddressElement_SetElementPrefixes(t *testing.T) {
	elem := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestEmailAddressElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestEmailAddressElement_SetElementsWithXmlns(t *testing.T) {
	elem := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestEmailAddressElement_SaveAndLoad tests SaveToFile and LoadEmailAddressFromFile
func TestEmailAddressElement_SaveAndLoad(t *testing.T) {
	elem := &EmailAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "email-address"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadEmailAddressFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestEmailAddressElement_LoadFromBytes tests the LoadEmailAddressFromBytes function
func TestEmailAddressElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<email-address xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></email-address>`)

	loaded, err := LoadEmailAddressFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestEmailAddressElementType_MarshalUnmarshal tests XML round-trip for EmailAddressElementType
func TestEmailAddressElementType_MarshalUnmarshal(t *testing.T) {
	original := &EmailAddressElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EmailAddressElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtendedInformationElementType_MarshalUnmarshal tests XML round-trip for ExtendedInformationElementType
func TestExtendedInformationElementType_MarshalUnmarshal(t *testing.T) {
	original := &ExtendedInformationElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ExtendedInformationElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFqdnElement_MarshalUnmarshal tests XML round-trip for FqdnElement
func TestFqdnElement_MarshalUnmarshal(t *testing.T) {
	original := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FqdnElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFqdnElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFqdnElement_MarshalIndentClean(t *testing.T) {
	elem := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFqdnElement_ToBytes tests the ToBytes method
func TestFqdnElement_ToBytes(t *testing.T) {
	elem := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFqdnElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFqdnElement_SetElementPrefixes(t *testing.T) {
	elem := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFqdnElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFqdnElement_SetElementsWithXmlns(t *testing.T) {
	elem := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFqdnElement_SaveAndLoad tests SaveToFile and LoadFqdnFromFile
func TestFqdnElement_SaveAndLoad(t *testing.T) {
	elem := &FqdnElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "fqdn"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFqdnFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFqdnElement_LoadFromBytes tests the LoadFqdnFromBytes function
func TestFqdnElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fqdn xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></fqdn>`)

	loaded, err := LoadFqdnFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFqdnElementType_MarshalUnmarshal tests XML round-trip for FqdnElementType
func TestFqdnElementType_MarshalUnmarshal(t *testing.T) {
	original := &FqdnElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FqdnElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestHostElementType_MarshalUnmarshal tests XML round-trip for HostElementType
func TestHostElementType_MarshalUnmarshal(t *testing.T) {
	original := &HostElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded HostElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestHostnameElementType_MarshalUnmarshal tests XML round-trip for HostnameElementType
func TestHostnameElementType_MarshalUnmarshal(t *testing.T) {
	original := &HostnameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded HostnameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInstallationIdElementType_MarshalUnmarshal tests XML round-trip for InstallationIdElementType
func TestInstallationIdElementType_MarshalUnmarshal(t *testing.T) {
	original := &InstallationIdElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded InstallationIdElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInstanceNameElementType_MarshalUnmarshal tests XML round-trip for InstanceNameElementType
func TestInstanceNameElementType_MarshalUnmarshal(t *testing.T) {
	original := &InstanceNameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded InstanceNameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIpAddressElement_MarshalUnmarshal tests XML round-trip for IpAddressElement
func TestIpAddressElement_MarshalUnmarshal(t *testing.T) {
	original := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded IpAddressElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIpAddressElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIpAddressElement_MarshalIndentClean(t *testing.T) {
	elem := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIpAddressElement_ToBytes tests the ToBytes method
func TestIpAddressElement_ToBytes(t *testing.T) {
	elem := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIpAddressElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIpAddressElement_SetElementPrefixes(t *testing.T) {
	elem := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIpAddressElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIpAddressElement_SetElementsWithXmlns(t *testing.T) {
	elem := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIpAddressElement_SaveAndLoad tests SaveToFile and LoadIpAddressFromFile
func TestIpAddressElement_SaveAndLoad(t *testing.T) {
	elem := &IpAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "ip-address"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIpAddressFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIpAddressElement_LoadFromBytes tests the LoadIpAddressFromBytes function
func TestIpAddressElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ip-address xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></ip-address>`)

	loaded, err := LoadIpAddressFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIpAddressType_MarshalUnmarshal tests XML round-trip for IpAddressType
func TestIpAddressType_MarshalUnmarshal(t *testing.T) {
	original := &IpAddressType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded IpAddressType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIpNetRangeElementType_MarshalUnmarshal tests XML round-trip for IpNetRangeElementType
func TestIpNetRangeElementType_MarshalUnmarshal(t *testing.T) {
	original := &IpNetRangeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded IpNetRangeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIpV4ElementType_MarshalUnmarshal tests XML round-trip for IpV4ElementType
func TestIpV4ElementType_MarshalUnmarshal(t *testing.T) {
	original := &IpV4ElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded IpV4ElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIpV6ElementType_MarshalUnmarshal tests XML round-trip for IpV6ElementType
func TestIpV6ElementType_MarshalUnmarshal(t *testing.T) {
	original := &IpV6ElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded IpV6ElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestItAssetElement_MarshalUnmarshal tests XML round-trip for ItAssetElement
func TestItAssetElement_MarshalUnmarshal(t *testing.T) {
	original := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ItAssetElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestItAssetElement_MarshalIndentClean tests the MarshalIndentClean method
func TestItAssetElement_MarshalIndentClean(t *testing.T) {
	elem := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestItAssetElement_ToBytes tests the ToBytes method
func TestItAssetElement_ToBytes(t *testing.T) {
	elem := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestItAssetElement_SetElementPrefixes tests the SetElementPrefixes method
func TestItAssetElement_SetElementPrefixes(t *testing.T) {
	elem := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestItAssetElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestItAssetElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestItAssetElement_SaveAndLoad tests SaveToFile and LoadItAssetFromFile
func TestItAssetElement_SaveAndLoad(t *testing.T) {
	elem := &ItAssetElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "it-asset"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadItAssetFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestItAssetElement_LoadFromBytes tests the LoadItAssetFromBytes function
func TestItAssetElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<it-asset xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></it-asset>`)

	loaded, err := LoadItAssetFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestItAssetType_MarshalUnmarshal tests XML round-trip for ItAssetType
func TestItAssetType_MarshalUnmarshal(t *testing.T) {
	original := &ItAssetType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ItAssetType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicenseElementType_MarshalUnmarshal tests XML round-trip for LicenseElementType
func TestLicenseElementType_MarshalUnmarshal(t *testing.T) {
	original := &LicenseElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LicenseElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocaleElementType_MarshalUnmarshal tests XML round-trip for LocaleElementType
func TestLocaleElementType_MarshalUnmarshal(t *testing.T) {
	original := &LocaleElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocaleElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationAddressElement_MarshalUnmarshal tests XML round-trip for LocationAddressElement
func TestLocationAddressElement_MarshalUnmarshal(t *testing.T) {
	original := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationAddressElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationAddressElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLocationAddressElement_MarshalIndentClean(t *testing.T) {
	elem := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLocationAddressElement_ToBytes tests the ToBytes method
func TestLocationAddressElement_ToBytes(t *testing.T) {
	elem := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLocationAddressElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLocationAddressElement_SetElementPrefixes(t *testing.T) {
	elem := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLocationAddressElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLocationAddressElement_SetElementsWithXmlns(t *testing.T) {
	elem := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLocationAddressElement_SaveAndLoad tests SaveToFile and LoadLocationAddressFromFile
func TestLocationAddressElement_SaveAndLoad(t *testing.T) {
	elem := &LocationAddressElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-address"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLocationAddressFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLocationAddressElement_LoadFromBytes tests the LoadLocationAddressFromBytes function
func TestLocationAddressElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<location-address xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></location-address>`)

	loaded, err := LoadLocationAddressFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLocationElement_MarshalUnmarshal tests XML round-trip for LocationElement
func TestLocationElement_MarshalUnmarshal(t *testing.T) {
	original := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLocationElement_MarshalIndentClean(t *testing.T) {
	elem := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLocationElement_ToBytes tests the ToBytes method
func TestLocationElement_ToBytes(t *testing.T) {
	elem := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLocationElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLocationElement_SetElementPrefixes(t *testing.T) {
	elem := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLocationElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLocationElement_SetElementsWithXmlns(t *testing.T) {
	elem := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLocationElement_SaveAndLoad tests SaveToFile and LoadLocationFromFile
func TestLocationElement_SaveAndLoad(t *testing.T) {
	elem := &LocationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLocationFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLocationElement_LoadFromBytes tests the LoadLocationFromBytes function
func TestLocationElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<location xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></location>`)

	loaded, err := LoadLocationFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLocationPointElement_MarshalUnmarshal tests XML round-trip for LocationPointElement
func TestLocationPointElement_MarshalUnmarshal(t *testing.T) {
	original := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationPointElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationPointElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLocationPointElement_MarshalIndentClean(t *testing.T) {
	elem := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLocationPointElement_ToBytes tests the ToBytes method
func TestLocationPointElement_ToBytes(t *testing.T) {
	elem := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLocationPointElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLocationPointElement_SetElementPrefixes(t *testing.T) {
	elem := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLocationPointElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLocationPointElement_SetElementsWithXmlns(t *testing.T) {
	elem := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLocationPointElement_SaveAndLoad tests SaveToFile and LoadLocationPointFromFile
func TestLocationPointElement_SaveAndLoad(t *testing.T) {
	elem := &LocationPointElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-point"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLocationPointFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLocationPointElement_LoadFromBytes tests the LoadLocationPointFromBytes function
func TestLocationPointElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<location-point xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></location-point>`)

	loaded, err := LoadLocationPointFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLocationPointElementType_MarshalUnmarshal tests XML round-trip for LocationPointElementType
func TestLocationPointElementType_MarshalUnmarshal(t *testing.T) {
	original := &LocationPointElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationPointElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationRegionElement_MarshalUnmarshal tests XML round-trip for LocationRegionElement
func TestLocationRegionElement_MarshalUnmarshal(t *testing.T) {
	original := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationRegionElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationRegionElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLocationRegionElement_MarshalIndentClean(t *testing.T) {
	elem := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLocationRegionElement_ToBytes tests the ToBytes method
func TestLocationRegionElement_ToBytes(t *testing.T) {
	elem := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLocationRegionElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLocationRegionElement_SetElementPrefixes(t *testing.T) {
	elem := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLocationRegionElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLocationRegionElement_SetElementsWithXmlns(t *testing.T) {
	elem := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLocationRegionElement_SaveAndLoad tests SaveToFile and LoadLocationRegionFromFile
func TestLocationRegionElement_SaveAndLoad(t *testing.T) {
	elem := &LocationRegionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "location-region"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLocationRegionFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLocationRegionElement_LoadFromBytes tests the LoadLocationRegionFromBytes function
func TestLocationRegionElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<location-region xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></location-region>`)

	loaded, err := LoadLocationRegionFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLocationRegionElementType_MarshalUnmarshal tests XML round-trip for LocationRegionElementType
func TestLocationRegionElementType_MarshalUnmarshal(t *testing.T) {
	original := &LocationRegionElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationRegionElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationsElement_MarshalUnmarshal tests XML round-trip for LocationsElement
func TestLocationsElement_MarshalUnmarshal(t *testing.T) {
	original := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationsElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLocationsElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLocationsElement_MarshalIndentClean(t *testing.T) {
	elem := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLocationsElement_ToBytes tests the ToBytes method
func TestLocationsElement_ToBytes(t *testing.T) {
	elem := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLocationsElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLocationsElement_SetElementPrefixes(t *testing.T) {
	elem := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLocationsElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLocationsElement_SetElementsWithXmlns(t *testing.T) {
	elem := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLocationsElement_SaveAndLoad tests SaveToFile and LoadLocationsFromFile
func TestLocationsElement_SaveAndLoad(t *testing.T) {
	elem := &LocationsElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "locations"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLocationsFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLocationsElement_LoadFromBytes tests the LoadLocationsFromBytes function
func TestLocationsElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<locations xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></locations>`)

	loaded, err := LoadLocationsFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLocationsElementType_MarshalUnmarshal tests XML round-trip for LocationsElementType
func TestLocationsElementType_MarshalUnmarshal(t *testing.T) {
	original := &LocationsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded LocationsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMacAddressElementType_MarshalUnmarshal tests XML round-trip for MacAddressElementType
func TestMacAddressElementType_MarshalUnmarshal(t *testing.T) {
	original := &MacAddressElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded MacAddressElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMotherboardGuidElementType_MarshalUnmarshal tests XML round-trip for MotherboardGuidElementType
func TestMotherboardGuidElementType_MarshalUnmarshal(t *testing.T) {
	original := &MotherboardGuidElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded MotherboardGuidElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNetworkElement_MarshalUnmarshal tests XML round-trip for NetworkElement
func TestNetworkElement_MarshalUnmarshal(t *testing.T) {
	original := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded NetworkElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNetworkElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNetworkElement_MarshalIndentClean(t *testing.T) {
	elem := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNetworkElement_ToBytes tests the ToBytes method
func TestNetworkElement_ToBytes(t *testing.T) {
	elem := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNetworkElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNetworkElement_SetElementPrefixes(t *testing.T) {
	elem := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNetworkElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNetworkElement_SetElementsWithXmlns(t *testing.T) {
	elem := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNetworkElement_SaveAndLoad tests SaveToFile and LoadNetworkFromFile
func TestNetworkElement_SaveAndLoad(t *testing.T) {
	elem := &NetworkElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "network"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNetworkFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNetworkElement_LoadFromBytes tests the LoadNetworkFromBytes function
func TestNetworkElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<network xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></network>`)

	loaded, err := LoadNetworkFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNetworkInterfaceType_MarshalUnmarshal tests XML round-trip for NetworkInterfaceType
func TestNetworkInterfaceType_MarshalUnmarshal(t *testing.T) {
	original := &NetworkInterfaceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded NetworkInterfaceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNetworkNameElementType_MarshalUnmarshal tests XML round-trip for NetworkNameElementType
func TestNetworkNameElementType_MarshalUnmarshal(t *testing.T) {
	original := &NetworkNameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded NetworkNameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNetworkType_MarshalUnmarshal tests XML round-trip for NetworkType
func TestNetworkType_MarshalUnmarshal(t *testing.T) {
	original := &NetworkType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded NetworkType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestOrganizationElement_MarshalUnmarshal tests XML round-trip for OrganizationElement
func TestOrganizationElement_MarshalUnmarshal(t *testing.T) {
	original := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded OrganizationElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestOrganizationElement_MarshalIndentClean tests the MarshalIndentClean method
func TestOrganizationElement_MarshalIndentClean(t *testing.T) {
	elem := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestOrganizationElement_ToBytes tests the ToBytes method
func TestOrganizationElement_ToBytes(t *testing.T) {
	elem := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestOrganizationElement_SetElementPrefixes tests the SetElementPrefixes method
func TestOrganizationElement_SetElementPrefixes(t *testing.T) {
	elem := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestOrganizationElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestOrganizationElement_SetElementsWithXmlns(t *testing.T) {
	elem := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestOrganizationElement_SaveAndLoad tests SaveToFile and LoadOrganizationFromFile
func TestOrganizationElement_SaveAndLoad(t *testing.T) {
	elem := &OrganizationElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "organization"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadOrganizationFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestOrganizationElement_LoadFromBytes tests the LoadOrganizationFromBytes function
func TestOrganizationElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<organization xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></organization>`)

	loaded, err := LoadOrganizationFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestOrganizationType_MarshalUnmarshal tests XML round-trip for OrganizationType
func TestOrganizationType_MarshalUnmarshal(t *testing.T) {
	original := &OrganizationType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded OrganizationType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPersonElement_MarshalUnmarshal tests XML round-trip for PersonElement
func TestPersonElement_MarshalUnmarshal(t *testing.T) {
	original := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PersonElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPersonElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPersonElement_MarshalIndentClean(t *testing.T) {
	elem := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPersonElement_ToBytes tests the ToBytes method
func TestPersonElement_ToBytes(t *testing.T) {
	elem := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPersonElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPersonElement_SetElementPrefixes(t *testing.T) {
	elem := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPersonElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPersonElement_SetElementsWithXmlns(t *testing.T) {
	elem := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPersonElement_SaveAndLoad tests SaveToFile and LoadPersonFromFile
func TestPersonElement_SaveAndLoad(t *testing.T) {
	elem := &PersonElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "person"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPersonFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPersonElement_LoadFromBytes tests the LoadPersonFromBytes function
func TestPersonElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<person xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></person>`)

	loaded, err := LoadPersonFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPersonType_MarshalUnmarshal tests XML round-trip for PersonType
func TestPersonType_MarshalUnmarshal(t *testing.T) {
	original := &PersonType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PersonType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPortElementType_MarshalUnmarshal tests XML round-trip for PortElementType
func TestPortElementType_MarshalUnmarshal(t *testing.T) {
	original := &PortElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PortElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPortRangeElementType_MarshalUnmarshal tests XML round-trip for PortRangeElementType
func TestPortRangeElementType_MarshalUnmarshal(t *testing.T) {
	original := &PortRangeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PortRangeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProtocolElementType_MarshalUnmarshal tests XML round-trip for ProtocolElementType
func TestProtocolElementType_MarshalUnmarshal(t *testing.T) {
	original := &ProtocolElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ProtocolElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServedByElement_MarshalUnmarshal tests XML round-trip for ServedByElement
func TestServedByElement_MarshalUnmarshal(t *testing.T) {
	original := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ServedByElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServedByElement_MarshalIndentClean tests the MarshalIndentClean method
func TestServedByElement_MarshalIndentClean(t *testing.T) {
	elem := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestServedByElement_ToBytes tests the ToBytes method
func TestServedByElement_ToBytes(t *testing.T) {
	elem := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestServedByElement_SetElementPrefixes tests the SetElementPrefixes method
func TestServedByElement_SetElementPrefixes(t *testing.T) {
	elem := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestServedByElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestServedByElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestServedByElement_SaveAndLoad tests SaveToFile and LoadServedByFromFile
func TestServedByElement_SaveAndLoad(t *testing.T) {
	elem := &ServedByElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "served-by"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadServedByFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestServedByElement_LoadFromBytes tests the LoadServedByFromBytes function
func TestServedByElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<served-by xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></served-by>`)

	loaded, err := LoadServedByFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestServiceElement_MarshalUnmarshal tests XML round-trip for ServiceElement
func TestServiceElement_MarshalUnmarshal(t *testing.T) {
	original := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ServiceElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceElement_MarshalIndentClean tests the MarshalIndentClean method
func TestServiceElement_MarshalIndentClean(t *testing.T) {
	elem := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestServiceElement_ToBytes tests the ToBytes method
func TestServiceElement_ToBytes(t *testing.T) {
	elem := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestServiceElement_SetElementPrefixes tests the SetElementPrefixes method
func TestServiceElement_SetElementPrefixes(t *testing.T) {
	elem := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestServiceElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestServiceElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestServiceElement_SaveAndLoad tests SaveToFile and LoadServiceFromFile
func TestServiceElement_SaveAndLoad(t *testing.T) {
	elem := &ServiceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "service"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadServiceFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestServiceElement_LoadFromBytes tests the LoadServiceFromBytes function
func TestServiceElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></service>`)

	loaded, err := LoadServiceFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestServiceType_MarshalUnmarshal tests XML round-trip for ServiceType
func TestServiceType_MarshalUnmarshal(t *testing.T) {
	original := &ServiceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ServiceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareElement_MarshalUnmarshal tests XML round-trip for SoftwareElement
func TestSoftwareElement_MarshalUnmarshal(t *testing.T) {
	original := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SoftwareElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSoftwareElement_MarshalIndentClean(t *testing.T) {
	elem := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSoftwareElement_ToBytes tests the ToBytes method
func TestSoftwareElement_ToBytes(t *testing.T) {
	elem := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSoftwareElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSoftwareElement_SetElementPrefixes(t *testing.T) {
	elem := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSoftwareElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSoftwareElement_SetElementsWithXmlns(t *testing.T) {
	elem := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSoftwareElement_SaveAndLoad tests SaveToFile and LoadSoftwareFromFile
func TestSoftwareElement_SaveAndLoad(t *testing.T) {
	elem := &SoftwareElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "software"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSoftwareFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSoftwareElement_LoadFromBytes tests the LoadSoftwareFromBytes function
func TestSoftwareElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<software xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></software>`)

	loaded, err := LoadSoftwareFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSoftwareType_MarshalUnmarshal tests XML round-trip for SoftwareType
func TestSoftwareType_MarshalUnmarshal(t *testing.T) {
	original := &SoftwareType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SoftwareType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSyntheticIdElement_MarshalUnmarshal tests XML round-trip for SyntheticIdElement
func TestSyntheticIdElement_MarshalUnmarshal(t *testing.T) {
	original := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SyntheticIdElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSyntheticIdElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSyntheticIdElement_MarshalIndentClean(t *testing.T) {
	elem := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSyntheticIdElement_ToBytes tests the ToBytes method
func TestSyntheticIdElement_ToBytes(t *testing.T) {
	elem := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSyntheticIdElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSyntheticIdElement_SetElementPrefixes(t *testing.T) {
	elem := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSyntheticIdElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSyntheticIdElement_SetElementsWithXmlns(t *testing.T) {
	elem := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSyntheticIdElement_SaveAndLoad tests SaveToFile and LoadSyntheticIdFromFile
func TestSyntheticIdElement_SaveAndLoad(t *testing.T) {
	elem := &SyntheticIdElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "synthetic-id"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSyntheticIdFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSyntheticIdElement_LoadFromBytes tests the LoadSyntheticIdFromBytes function
func TestSyntheticIdElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<synthetic-id xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></synthetic-id>`)

	loaded, err := LoadSyntheticIdFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSyntheticIdElementType_MarshalUnmarshal tests XML round-trip for SyntheticIdElementType
func TestSyntheticIdElementType_MarshalUnmarshal(t *testing.T) {
	original := &SyntheticIdElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SyntheticIdElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemElement_MarshalUnmarshal tests XML round-trip for SystemElement
func TestSystemElement_MarshalUnmarshal(t *testing.T) {
	original := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SystemElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemElement_MarshalIndentClean(t *testing.T) {
	elem := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemElement_ToBytes tests the ToBytes method
func TestSystemElement_ToBytes(t *testing.T) {
	elem := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemElement_SetElementPrefixes(t *testing.T) {
	elem := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemElement_SetElementsWithXmlns(t *testing.T) {
	elem := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemElement_SaveAndLoad tests SaveToFile and LoadSystemFromFile
func TestSystemElement_SaveAndLoad(t *testing.T) {
	elem := &SystemElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "system"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemElement_LoadFromBytes tests the LoadSystemFromBytes function
func TestSystemElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<system xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></system>`)

	loaded, err := LoadSystemFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemNameElementType_MarshalUnmarshal tests XML round-trip for SystemNameElementType
func TestSystemNameElementType_MarshalUnmarshal(t *testing.T) {
	original := &SystemNameElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SystemNameElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemType_MarshalUnmarshal tests XML round-trip for SystemType
func TestSystemType_MarshalUnmarshal(t *testing.T) {
	original := &SystemType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SystemType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTelephoneNumberElement_MarshalUnmarshal tests XML round-trip for TelephoneNumberElement
func TestTelephoneNumberElement_MarshalUnmarshal(t *testing.T) {
	original := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded TelephoneNumberElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTelephoneNumberElement_MarshalIndentClean tests the MarshalIndentClean method
func TestTelephoneNumberElement_MarshalIndentClean(t *testing.T) {
	elem := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestTelephoneNumberElement_ToBytes tests the ToBytes method
func TestTelephoneNumberElement_ToBytes(t *testing.T) {
	elem := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestTelephoneNumberElement_SetElementPrefixes tests the SetElementPrefixes method
func TestTelephoneNumberElement_SetElementPrefixes(t *testing.T) {
	elem := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestTelephoneNumberElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestTelephoneNumberElement_SetElementsWithXmlns(t *testing.T) {
	elem := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestTelephoneNumberElement_SaveAndLoad tests SaveToFile and LoadTelephoneNumberFromFile
func TestTelephoneNumberElement_SaveAndLoad(t *testing.T) {
	elem := &TelephoneNumberElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "telephone-number"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadTelephoneNumberFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestTelephoneNumberElement_LoadFromBytes tests the LoadTelephoneNumberFromBytes function
func TestTelephoneNumberElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<telephone-number xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></telephone-number>`)

	loaded, err := LoadTelephoneNumberFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestTelephoneNumberElementType_MarshalUnmarshal tests XML round-trip for TelephoneNumberElementType
func TestTelephoneNumberElementType_MarshalUnmarshal(t *testing.T) {
	original := &TelephoneNumberElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded TelephoneNumberElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUrlElementType_MarshalUnmarshal tests XML round-trip for UrlElementType
func TestUrlElementType_MarshalUnmarshal(t *testing.T) {
	original := &UrlElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded UrlElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType_MarshalUnmarshal tests XML round-trip for VersionElementType
func TestVersionElementType_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWebsiteElement_MarshalUnmarshal tests XML round-trip for WebsiteElement
func TestWebsiteElement_MarshalUnmarshal(t *testing.T) {
	original := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded WebsiteElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWebsiteElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWebsiteElement_MarshalIndentClean(t *testing.T) {
	elem := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWebsiteElement_ToBytes tests the ToBytes method
func TestWebsiteElement_ToBytes(t *testing.T) {
	elem := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWebsiteElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWebsiteElement_SetElementPrefixes(t *testing.T) {
	elem := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWebsiteElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWebsiteElement_SetElementsWithXmlns(t *testing.T) {
	elem := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWebsiteElement_SaveAndLoad tests SaveToFile and LoadWebsiteFromFile
func TestWebsiteElement_SaveAndLoad(t *testing.T) {
	elem := &WebsiteElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWebsiteFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWebsiteElement_LoadFromBytes tests the LoadWebsiteFromBytes function
func TestWebsiteElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<website xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></website>`)

	loaded, err := LoadWebsiteFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWebsiteType_MarshalUnmarshal tests XML round-trip for WebsiteType
func TestWebsiteType_MarshalUnmarshal(t *testing.T) {
	original := &WebsiteType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded WebsiteType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWebsiteUrlElement_MarshalUnmarshal tests XML round-trip for WebsiteUrlElement
func TestWebsiteUrlElement_MarshalUnmarshal(t *testing.T) {
	original := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded WebsiteUrlElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWebsiteUrlElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWebsiteUrlElement_MarshalIndentClean(t *testing.T) {
	elem := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWebsiteUrlElement_ToBytes tests the ToBytes method
func TestWebsiteUrlElement_ToBytes(t *testing.T) {
	elem := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWebsiteUrlElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWebsiteUrlElement_SetElementPrefixes(t *testing.T) {
	elem := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWebsiteUrlElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWebsiteUrlElement_SetElementsWithXmlns(t *testing.T) {
	elem := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWebsiteUrlElement_SaveAndLoad tests SaveToFile and LoadWebsiteUrlFromFile
func TestWebsiteUrlElement_SaveAndLoad(t *testing.T) {
	elem := &WebsiteUrlElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-identification/1.1", Local: "website-url"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWebsiteUrlFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWebsiteUrlElement_LoadFromBytes tests the LoadWebsiteUrlFromBytes function
func TestWebsiteUrlElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<website-url xmlns="http://scap.nist.gov/schema/asset-identification/1.1"></website-url>`)

	loaded, err := LoadWebsiteUrlFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWebsiteUrlElementType_MarshalUnmarshal tests XML round-trip for WebsiteUrlElementType
func TestWebsiteUrlElementType_MarshalUnmarshal(t *testing.T) {
	original := &WebsiteUrlElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded WebsiteUrlElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
