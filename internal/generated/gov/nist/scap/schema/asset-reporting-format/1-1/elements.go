// Package asset_reporting_format1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-reporting-format/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-reporting-format_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_reporting_format1_1

import (
	"encoding/xml"
	"os"
	"strings"

	reporting_core1_1 "forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
)

// AssetReportCollectionElement represents the XSD element 'asset-report-collection'
// XSD element declaration (W3C XSD ยง3.3)
type AssetReportCollectionElement struct {
	XMLName                                      xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 asset-report-collection"`
	reporting_core1_1.RelationshipsContainerType          // XSD extension base
	// ReportRequests represents XSD element 'report-requests'
	// minOccurs=0, maxOccurs=1
	ReportRequests *ReportRequestsElementType `xml:"report-requests,omitempty"`
	// Assets represents XSD element 'assets'
	// minOccurs=0, maxOccurs=1
	Assets *AssetsElementType `xml:"assets,omitempty"`
	// Reports represents XSD element 'reports'
	Reports ReportsElementType `xml:"reports"`
	// ExtendedInfos represents XSD element 'extended-infos'
	// minOccurs=0, maxOccurs=1
	ExtendedInfos *ExtendedInfosElementType `xml:"extended-infos,omitempty"`
	// Id represents XSD attribute 'id'
	// use="optional"
	Id *string `xml:"id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *AssetReportCollectionElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias AssetReportCollectionElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *AssetReportCollectionElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias AssetReportCollectionElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *AssetReportCollectionElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *AssetReportCollectionElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *AssetReportCollectionElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *AssetReportCollectionElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *AssetReportCollectionElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAssetReportCollectionFromBytes loads an element from bytes with namespace preservation
func LoadAssetReportCollectionFromBytes(data []byte) (*AssetReportCollectionElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element AssetReportCollectionElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAssetReportCollectionFromFile loads an element from a file with namespace preservation
func LoadAssetReportCollectionFromFile(path string) (*AssetReportCollectionElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAssetReportCollectionFromBytes(data)
}

// ObjectRefElement represents the XSD element 'object-ref'
// XSD element declaration (W3C XSD ยง3.3)
type ObjectRefElement struct {
	XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 object-ref"`
	// RefId represents XSD attribute 'ref-id'
	// use="optional"
	RefId *string `xml:"ref-id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ObjectRefElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias ObjectRefElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ObjectRefElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias ObjectRefElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ObjectRefElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ObjectRefElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ObjectRefElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ObjectRefElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *ObjectRefElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadObjectRefFromBytes loads an element from bytes with namespace preservation
func LoadObjectRefFromBytes(data []byte) (*ObjectRefElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element ObjectRefElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadObjectRefFromFile loads an element from a file with namespace preservation
func LoadObjectRefFromFile(path string) (*ObjectRefElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadObjectRefFromBytes(data)
}

// RemoteResourceElement represents the XSD element 'remote-resource'
// XSD element declaration (W3C XSD ยง3.3)
type RemoteResourceElement struct {
	XMLName xml.Name `xml:"http://scap.nist.gov/schema/asset-reporting-format/1.1 remote-resource"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *RemoteResourceElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias RemoteResourceElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *RemoteResourceElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias RemoteResourceElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *RemoteResourceElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *RemoteResourceElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *RemoteResourceElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *RemoteResourceElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *RemoteResourceElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRemoteResourceFromBytes loads an element from bytes with namespace preservation
func LoadRemoteResourceFromBytes(data []byte) (*RemoteResourceElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element RemoteResourceElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRemoteResourceFromFile loads an element from a file with namespace preservation
func LoadRemoteResourceFromFile(path string) (*RemoteResourceElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRemoteResourceFromBytes(data)
}
