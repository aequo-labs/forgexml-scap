// Package asset_reporting_format1_1 - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package asset_reporting_format1_1

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestAssetElementType_MarshalUnmarshal tests XML round-trip for AssetElementType
func TestAssetElementType_MarshalUnmarshal(t *testing.T) {
	original := &AssetElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetReportCollectionElement_MarshalUnmarshal tests XML round-trip for AssetReportCollectionElement
func TestAssetReportCollectionElement_MarshalUnmarshal(t *testing.T) {
	original := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetReportCollectionElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetReportCollectionElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAssetReportCollectionElement_MarshalIndentClean(t *testing.T) {
	elem := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAssetReportCollectionElement_ToBytes tests the ToBytes method
func TestAssetReportCollectionElement_ToBytes(t *testing.T) {
	elem := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAssetReportCollectionElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAssetReportCollectionElement_SetElementPrefixes(t *testing.T) {
	elem := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAssetReportCollectionElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAssetReportCollectionElement_SetElementsWithXmlns(t *testing.T) {
	elem := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAssetReportCollectionElement_SaveAndLoad tests SaveToFile and LoadAssetReportCollectionFromFile
func TestAssetReportCollectionElement_SaveAndLoad(t *testing.T) {
	elem := &AssetReportCollectionElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "asset-report-collection"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAssetReportCollectionFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAssetReportCollectionElement_LoadFromBytes tests the LoadAssetReportCollectionFromBytes function
func TestAssetReportCollectionElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<asset-report-collection xmlns="http://scap.nist.gov/schema/asset-reporting-format/1.1"></asset-report-collection>`)

	loaded, err := LoadAssetReportCollectionFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAssetReportCollectionElementType_MarshalUnmarshal tests XML round-trip for AssetReportCollectionElementType
func TestAssetReportCollectionElementType_MarshalUnmarshal(t *testing.T) {
	original := &AssetReportCollectionElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetReportCollectionElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAssetsElementType_MarshalUnmarshal tests XML round-trip for AssetsElementType
func TestAssetsElementType_MarshalUnmarshal(t *testing.T) {
	original := &AssetsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AssetsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestContentElementType_MarshalUnmarshal tests XML round-trip for ContentElementType
func TestContentElementType_MarshalUnmarshal(t *testing.T) {
	original := &ContentElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ContentElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestContentElementType1_MarshalUnmarshal tests XML round-trip for ContentElementType1
func TestContentElementType1_MarshalUnmarshal(t *testing.T) {
	original := &ContentElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ContentElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtendedInfoElementType_MarshalUnmarshal tests XML round-trip for ExtendedInfoElementType
func TestExtendedInfoElementType_MarshalUnmarshal(t *testing.T) {
	original := &ExtendedInfoElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ExtendedInfoElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtendedInfosElementType_MarshalUnmarshal tests XML round-trip for ExtendedInfosElementType
func TestExtendedInfosElementType_MarshalUnmarshal(t *testing.T) {
	original := &ExtendedInfosElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ExtendedInfosElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestObjectRefElement_MarshalUnmarshal tests XML round-trip for ObjectRefElement
func TestObjectRefElement_MarshalUnmarshal(t *testing.T) {
	original := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ObjectRefElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestObjectRefElement_MarshalIndentClean tests the MarshalIndentClean method
func TestObjectRefElement_MarshalIndentClean(t *testing.T) {
	elem := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestObjectRefElement_ToBytes tests the ToBytes method
func TestObjectRefElement_ToBytes(t *testing.T) {
	elem := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestObjectRefElement_SetElementPrefixes tests the SetElementPrefixes method
func TestObjectRefElement_SetElementPrefixes(t *testing.T) {
	elem := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestObjectRefElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestObjectRefElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestObjectRefElement_SaveAndLoad tests SaveToFile and LoadObjectRefFromFile
func TestObjectRefElement_SaveAndLoad(t *testing.T) {
	elem := &ObjectRefElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "object-ref"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadObjectRefFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestObjectRefElement_LoadFromBytes tests the LoadObjectRefFromBytes function
func TestObjectRefElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<object-ref xmlns="http://scap.nist.gov/schema/asset-reporting-format/1.1"></object-ref>`)

	loaded, err := LoadObjectRefFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestObjectRefElementType_MarshalUnmarshal tests XML round-trip for ObjectRefElementType
func TestObjectRefElementType_MarshalUnmarshal(t *testing.T) {
	original := &ObjectRefElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ObjectRefElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRemoteResourceElement_MarshalUnmarshal tests XML round-trip for RemoteResourceElement
func TestRemoteResourceElement_MarshalUnmarshal(t *testing.T) {
	original := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RemoteResourceElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRemoteResourceElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRemoteResourceElement_MarshalIndentClean(t *testing.T) {
	elem := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRemoteResourceElement_ToBytes tests the ToBytes method
func TestRemoteResourceElement_ToBytes(t *testing.T) {
	elem := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRemoteResourceElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRemoteResourceElement_SetElementPrefixes(t *testing.T) {
	elem := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRemoteResourceElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRemoteResourceElement_SetElementsWithXmlns(t *testing.T) {
	elem := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRemoteResourceElement_SaveAndLoad tests SaveToFile and LoadRemoteResourceFromFile
func TestRemoteResourceElement_SaveAndLoad(t *testing.T) {
	elem := &RemoteResourceElement{
		XMLName: xml.Name{Space: "http://scap.nist.gov/schema/asset-reporting-format/1.1", Local: "remote-resource"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRemoteResourceFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRemoteResourceElement_LoadFromBytes tests the LoadRemoteResourceFromBytes function
func TestRemoteResourceElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<remote-resource xmlns="http://scap.nist.gov/schema/asset-reporting-format/1.1"></remote-resource>`)

	loaded, err := LoadRemoteResourceFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRemoteResourceElementType_MarshalUnmarshal tests XML round-trip for RemoteResourceElementType
func TestRemoteResourceElementType_MarshalUnmarshal(t *testing.T) {
	original := &RemoteResourceElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RemoteResourceElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReportRequestType_MarshalUnmarshal tests XML round-trip for ReportRequestType
func TestReportRequestType_MarshalUnmarshal(t *testing.T) {
	original := &ReportRequestType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReportRequestType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReportRequestsElementType_MarshalUnmarshal tests XML round-trip for ReportRequestsElementType
func TestReportRequestsElementType_MarshalUnmarshal(t *testing.T) {
	original := &ReportRequestsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReportRequestsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReportType_MarshalUnmarshal tests XML round-trip for ReportType
func TestReportType_MarshalUnmarshal(t *testing.T) {
	original := &ReportType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReportType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReportsElementType_MarshalUnmarshal tests XML round-trip for ReportsElementType
func TestReportsElementType_MarshalUnmarshal(t *testing.T) {
	original := &ReportsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReportsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child/></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
}
