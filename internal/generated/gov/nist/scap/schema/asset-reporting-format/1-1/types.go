// Package asset_reporting_format1_1 generated from XSD schema
// Source namespace: http://scap.nist.gov/schema/asset-reporting-format/1.1
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/arf/asset-reporting-format_1.1.0.xsd
// Generated by forgexml - Do not edit manually

package asset_reporting_format1_1

import (
	"encoding/xml"
	"regexp"
	"strings"

	asset_identification1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/asset-identification/1-1"
	reporting_core1_1 "github.com/aequo-labs/forgexml-scap/internal/generated/gov/nist/scap/schema/reporting-core/1-1"
	types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
	XMLName xml.Name   `xml:""`
	Content string     `xml:",innerxml"`
	Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -> xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string {
	elementsWithXmlns := make(map[string]string)
	xmlStr := string(xmlData)

	// Pattern to find elements with xmlns: <element_name ...xmlns="uri"...
	// Captures both prefixed and unprefixed element names
	pattern := regexp.MustCompile(`<(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^>]*?xmlns="([^"]+)"`)
	matches := pattern.FindAllStringSubmatch(xmlStr, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			// match[1] = prefix (may be empty)
			// match[2] = element name
			// match[3] = xmlns URI
			elementName := match[2]
			xmlnsURI := match[3]
			elementsWithXmlns[elementName] = xmlnsURI
		}
	}

	return elementsWithXmlns
}

// ExtractElementPrefixes parses raw XML to build element name -> prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string {
	elementPrefixes := make(map[string]string)

	// Use regex to find all opening tags with prefixes: <prefix:element
	pattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s>]`)
	matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

	for _, match := range matches {
		if len(match) >= 3 {
			prefix := match[1]
			elementName := match[2]
			elementPrefixes[elementName] = prefix
		}
	}

	return elementPrefixes
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string {
	// For each element name -> prefix mapping
	for elementName, prefix := range elementPrefixes {
		// Replace opening tags: <elementName with <prefix:elementName
		// and remove default xmlns="..." since the prefix declares the namespace
		pattern := regexp.MustCompile(`<` + elementName + `(\s[^>]*)?>`)
		xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
			// Add prefix to element name
			result := "<" + prefix + ":" + elementName
			// Extract attributes (everything between element name and >)
			if len(match) > len("<"+elementName+">") {
				attrs := match[len("<"+elementName) : len(match)-1]
				// Remove default xmlns="..." attribute
				xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, "")
				result += attrs
			}
			result += ">"
			return result
		})

		// Replace closing tags: </elementName> with </prefix:elementName>
		xmlOutput = strings.ReplaceAll(xmlOutput, "</"+elementName+">", "</"+prefix+":"+elementName+">")
	}

	return xmlOutput
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string {
	if len(elementsWithXmlns) == 0 {
		// No xmlns tracking - remove all nested xmlns to avoid inflation
		// Keep only root element xmlns
		firstGT := strings.Index(xmlOutput, ">")
		if firstGT == -1 {
			return xmlOutput
		}
		rootTag := xmlOutput[:firstGT+1]
		rest := xmlOutput[firstGT+1:]
		// Remove all xmlns from nested elements
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		rest = xmlnsPattern.ReplaceAllString(rest, "")
		return rootTag + rest
	}

	// Strategy: Find all opening tags and remove xmlns if element type not in map
	// Pattern matches: <element_name attr="val" xmlns="uri" ...>
	tagPattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+)(\s[^>]*?)>`)
	result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
		// Extract element name
		tagMatch := tagPattern.FindStringSubmatch(match)
		if len(tagMatch) < 2 {
			return match
		}
		elementName := tagMatch[1]
		attrs := ""
		if len(tagMatch) >= 3 {
			attrs = tagMatch[2]
		}

		// CRITICAL FIX: Deduplicate xmlns attributes first
		// Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
		// This happens with nested structs having XMLName with different namespaces
		// Remove all duplicate xmlns declarations, keeping only the first one
		dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
		matches := dedupPattern.FindAllString(attrs, -1)
		if len(matches) > 1 {
			// Found duplicates - keep only first xmlns, remove rest
			firstXmlns := matches[0]
			attrs = dedupPattern.ReplaceAllString(attrs, "")
			attrs = " " + firstXmlns + attrs
		}

		// Check if this element type should have xmlns
		expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
		if shouldHaveXmlns {
			// This element should have xmlns - ensure it's present and correct
			if !strings.Contains(attrs, "xmlns=") {
				// Missing xmlns - add it
				return "<" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + ">"
			}
			// Has xmlns - verify it's correct
			if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) {
				// Wrong xmlns - replace it
				xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
			}
			return "<" + elementName + attrs + ">"
		}

		// This element should NOT have xmlns - remove any xmlns attributes
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		attrs = xmlnsPattern.ReplaceAllString(attrs, "")
		return "<" + elementName + attrs + ">"
	})

	return result
}

// ReportRequestType represents the XSD type 'ReportRequestType'
// XSD complex type (W3C XSD §3.4)
type ReportRequestType struct {
	// Content represents XSD element 'content'
	Content *ContentElementType `xml:"content,omitempty"`
	// RemoteResource represents XSD element 'remote-resource'
	RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
	// Id represents XSD attribute 'id'
	// use="required"
	Id string `xml:"id,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportType represents the XSD type 'ReportType'
// XSD complex type (W3C XSD §3.4)
type ReportType struct {
	// Content represents XSD element 'content'
	Content *ContentElementType1 `xml:"content,omitempty"`
	// RemoteResource represents XSD element 'remote-resource'
	RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
	// Id represents XSD attribute 'id'
	// use="required"
	Id string `xml:"id,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RemoteResourceElementType represents the XSD type 'RemoteResourceElementType'
// XSD complex type (W3C XSD §3.4)
type RemoteResourceElementType struct {
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetReportCollectionElementType represents the XSD type 'AssetReportCollectionElementType'
// XSD complex type (W3C XSD §3.4)
type AssetReportCollectionElementType struct {
	reporting_core1_1.RelationshipsContainerType // XSD extension base
	// ReportRequests represents XSD element 'report-requests'
	// minOccurs=0, maxOccurs=1
	ReportRequests *ReportRequestsElementType `xml:"report-requests,omitempty"`
	// Assets represents XSD element 'assets'
	// minOccurs=0, maxOccurs=1
	Assets *AssetsElementType `xml:"assets,omitempty"`
	// Reports represents XSD element 'reports'
	Reports ReportsElementType `xml:"reports"`
	// ExtendedInfos represents XSD element 'extended-infos'
	// minOccurs=0, maxOccurs=1
	ExtendedInfos *ExtendedInfosElementType `xml:"extended-infos,omitempty"`
	// Id represents XSD attribute 'id'
	// use="optional"
	Id *string `xml:"id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportRequestsElementType represents the XSD type 'ReportRequestsElementType'
// XSD complex type (W3C XSD §3.4)
type ReportRequestsElementType struct {
	// ReportRequest represents XSD element 'report-request'
	// minOccurs=1, maxOccurs=-1
	ReportRequest []ReportRequestType `xml:"report-request"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetsElementType represents the XSD type 'AssetsElementType'
// XSD complex type (W3C XSD §3.4)
type AssetsElementType struct {
	// Asset represents XSD element 'asset'
	// minOccurs=1, maxOccurs=-1
	Asset []AssetElementType `xml:"asset"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// AssetElementType represents the XSD type 'AssetElementType'
// XSD complex type (W3C XSD §3.4)
type AssetElementType struct {
	// X1_1Organization represents substitution group member 'organization' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
	// Substitutes for abstract element 'asset'
	X1_1Organization []asset_identification1_1.OrganizationType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 organization,omitempty"`
	// X1_1ItAsset represents substitution group member 'it-asset' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
	// Substitutes for abstract element 'asset'
	X1_1ItAsset []asset_identification1_1.ItAssetType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 it-asset,omitempty"`
	// X1_1Data represents substitution group member 'data' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
	// Substitutes for abstract element 'asset'
	X1_1Data []asset_identification1_1.DataType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 data,omitempty"`
	// X1_1Person represents substitution group member 'person' (namespace: http://scap.nist.gov/schema/asset-identification/1.1)
	// Substitutes for abstract element 'asset'
	X1_1Person []asset_identification1_1.PersonType `xml:"http://scap.nist.gov/schema/asset-identification/1.1 person,omitempty"`
	// RemoteResource represents XSD element 'remote-resource'
	RemoteResource *RemoteResourceElement `xml:"remote-resource,omitempty"`
	// Id represents XSD attribute 'id'
	// use="required"
	Id string `xml:"id,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReportsElementType represents the XSD type 'ReportsElementType'
// XSD complex type (W3C XSD §3.4)
type ReportsElementType struct {
	// Report represents XSD element 'report'
	// minOccurs=1, maxOccurs=-1
	Report []ReportType `xml:"report"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendedInfosElementType represents the XSD type 'ExtendedInfosElementType'
// XSD complex type (W3C XSD §3.4)
type ExtendedInfosElementType struct {
	// ExtendedInfo represents XSD element 'extended-info'
	// minOccurs=1, maxOccurs=-1
	ExtendedInfo []ExtendedInfoElementType `xml:"extended-info"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendedInfoElementType represents the XSD type 'ExtendedInfoElementType'
// XSD complex type (W3C XSD §3.4)
type ExtendedInfoElementType struct {
	// Id represents XSD attribute 'id'
	// use="required"
	Id string `xml:"id,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectRefElementType represents the XSD type 'ObjectRefElementType'
// XSD complex type (W3C XSD §3.4)
type ObjectRefElementType struct {
	// RefId represents XSD attribute 'ref-id'
	// use="optional"
	RefId *string `xml:"ref-id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ContentElementType represents the XSD type 'ContentElementType'
// XSD complex type (W3C XSD §3.4)
type ContentElementType struct {
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ContentElementType1 represents the XSD type 'ContentElementType1'
// XSD complex type (W3C XSD §3.4)
type ContentElementType1 struct {
	// DataValidStartDate represents XSD attribute 'data-valid-start-date'
	// use="optional"
	DataValidStartDate *types.DateTime `xml:"data-valid-start-date,attr,omitempty"`
	// DataValidEndDate represents XSD attribute 'data-valid-end-date'
	// use="optional"
	DataValidEndDate *types.DateTime `xml:"data-valid-end-date,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
