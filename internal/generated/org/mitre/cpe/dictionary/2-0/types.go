// Package dictionary2_0 generated from XSD schema
// Source namespace: http://cpe.mitre.org/dictionary/2.0
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/cpe-dictionary/cpe-dictionary_2.1.xsd
// Generated by forgexml - Do not edit manually

package dictionary2_0

import (
	"encoding/xml"
	"regexp"
	"strings"

	types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
	XMLName xml.Name   `xml:""`
	Content string     `xml:",innerxml"`
	Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -> xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string {
	elementsWithXmlns := make(map[string]string)
	xmlStr := string(xmlData)

	// Pattern to find elements with xmlns: <element_name ...xmlns="uri"...
	// Captures both prefixed and unprefixed element names
	pattern := regexp.MustCompile(`<(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^>]*?xmlns="([^"]+)"`)
	matches := pattern.FindAllStringSubmatch(xmlStr, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			// match[1] = prefix (may be empty)
			// match[2] = element name
			// match[3] = xmlns URI
			elementName := match[2]
			xmlnsURI := match[3]
			elementsWithXmlns[elementName] = xmlnsURI
		}
	}

	return elementsWithXmlns
}

// ExtractElementPrefixes parses raw XML to build element name -> prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string {
	elementPrefixes := make(map[string]string)

	// Use regex to find all opening tags with prefixes: <prefix:element
	pattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s>]`)
	matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

	for _, match := range matches {
		if len(match) >= 3 {
			prefix := match[1]
			elementName := match[2]
			elementPrefixes[elementName] = prefix
		}
	}

	return elementPrefixes
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string {
	// For each element name -> prefix mapping
	for elementName, prefix := range elementPrefixes {
		// Replace opening tags: <elementName with <prefix:elementName
		// and remove default xmlns="..." since the prefix declares the namespace
		pattern := regexp.MustCompile(`<` + elementName + `(\s[^>]*)?>`)
		xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
			// Add prefix to element name
			result := "<" + prefix + ":" + elementName
			// Extract attributes (everything between element name and >)
			if len(match) > len("<"+elementName+">") {
				attrs := match[len("<"+elementName) : len(match)-1]
				// Remove default xmlns="..." attribute
				xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, "")
				result += attrs
			}
			result += ">"
			return result
		})

		// Replace closing tags: </elementName> with </prefix:elementName>
		xmlOutput = strings.ReplaceAll(xmlOutput, "</"+elementName+">", "</"+prefix+":"+elementName+">")
	}

	return xmlOutput
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string {
	if len(elementsWithXmlns) == 0 {
		// No xmlns tracking - remove all nested xmlns to avoid inflation
		// Keep only root element xmlns
		firstGT := strings.Index(xmlOutput, ">")
		if firstGT == -1 {
			return xmlOutput
		}
		rootTag := xmlOutput[:firstGT+1]
		rest := xmlOutput[firstGT+1:]
		// Remove all xmlns from nested elements
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		rest = xmlnsPattern.ReplaceAllString(rest, "")
		return rootTag + rest
	}

	// Strategy: Find all opening tags and remove xmlns if element type not in map
	// Pattern matches: <element_name attr="val" xmlns="uri" ...>
	tagPattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+)(\s[^>]*?)>`)
	result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
		// Extract element name
		tagMatch := tagPattern.FindStringSubmatch(match)
		if len(tagMatch) < 2 {
			return match
		}
		elementName := tagMatch[1]
		attrs := ""
		if len(tagMatch) >= 3 {
			attrs = tagMatch[2]
		}

		// CRITICAL FIX: Deduplicate xmlns attributes first
		// Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
		// This happens with nested structs having XMLName with different namespaces
		// Remove all duplicate xmlns declarations, keeping only the first one
		dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
		matches := dedupPattern.FindAllString(attrs, -1)
		if len(matches) > 1 {
			// Found duplicates - keep only first xmlns, remove rest
			firstXmlns := matches[0]
			attrs = dedupPattern.ReplaceAllString(attrs, "")
			attrs = " " + firstXmlns + attrs
		}

		// Check if this element type should have xmlns
		expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
		if shouldHaveXmlns {
			// This element should have xmlns - ensure it's present and correct
			if !strings.Contains(attrs, "xmlns=") {
				// Missing xmlns - add it
				return "<" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + ">"
			}
			// Has xmlns - verify it's correct
			if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) {
				// Wrong xmlns - replace it
				xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
			}
			return "<" + elementName + attrs + ">"
		}

		// This element should NOT have xmlns - remove any xmlns attributes
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		attrs = xmlnsPattern.ReplaceAllString(attrs, "")
		return "<" + elementName + attrs + ">"
	})

	return result
}

// NamePattern represents the XSD type 'namePattern'
// XSD simple type (W3C XSD §4.1)
// pattern="[c][pP][eE]:/[AHOaho]?(:[A-Za-z0-9\._\-~%]*){0,6}"
type NamePattern string

// GeneratorType represents the XSD type 'GeneratorType'
// XSD complex type (W3C XSD §3.4)
type GeneratorType struct {
	// Product_name represents XSD element 'product_name'
	// minOccurs=0, maxOccurs=1
	Product_name *string `xml:"product_name,omitempty"`
	// Product_version represents XSD element 'product_version'
	// minOccurs=0, maxOccurs=1
	Product_version *string `xml:"product_version,omitempty"`
	// Schema_version represents XSD element 'schema_version'
	Schema_version string `xml:"schema_version"`
	// Timestamp represents XSD element 'timestamp'
	Timestamp types.DateTime `xml:"timestamp"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ListType represents the XSD type 'ListType'
// XSD complex type (W3C XSD §3.4)
type ListType struct {
	// Generator represents XSD element 'generator'
	// minOccurs=0, maxOccurs=1
	Generator *GeneratorType `xml:"generator,omitempty"`
	// CpeItem represents XSD element 'cpe-item'
	// minOccurs=1, maxOccurs=-1
	CpeItem []ItemType `xml:"cpe-item"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType represents the XSD type 'TextType'
// XSD complex type (W3C XSD §3.4)
type TextTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TextType is an alias for TextTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TextType = TextTypeWithAttrs

// NotesType represents the XSD type 'NotesType'
// XSD complex type (W3C XSD §3.4)
type NotesType struct {
	// Note represents XSD element 'note'
	// minOccurs=1, maxOccurs=-1
	Note []string `xml:"note"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckType represents the XSD type 'CheckType'
// XSD complex type (W3C XSD §3.4)
type CheckTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// System represents XSD attribute 'system'
	// use="required"
	System string `xml:"system,attr"`
	// Href represents XSD attribute 'href'
	// use="optional"
	Href *string `xml:"href,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CheckType is an alias for CheckTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type CheckType = CheckTypeWithAttrs

// ItemType represents the XSD type 'ItemType'
// XSD complex type (W3C XSD §3.4)
type ItemType struct {
	// Title represents XSD element 'title'
	// minOccurs=1, maxOccurs=-1
	Title []TextTypeWithAttrs `xml:"title"`
	// Notes represents XSD element 'notes'
	// minOccurs=0, maxOccurs=-1
	Notes []NotesType `xml:"notes,omitempty"`
	// References represents XSD element 'references'
	// minOccurs=0, maxOccurs=1
	References *ReferencesType `xml:"references,omitempty"`
	// Check represents XSD element 'check'
	// minOccurs=0, maxOccurs=-1
	Check []CheckTypeWithAttrs `xml:"check,omitempty"`
	// Name represents XSD attribute 'name'
	// use="required"
	Name NamePattern `xml:"name,attr"`
	// Deprecated represents XSD attribute 'deprecated'
	// use="optional"
	Deprecated *bool `xml:"deprecated,attr,omitempty"`
	// Deprecated_by represents XSD attribute 'deprecated_by'
	// use="optional"
	Deprecated_by *NamePattern `xml:"deprecated_by,attr,omitempty"`
	// Deprecation_date represents XSD attribute 'deprecation_date'
	// use="optional"
	Deprecation_date *types.DateTime `xml:"deprecation_date,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferencesType represents the XSD type 'ReferencesType'
// XSD complex type (W3C XSD §3.4)
type ReferencesType struct {
	// Reference represents XSD element 'reference'
	// minOccurs=1, maxOccurs=-1
	Reference []ReferenceElementType `xml:"reference"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceElementType represents the XSD type 'ReferenceElementType'
// XSD complex type (W3C XSD §3.4)
type ReferenceElementTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// Href represents XSD attribute 'href'
	// use="optional"
	Href *string `xml:"href,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceElementType is an alias for ReferenceElementTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ReferenceElementType = ReferenceElementTypeWithAttrs
