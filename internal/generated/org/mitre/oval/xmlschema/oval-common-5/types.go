// Package xmlschemaoval_common_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-common-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-common-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_common_5

import (
	"encoding/xml"
	"regexp"
	"strings"

	types "github.com/aequo-labs/forgexml-scap/internal/generated/types"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
	XMLName xml.Name   `xml:""`
	Content string     `xml:",innerxml"`
	Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -> xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string {
	elementsWithXmlns := make(map[string]string)
	xmlStr := string(xmlData)

	// Pattern to find elements with xmlns: <element_name ...xmlns="uri"...
	// Captures both prefixed and unprefixed element names
	pattern := regexp.MustCompile(`<(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^>]*?xmlns="([^"]+)"`)
	matches := pattern.FindAllStringSubmatch(xmlStr, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			// match[1] = prefix (may be empty)
			// match[2] = element name
			// match[3] = xmlns URI
			elementName := match[2]
			xmlnsURI := match[3]
			elementsWithXmlns[elementName] = xmlnsURI
		}
	}

	return elementsWithXmlns
}

// ExtractElementPrefixes parses raw XML to build element name -> prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string {
	elementPrefixes := make(map[string]string)

	// Use regex to find all opening tags with prefixes: <prefix:element
	pattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s>]`)
	matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

	for _, match := range matches {
		if len(match) >= 3 {
			prefix := match[1]
			elementName := match[2]
			elementPrefixes[elementName] = prefix
		}
	}

	return elementPrefixes
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string {
	// For each element name -> prefix mapping
	for elementName, prefix := range elementPrefixes {
		// Replace opening tags: <elementName with <prefix:elementName
		// and remove default xmlns="..." since the prefix declares the namespace
		pattern := regexp.MustCompile(`<` + elementName + `(\s[^>]*)?>`)
		xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
			// Add prefix to element name
			result := "<" + prefix + ":" + elementName
			// Extract attributes (everything between element name and >)
			if len(match) > len("<"+elementName+">") {
				attrs := match[len("<"+elementName) : len(match)-1]
				// Remove default xmlns="..." attribute
				xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, "")
				result += attrs
			}
			result += ">"
			return result
		})

		// Replace closing tags: </elementName> with </prefix:elementName>
		xmlOutput = strings.ReplaceAll(xmlOutput, "</"+elementName+">", "</"+prefix+":"+elementName+">")
	}

	return xmlOutput
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string {
	if len(elementsWithXmlns) == 0 {
		// No xmlns tracking - remove all nested xmlns to avoid inflation
		// Keep only root element xmlns
		firstGT := strings.Index(xmlOutput, ">")
		if firstGT == -1 {
			return xmlOutput
		}
		rootTag := xmlOutput[:firstGT+1]
		rest := xmlOutput[firstGT+1:]
		// Remove all xmlns from nested elements
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		rest = xmlnsPattern.ReplaceAllString(rest, "")
		return rootTag + rest
	}

	// Strategy: Find all opening tags and remove xmlns if element type not in map
	// Pattern matches: <element_name attr="val" xmlns="uri" ...>
	tagPattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+)(\s[^>]*?)>`)
	result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
		// Extract element name
		tagMatch := tagPattern.FindStringSubmatch(match)
		if len(tagMatch) < 2 {
			return match
		}
		elementName := tagMatch[1]
		attrs := ""
		if len(tagMatch) >= 3 {
			attrs = tagMatch[2]
		}

		// CRITICAL FIX: Deduplicate xmlns attributes first
		// Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
		// This happens with nested structs having XMLName with different namespaces
		// Remove all duplicate xmlns declarations, keeping only the first one
		dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
		matches := dedupPattern.FindAllString(attrs, -1)
		if len(matches) > 1 {
			// Found duplicates - keep only first xmlns, remove rest
			firstXmlns := matches[0]
			attrs = dedupPattern.ReplaceAllString(attrs, "")
			attrs = " " + firstXmlns + attrs
		}

		// Check if this element type should have xmlns
		expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
		if shouldHaveXmlns {
			// This element should have xmlns - ensure it's present and correct
			if !strings.Contains(attrs, "xmlns=") {
				// Missing xmlns - add it
				return "<" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + ">"
			}
			// Has xmlns - verify it's correct
			if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) {
				// Wrong xmlns - replace it
				xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
			}
			return "<" + elementName + attrs + ">"
		}

		// This element should NOT have xmlns - remove any xmlns attributes
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		attrs = xmlnsPattern.ReplaceAllString(attrs, "")
		return "<" + elementName + attrs + ">"
	})

	return result
}

// SimpleDatatypeEnumeration represents the XSD type 'SimpleDatatypeEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="binary"
// enumeration="boolean"
// enumeration="evr_string"
// enumeration="debian_evr_string"
// enumeration="fileset_revision"
// enumeration="float"
// enumeration="ios_version"
// enumeration="int"
// enumeration="ipv4_address"
// enumeration="ipv6_address"
// enumeration="string"
// enumeration="version"
type SimpleDatatypeEnumeration string

// DatatypeEnumeration represents the XSD type 'DatatypeEnumeration'
// XSD union type (W3C XSD §4.2.3.3)
type DatatypeEnumeration struct {
	Value interface{} // Union type - can hold any member type
}

// OperationEnumeration represents the XSD type 'OperationEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="equals"
// enumeration="not equal"
// enumeration="case insensitive equals"
// enumeration="case insensitive not equal"
// enumeration="greater than"
// enumeration="less than"
// enumeration="greater than or equal"
// enumeration="less than or equal"
// enumeration="bitwise and"
// enumeration="bitwise or"
// enumeration="pattern match"
// enumeration="subset of"
// enumeration="superset of"
type OperationEnumeration string

// OperatorEnumeration represents the XSD type 'OperatorEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="AND"
// enumeration="ONE"
// enumeration="OR"
// enumeration="XOR"
type OperatorEnumeration string

// ExistenceEnumeration represents the XSD type 'ExistenceEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="all_exist"
// enumeration="any_exist"
// enumeration="at_least_one_exists"
// enumeration="none_exist"
// enumeration="only_one_exists"
type ExistenceEnumeration string

// StateIDPattern represents the XSD type 'StateIDPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:ste:[1-9][0-9]*"
type StateIDPattern string

// DefinitionIDPattern represents the XSD type 'DefinitionIDPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:def:[1-9][0-9]*"
type DefinitionIDPattern string

// VariableIDPattern represents the XSD type 'VariableIDPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:var:[1-9][0-9]*"
type VariableIDPattern string

// SchemaVersionPattern represents the XSD type 'SchemaVersionPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="[0-9]+\.[0-9]+(\.[0-9]+)?(:[0-9]+\.[0-9]+(\.[0-9]+)?)?"
type SchemaVersionPattern string

// NonEmptyStringType represents the XSD type 'NonEmptyStringType'
// XSD simple type (W3C XSD §4.1)
// minLength="1"
type NonEmptyStringType string

// ElementMapType represents the XSD type 'ElementMapType'
// XSD complex type (W3C XSD §3.4)
type ElementMapType struct {
	// Test represents XSD element 'test'
	Test ElementMapItemTypeWithAttrs `xml:"test"`
	// Object represents XSD element 'object'
	// minOccurs=0, maxOccurs=1
	Object *ElementMapItemTypeWithAttrs `xml:"object,omitempty"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=1
	State *ElementMapItemTypeWithAttrs `xml:"state,omitempty"`
	// Item represents XSD element 'item'
	// minOccurs=0, maxOccurs=1
	Item *ElementMapItemTypeWithAttrs `xml:"item,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ElementMapItemType represents the XSD type 'ElementMapItemType'
// XSD complex type (W3C XSD §3.4)
type ElementMapItemTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// Target_namespace represents XSD attribute 'target_namespace'
	// use="optional"
	Target_namespace *string `xml:"target_namespace,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ElementMapItemType is an alias for ElementMapItemTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type ElementMapItemType = ElementMapItemTypeWithAttrs

// ComplexDatatypeEnumeration represents the XSD type 'ComplexDatatypeEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="record"
type ComplexDatatypeEnumeration string

// EmptyStringType represents the XSD type 'EmptyStringType'
// XSD simple type (W3C XSD §4.1)
// maxLength="0"
type EmptyStringType string

// DeprecatedInfoType represents the XSD type 'DeprecatedInfoType'
// XSD complex type (W3C XSD §3.4)
type DeprecatedInfoType struct {
	// Version represents XSD element 'version'
	Version VersionElementType `xml:"version"`
	// Reason represents XSD element 'reason'
	Reason string `xml:"reason"`
	// Comment represents XSD element 'comment'
	// minOccurs=0, maxOccurs=1
	Comment *string `xml:"comment,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// GeneratorType represents the XSD type 'GeneratorType'
// XSD complex type (W3C XSD §3.4)
type GeneratorType struct {
	// Product_name represents XSD element 'product_name'
	// minOccurs=0, maxOccurs=1
	Product_name *string `xml:"product_name,omitempty"`
	// Product_version represents XSD element 'product_version'
	// minOccurs=0, maxOccurs=1
	Product_version *string `xml:"product_version,omitempty"`
	// Schema_version represents XSD element 'schema_version'
	// minOccurs=1, maxOccurs=-1
	Schema_version []SchemaVersionType `xml:"schema_version"`
	// Timestamp represents XSD element 'timestamp'
	Timestamp types.DateTime `xml:"timestamp"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MessageType represents the XSD type 'MessageType'
// XSD complex type (W3C XSD §3.4)
type MessageTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// Level represents XSD attribute 'level'
	// use="optional"
	Level *MessageLevelEnumeration `xml:"level,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// MessageType is an alias for MessageTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type MessageType = MessageTypeWithAttrs

// FamilyEnumeration represents the XSD type 'FamilyEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="android"
// enumeration="asa"
// enumeration="apple_ios"
// enumeration="catos"
// enumeration="ios"
// enumeration="iosxe"
// enumeration="junos"
// enumeration="macos"
// enumeration="pixos"
// enumeration="undefined"
// enumeration="unix"
// enumeration="vmware_infrastructure"
// enumeration="windows"
type FamilyEnumeration string

// MessageLevelEnumeration represents the XSD type 'MessageLevelEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="debug"
// enumeration="error"
// enumeration="fatal"
// enumeration="info"
// enumeration="warning"
type MessageLevelEnumeration string

// ItemIDPattern represents the XSD type 'ItemIDPattern'
// XSD simple type (W3C XSD §4.1)
type ItemIDPattern int64

// SchemaVersionType represents the XSD type 'SchemaVersionType'
// XSD complex type (W3C XSD §3.4)
type SchemaVersionTypeWithAttrs struct {
	Value SchemaVersionPattern `xml:",chardata"` // XSD simple content
	// Platform represents XSD attribute 'platform'
	// use="optional"
	Platform *string `xml:"platform,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SchemaVersionType is an alias for SchemaVersionTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SchemaVersionType = SchemaVersionTypeWithAttrs

// NotesType represents the XSD type 'NotesType'
// XSD complex type (W3C XSD §3.4)
type NotesType struct {
	// Note represents XSD element 'note'
	// minOccurs=0, maxOccurs=-1
	Note []string `xml:"note,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// VersionElementType represents the XSD type 'VersionElementType'
// XSD simple type (W3C XSD §4.1)
type VersionElementType SchemaVersionPattern

// ObjectIDPattern represents the XSD type 'ObjectIDPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:obj:[1-9][0-9]*"
type ObjectIDPattern string

// TestIDPattern represents the XSD type 'TestIDPattern'
// XSD simple type (W3C XSD §4.1)
// pattern="oval:[A-Za-z0-9_\-\.]+:tst:[1-9][0-9]*"
type TestIDPattern string

// CheckEnumeration represents the XSD type 'CheckEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="all"
// enumeration="at least one"
// enumeration="none exist"
// enumeration="none satisfy"
// enumeration="only one"
type CheckEnumeration string

// ClassEnumeration represents the XSD type 'ClassEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="compliance"
// enumeration="inventory"
// enumeration="miscellaneous"
// enumeration="patch"
// enumeration="vulnerability"
type ClassEnumeration string
