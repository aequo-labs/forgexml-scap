// Package xmlschemaoval_definitions_5_apache generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5#apache
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/apache-definitions-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_apache

import (
	"encoding/xml"
	"os"
	"strings"

	xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	xmlschemaoval_results_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-results-5"
	xmlschemaoval_system_characteristics_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-system-characteristics-5"
)

// Httpd_testElement represents the XSD element 'httpd_test'
// XSD element declaration (W3C XSD ยง3.3)
type Httpd_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#apache httpd_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Httpd_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Httpd_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Httpd_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Httpd_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Httpd_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Httpd_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Httpd_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Httpd_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Httpd_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadHttpd_testFromBytes loads an element from bytes with namespace preservation
func LoadHttpd_testFromBytes(data []byte) (*Httpd_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Httpd_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadHttpd_testFromFile loads an element from a file with namespace preservation
func LoadHttpd_testFromFile(path string) (*Httpd_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadHttpd_testFromBytes(data)
}

// Httpd_objectElement represents the XSD element 'httpd_object'
// XSD element declaration (W3C XSD ยง3.3)
type Httpd_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#apache httpd_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Httpd_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Httpd_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Httpd_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Httpd_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Httpd_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Httpd_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Httpd_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Httpd_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Httpd_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadHttpd_objectFromBytes loads an element from bytes with namespace preservation
func LoadHttpd_objectFromBytes(data []byte) (*Httpd_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Httpd_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadHttpd_objectFromFile loads an element from a file with namespace preservation
func LoadHttpd_objectFromFile(path string) (*Httpd_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadHttpd_objectFromBytes(data)
}

// Httpd_stateElement represents the XSD element 'httpd_state'
// XSD element declaration (W3C XSD ยง3.3)
type Httpd_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#apache httpd_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Binary_name represents XSD element 'binary_name'
	// minOccurs=0, maxOccurs=1
	Binary_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"binary_name,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *xmlschemaoval_definitions_5.EntityStateVersionType `xml:"version,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Httpd_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Httpd_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Httpd_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Httpd_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Httpd_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Httpd_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Httpd_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Httpd_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Httpd_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadHttpd_stateFromBytes loads an element from bytes with namespace preservation
func LoadHttpd_stateFromBytes(data []byte) (*Httpd_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Httpd_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadHttpd_stateFromFile loads an element from a file with namespace preservation
func LoadHttpd_stateFromFile(path string) (*Httpd_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadHttpd_stateFromBytes(data)
}
