// Package xmlschemaoval_definitions_5_asa - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_asa

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestAcl_objectElement_MarshalUnmarshal tests XML round-trip for Acl_objectElement
func TestAcl_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAcl_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAcl_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAcl_objectElement_ToBytes tests the ToBytes method
func TestAcl_objectElement_ToBytes(t *testing.T) {
	elem := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAcl_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAcl_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAcl_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAcl_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAcl_objectElement_SaveAndLoad tests SaveToFile and LoadAcl_objectFromFile
func TestAcl_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Acl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAcl_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAcl_objectElement_LoadFromBytes tests the LoadAcl_objectFromBytes function
func TestAcl_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<acl_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></acl_object>`)

	loaded, err := LoadAcl_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAcl_objectElementType_MarshalUnmarshal tests XML round-trip for Acl_objectElementType
func TestAcl_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Acl_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAcl_stateElement_MarshalUnmarshal tests XML round-trip for Acl_stateElement
func TestAcl_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAcl_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAcl_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAcl_stateElement_ToBytes tests the ToBytes method
func TestAcl_stateElement_ToBytes(t *testing.T) {
	elem := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAcl_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAcl_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAcl_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAcl_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAcl_stateElement_SaveAndLoad tests SaveToFile and LoadAcl_stateFromFile
func TestAcl_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Acl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAcl_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAcl_stateElement_LoadFromBytes tests the LoadAcl_stateFromBytes function
func TestAcl_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<acl_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></acl_state>`)

	loaded, err := LoadAcl_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAcl_stateElementType_MarshalUnmarshal tests XML round-trip for Acl_stateElementType
func TestAcl_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Acl_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAcl_testElement_MarshalUnmarshal tests XML round-trip for Acl_testElement
func TestAcl_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAcl_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAcl_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAcl_testElement_ToBytes tests the ToBytes method
func TestAcl_testElement_ToBytes(t *testing.T) {
	elem := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAcl_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAcl_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAcl_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAcl_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAcl_testElement_SaveAndLoad tests SaveToFile and LoadAcl_testFromFile
func TestAcl_testElement_SaveAndLoad(t *testing.T) {
	elem := &Acl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "acl_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAcl_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAcl_testElement_LoadFromBytes tests the LoadAcl_testFromBytes function
func TestAcl_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<acl_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></acl_test>`)

	loaded, err := LoadAcl_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAcl_testElementType_MarshalUnmarshal tests XML round-trip for Acl_testElementType
func TestAcl_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Acl_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Acl_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_objectElement_MarshalUnmarshal tests XML round-trip for Class_map_objectElement
func TestClass_map_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestClass_map_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestClass_map_objectElement_ToBytes tests the ToBytes method
func TestClass_map_objectElement_ToBytes(t *testing.T) {
	elem := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestClass_map_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestClass_map_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestClass_map_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestClass_map_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestClass_map_objectElement_SaveAndLoad tests SaveToFile and LoadClass_map_objectFromFile
func TestClass_map_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Class_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadClass_map_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestClass_map_objectElement_LoadFromBytes tests the LoadClass_map_objectFromBytes function
func TestClass_map_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<class_map_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></class_map_object>`)

	loaded, err := LoadClass_map_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestClass_map_objectElementType_MarshalUnmarshal tests XML round-trip for Class_map_objectElementType
func TestClass_map_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_stateElement_MarshalUnmarshal tests XML round-trip for Class_map_stateElement
func TestClass_map_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestClass_map_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestClass_map_stateElement_ToBytes tests the ToBytes method
func TestClass_map_stateElement_ToBytes(t *testing.T) {
	elem := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestClass_map_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestClass_map_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestClass_map_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestClass_map_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestClass_map_stateElement_SaveAndLoad tests SaveToFile and LoadClass_map_stateFromFile
func TestClass_map_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Class_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadClass_map_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestClass_map_stateElement_LoadFromBytes tests the LoadClass_map_stateFromBytes function
func TestClass_map_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<class_map_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></class_map_state>`)

	loaded, err := LoadClass_map_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestClass_map_stateElementType_MarshalUnmarshal tests XML round-trip for Class_map_stateElementType
func TestClass_map_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_testElement_MarshalUnmarshal tests XML round-trip for Class_map_testElement
func TestClass_map_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestClass_map_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestClass_map_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestClass_map_testElement_ToBytes tests the ToBytes method
func TestClass_map_testElement_ToBytes(t *testing.T) {
	elem := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestClass_map_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestClass_map_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestClass_map_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestClass_map_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestClass_map_testElement_SaveAndLoad tests SaveToFile and LoadClass_map_testFromFile
func TestClass_map_testElement_SaveAndLoad(t *testing.T) {
	elem := &Class_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "class_map_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadClass_map_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestClass_map_testElement_LoadFromBytes tests the LoadClass_map_testFromBytes function
func TestClass_map_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<class_map_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></class_map_test>`)

	loaded, err := LoadClass_map_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestClass_map_testElementType_MarshalUnmarshal tests XML round-trip for Class_map_testElementType
func TestClass_map_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Class_map_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Class_map_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectAccessListIPVersionType_MarshalUnmarshal tests XML round-trip for EntityObjectAccessListIPVersionType
func TestEntityObjectAccessListIPVersionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectAccessListIPVersionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectAccessListIPVersionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAccessListIPVersionType_MarshalUnmarshal tests XML round-trip for EntityStateAccessListIPVersionType
func TestEntityStateAccessListIPVersionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAccessListIPVersionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAccessListIPVersionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAccessListInterfaceDirectionType_MarshalUnmarshal tests XML round-trip for EntityStateAccessListInterfaceDirectionType
func TestEntityStateAccessListInterfaceDirectionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAccessListInterfaceDirectionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAccessListInterfaceDirectionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAccessListUseType_MarshalUnmarshal tests XML round-trip for EntityStateAccessListUseType
func TestEntityStateAccessListUseType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAccessListUseType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAccessListUseType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateApplyServicePolicyType_MarshalUnmarshal tests XML round-trip for EntityStateApplyServicePolicyType
func TestEntityStateApplyServicePolicyType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateApplyServicePolicyType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateApplyServicePolicyType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateClassMapType_MarshalUnmarshal tests XML round-trip for EntityStateClassMapType
func TestEntityStateClassMapType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateClassMapType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateClassMapType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateInspectionType_MarshalUnmarshal tests XML round-trip for EntityStateInspectionType
func TestEntityStateInspectionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateInspectionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateInspectionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateMatchType_MarshalUnmarshal tests XML round-trip for EntityStateMatchType
func TestEntityStateMatchType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateMatchType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateMatchType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSNMPAuthStringType_MarshalUnmarshal tests XML round-trip for EntityStateSNMPAuthStringType
func TestEntityStateSNMPAuthStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSNMPAuthStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSNMPAuthStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSNMPPrivStringType_MarshalUnmarshal tests XML round-trip for EntityStateSNMPPrivStringType
func TestEntityStateSNMPPrivStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSNMPPrivStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSNMPPrivStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSNMPSecLevelStringType_MarshalUnmarshal tests XML round-trip for EntityStateSNMPSecLevelStringType
func TestEntityStateSNMPSecLevelStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSNMPSecLevelStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSNMPSecLevelStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSNMPVersionStringType_MarshalUnmarshal tests XML round-trip for EntityStateSNMPVersionStringType
func TestEntityStateSNMPVersionStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSNMPVersionStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSNMPVersionStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalUnmarshal tests XML round-trip for Interface_objectElement
func TestInterface_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_objectElement_ToBytes tests the ToBytes method
func TestInterface_objectElement_ToBytes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SaveAndLoad tests SaveToFile and LoadInterface_objectFromFile
func TestInterface_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_objectElement_LoadFromBytes tests the LoadInterface_objectFromBytes function
func TestInterface_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></interface_object>`)

	loaded, err := LoadInterface_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_objectElementType_MarshalUnmarshal tests XML round-trip for Interface_objectElementType
func TestInterface_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalUnmarshal tests XML round-trip for Interface_stateElement
func TestInterface_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_stateElement_ToBytes tests the ToBytes method
func TestInterface_stateElement_ToBytes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SaveAndLoad tests SaveToFile and LoadInterface_stateFromFile
func TestInterface_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_stateElement_LoadFromBytes tests the LoadInterface_stateFromBytes function
func TestInterface_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></interface_state>`)

	loaded, err := LoadInterface_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_stateElementType_MarshalUnmarshal tests XML round-trip for Interface_stateElementType
func TestInterface_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalUnmarshal tests XML round-trip for Interface_testElement
func TestInterface_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_testElement_ToBytes tests the ToBytes method
func TestInterface_testElement_ToBytes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SaveAndLoad tests SaveToFile and LoadInterface_testFromFile
func TestInterface_testElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "interface_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_testElement_LoadFromBytes tests the LoadInterface_testFromBytes function
func TestInterface_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></interface_test>`)

	loaded, err := LoadInterface_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_testElementType_MarshalUnmarshal tests XML round-trip for Interface_testElementType
func TestInterface_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_objectElement_MarshalUnmarshal tests XML round-trip for Line_objectElement
func TestLine_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLine_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLine_objectElement_ToBytes tests the ToBytes method
func TestLine_objectElement_ToBytes(t *testing.T) {
	elem := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLine_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLine_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLine_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLine_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLine_objectElement_SaveAndLoad tests SaveToFile and LoadLine_objectFromFile
func TestLine_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Line_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLine_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLine_objectElement_LoadFromBytes tests the LoadLine_objectFromBytes function
func TestLine_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<line_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></line_object>`)

	loaded, err := LoadLine_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLine_objectElementType_MarshalUnmarshal tests XML round-trip for Line_objectElementType
func TestLine_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Line_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_stateElement_MarshalUnmarshal tests XML round-trip for Line_stateElement
func TestLine_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLine_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLine_stateElement_ToBytes tests the ToBytes method
func TestLine_stateElement_ToBytes(t *testing.T) {
	elem := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLine_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLine_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLine_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLine_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLine_stateElement_SaveAndLoad tests SaveToFile and LoadLine_stateFromFile
func TestLine_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Line_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLine_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLine_stateElement_LoadFromBytes tests the LoadLine_stateFromBytes function
func TestLine_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<line_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></line_state>`)

	loaded, err := LoadLine_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLine_stateElementType_MarshalUnmarshal tests XML round-trip for Line_stateElementType
func TestLine_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Line_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_testElement_MarshalUnmarshal tests XML round-trip for Line_testElement
func TestLine_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLine_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLine_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLine_testElement_ToBytes tests the ToBytes method
func TestLine_testElement_ToBytes(t *testing.T) {
	elem := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLine_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLine_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLine_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLine_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLine_testElement_SaveAndLoad tests SaveToFile and LoadLine_testFromFile
func TestLine_testElement_SaveAndLoad(t *testing.T) {
	elem := &Line_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "line_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLine_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLine_testElement_LoadFromBytes tests the LoadLine_testFromBytes function
func TestLine_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<line_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></line_test>`)

	loaded, err := LoadLine_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLine_testElementType_MarshalUnmarshal tests XML round-trip for Line_testElementType
func TestLine_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Line_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Line_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_objectElement_MarshalUnmarshal tests XML round-trip for Policy_map_objectElement
func TestPolicy_map_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPolicy_map_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPolicy_map_objectElement_ToBytes tests the ToBytes method
func TestPolicy_map_objectElement_ToBytes(t *testing.T) {
	elem := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPolicy_map_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPolicy_map_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPolicy_map_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPolicy_map_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPolicy_map_objectElement_SaveAndLoad tests SaveToFile and LoadPolicy_map_objectFromFile
func TestPolicy_map_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Policy_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPolicy_map_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPolicy_map_objectElement_LoadFromBytes tests the LoadPolicy_map_objectFromBytes function
func TestPolicy_map_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<policy_map_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></policy_map_object>`)

	loaded, err := LoadPolicy_map_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPolicy_map_objectElementType_MarshalUnmarshal tests XML round-trip for Policy_map_objectElementType
func TestPolicy_map_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_stateElement_MarshalUnmarshal tests XML round-trip for Policy_map_stateElement
func TestPolicy_map_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPolicy_map_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPolicy_map_stateElement_ToBytes tests the ToBytes method
func TestPolicy_map_stateElement_ToBytes(t *testing.T) {
	elem := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPolicy_map_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPolicy_map_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPolicy_map_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPolicy_map_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPolicy_map_stateElement_SaveAndLoad tests SaveToFile and LoadPolicy_map_stateFromFile
func TestPolicy_map_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Policy_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPolicy_map_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPolicy_map_stateElement_LoadFromBytes tests the LoadPolicy_map_stateFromBytes function
func TestPolicy_map_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<policy_map_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></policy_map_state>`)

	loaded, err := LoadPolicy_map_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPolicy_map_stateElementType_MarshalUnmarshal tests XML round-trip for Policy_map_stateElementType
func TestPolicy_map_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_testElement_MarshalUnmarshal tests XML round-trip for Policy_map_testElement
func TestPolicy_map_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPolicy_map_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPolicy_map_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPolicy_map_testElement_ToBytes tests the ToBytes method
func TestPolicy_map_testElement_ToBytes(t *testing.T) {
	elem := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPolicy_map_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPolicy_map_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPolicy_map_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPolicy_map_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPolicy_map_testElement_SaveAndLoad tests SaveToFile and LoadPolicy_map_testFromFile
func TestPolicy_map_testElement_SaveAndLoad(t *testing.T) {
	elem := &Policy_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "policy_map_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPolicy_map_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPolicy_map_testElement_LoadFromBytes tests the LoadPolicy_map_testFromBytes function
func TestPolicy_map_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<policy_map_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></policy_map_test>`)

	loaded, err := LoadPolicy_map_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPolicy_map_testElementType_MarshalUnmarshal tests XML round-trip for Policy_map_testElementType
func TestPolicy_map_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Policy_map_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Policy_map_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_objectElement_MarshalUnmarshal tests XML round-trip for Service_policy_objectElement
func TestService_policy_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_policy_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_policy_objectElement_ToBytes tests the ToBytes method
func TestService_policy_objectElement_ToBytes(t *testing.T) {
	elem := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_policy_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_policy_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_policy_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_policy_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_policy_objectElement_SaveAndLoad tests SaveToFile and LoadService_policy_objectFromFile
func TestService_policy_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Service_policy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_policy_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_policy_objectElement_LoadFromBytes tests the LoadService_policy_objectFromBytes function
func TestService_policy_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_policy_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></service_policy_object>`)

	loaded, err := LoadService_policy_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_policy_objectElementType_MarshalUnmarshal tests XML round-trip for Service_policy_objectElementType
func TestService_policy_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_stateElement_MarshalUnmarshal tests XML round-trip for Service_policy_stateElement
func TestService_policy_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_policy_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_policy_stateElement_ToBytes tests the ToBytes method
func TestService_policy_stateElement_ToBytes(t *testing.T) {
	elem := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_policy_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_policy_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_policy_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_policy_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_policy_stateElement_SaveAndLoad tests SaveToFile and LoadService_policy_stateFromFile
func TestService_policy_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Service_policy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_policy_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_policy_stateElement_LoadFromBytes tests the LoadService_policy_stateFromBytes function
func TestService_policy_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_policy_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></service_policy_state>`)

	loaded, err := LoadService_policy_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_policy_stateElementType_MarshalUnmarshal tests XML round-trip for Service_policy_stateElementType
func TestService_policy_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_testElement_MarshalUnmarshal tests XML round-trip for Service_policy_testElement
func TestService_policy_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_policy_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_policy_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_policy_testElement_ToBytes tests the ToBytes method
func TestService_policy_testElement_ToBytes(t *testing.T) {
	elem := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_policy_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_policy_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_policy_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_policy_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_policy_testElement_SaveAndLoad tests SaveToFile and LoadService_policy_testFromFile
func TestService_policy_testElement_SaveAndLoad(t *testing.T) {
	elem := &Service_policy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "service_policy_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_policy_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_policy_testElement_LoadFromBytes tests the LoadService_policy_testFromBytes function
func TestService_policy_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_policy_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></service_policy_test>`)

	loaded, err := LoadService_policy_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_policy_testElementType_MarshalUnmarshal tests XML round-trip for Service_policy_testElementType
func TestService_policy_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_policy_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_policy_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_objectElement_MarshalUnmarshal tests XML round-trip for Snmp_group_objectElement
func TestSnmp_group_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_group_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_group_objectElement_ToBytes tests the ToBytes method
func TestSnmp_group_objectElement_ToBytes(t *testing.T) {
	elem := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_group_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_group_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_group_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_group_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_group_objectElement_SaveAndLoad tests SaveToFile and LoadSnmp_group_objectFromFile
func TestSnmp_group_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_group_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_group_objectElement_LoadFromBytes tests the LoadSnmp_group_objectFromBytes function
func TestSnmp_group_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_group_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_group_object>`)

	loaded, err := LoadSnmp_group_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_group_objectElementType_MarshalUnmarshal tests XML round-trip for Snmp_group_objectElementType
func TestSnmp_group_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_stateElement_MarshalUnmarshal tests XML round-trip for Snmp_group_stateElement
func TestSnmp_group_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_group_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_group_stateElement_ToBytes tests the ToBytes method
func TestSnmp_group_stateElement_ToBytes(t *testing.T) {
	elem := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_group_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_group_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_group_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_group_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_group_stateElement_SaveAndLoad tests SaveToFile and LoadSnmp_group_stateFromFile
func TestSnmp_group_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_group_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_group_stateElement_LoadFromBytes tests the LoadSnmp_group_stateFromBytes function
func TestSnmp_group_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_group_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_group_state>`)

	loaded, err := LoadSnmp_group_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_group_stateElementType_MarshalUnmarshal tests XML round-trip for Snmp_group_stateElementType
func TestSnmp_group_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_testElement_MarshalUnmarshal tests XML round-trip for Snmp_group_testElement
func TestSnmp_group_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_group_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_group_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_group_testElement_ToBytes tests the ToBytes method
func TestSnmp_group_testElement_ToBytes(t *testing.T) {
	elem := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_group_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_group_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_group_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_group_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_group_testElement_SaveAndLoad tests SaveToFile and LoadSnmp_group_testFromFile
func TestSnmp_group_testElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_group_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_group_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_group_testElement_LoadFromBytes tests the LoadSnmp_group_testFromBytes function
func TestSnmp_group_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_group_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_group_test>`)

	loaded, err := LoadSnmp_group_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_group_testElementType_MarshalUnmarshal tests XML round-trip for Snmp_group_testElementType
func TestSnmp_group_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_group_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_group_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_objectElement_MarshalUnmarshal tests XML round-trip for Snmp_host_objectElement
func TestSnmp_host_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_host_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_host_objectElement_ToBytes tests the ToBytes method
func TestSnmp_host_objectElement_ToBytes(t *testing.T) {
	elem := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_host_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_host_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_host_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_host_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_host_objectElement_SaveAndLoad tests SaveToFile and LoadSnmp_host_objectFromFile
func TestSnmp_host_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_host_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_host_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_host_objectElement_LoadFromBytes tests the LoadSnmp_host_objectFromBytes function
func TestSnmp_host_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_host_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_host_object>`)

	loaded, err := LoadSnmp_host_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_host_objectElementType_MarshalUnmarshal tests XML round-trip for Snmp_host_objectElementType
func TestSnmp_host_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_stateElement_MarshalUnmarshal tests XML round-trip for Snmp_host_stateElement
func TestSnmp_host_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_host_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_host_stateElement_ToBytes tests the ToBytes method
func TestSnmp_host_stateElement_ToBytes(t *testing.T) {
	elem := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_host_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_host_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_host_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_host_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_host_stateElement_SaveAndLoad tests SaveToFile and LoadSnmp_host_stateFromFile
func TestSnmp_host_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_host_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_host_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_host_stateElement_LoadFromBytes tests the LoadSnmp_host_stateFromBytes function
func TestSnmp_host_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_host_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_host_state>`)

	loaded, err := LoadSnmp_host_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_host_stateElementType_MarshalUnmarshal tests XML round-trip for Snmp_host_stateElementType
func TestSnmp_host_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_testElement_MarshalUnmarshal tests XML round-trip for Snmp_host_testElement
func TestSnmp_host_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_host_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_host_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_host_testElement_ToBytes tests the ToBytes method
func TestSnmp_host_testElement_ToBytes(t *testing.T) {
	elem := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_host_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_host_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_host_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_host_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_host_testElement_SaveAndLoad tests SaveToFile and LoadSnmp_host_testFromFile
func TestSnmp_host_testElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_host_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_host_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_host_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_host_testElement_LoadFromBytes tests the LoadSnmp_host_testFromBytes function
func TestSnmp_host_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_host_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_host_test>`)

	loaded, err := LoadSnmp_host_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_host_testElementType_MarshalUnmarshal tests XML round-trip for Snmp_host_testElementType
func TestSnmp_host_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_host_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_host_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_objectElement_MarshalUnmarshal tests XML round-trip for Snmp_user_objectElement
func TestSnmp_user_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_user_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_user_objectElement_ToBytes tests the ToBytes method
func TestSnmp_user_objectElement_ToBytes(t *testing.T) {
	elem := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_user_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_user_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_user_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_user_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_user_objectElement_SaveAndLoad tests SaveToFile and LoadSnmp_user_objectFromFile
func TestSnmp_user_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_user_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_user_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_user_objectElement_LoadFromBytes tests the LoadSnmp_user_objectFromBytes function
func TestSnmp_user_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_user_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_user_object>`)

	loaded, err := LoadSnmp_user_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_user_objectElementType_MarshalUnmarshal tests XML round-trip for Snmp_user_objectElementType
func TestSnmp_user_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_stateElement_MarshalUnmarshal tests XML round-trip for Snmp_user_stateElement
func TestSnmp_user_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_user_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_user_stateElement_ToBytes tests the ToBytes method
func TestSnmp_user_stateElement_ToBytes(t *testing.T) {
	elem := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_user_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_user_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_user_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_user_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_user_stateElement_SaveAndLoad tests SaveToFile and LoadSnmp_user_stateFromFile
func TestSnmp_user_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_user_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_user_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_user_stateElement_LoadFromBytes tests the LoadSnmp_user_stateFromBytes function
func TestSnmp_user_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_user_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_user_state>`)

	loaded, err := LoadSnmp_user_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_user_stateElementType_MarshalUnmarshal tests XML round-trip for Snmp_user_stateElementType
func TestSnmp_user_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_testElement_MarshalUnmarshal tests XML round-trip for Snmp_user_testElement
func TestSnmp_user_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSnmp_user_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSnmp_user_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSnmp_user_testElement_ToBytes tests the ToBytes method
func TestSnmp_user_testElement_ToBytes(t *testing.T) {
	elem := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSnmp_user_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSnmp_user_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSnmp_user_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSnmp_user_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSnmp_user_testElement_SaveAndLoad tests SaveToFile and LoadSnmp_user_testFromFile
func TestSnmp_user_testElement_SaveAndLoad(t *testing.T) {
	elem := &Snmp_user_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "snmp_user_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSnmp_user_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSnmp_user_testElement_LoadFromBytes tests the LoadSnmp_user_testFromBytes function
func TestSnmp_user_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<snmp_user_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></snmp_user_test>`)

	loaded, err := LoadSnmp_user_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSnmp_user_testElementType_MarshalUnmarshal tests XML round-trip for Snmp_user_testElementType
func TestSnmp_user_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Snmp_user_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Snmp_user_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_objectElement_MarshalUnmarshal tests XML round-trip for Tcp_map_objectElement
func TestTcp_map_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestTcp_map_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestTcp_map_objectElement_ToBytes tests the ToBytes method
func TestTcp_map_objectElement_ToBytes(t *testing.T) {
	elem := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestTcp_map_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestTcp_map_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestTcp_map_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestTcp_map_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestTcp_map_objectElement_SaveAndLoad tests SaveToFile and LoadTcp_map_objectFromFile
func TestTcp_map_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Tcp_map_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadTcp_map_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestTcp_map_objectElement_LoadFromBytes tests the LoadTcp_map_objectFromBytes function
func TestTcp_map_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<tcp_map_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></tcp_map_object>`)

	loaded, err := LoadTcp_map_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestTcp_map_objectElementType_MarshalUnmarshal tests XML round-trip for Tcp_map_objectElementType
func TestTcp_map_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_stateElement_MarshalUnmarshal tests XML round-trip for Tcp_map_stateElement
func TestTcp_map_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestTcp_map_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestTcp_map_stateElement_ToBytes tests the ToBytes method
func TestTcp_map_stateElement_ToBytes(t *testing.T) {
	elem := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestTcp_map_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestTcp_map_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestTcp_map_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestTcp_map_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestTcp_map_stateElement_SaveAndLoad tests SaveToFile and LoadTcp_map_stateFromFile
func TestTcp_map_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Tcp_map_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadTcp_map_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestTcp_map_stateElement_LoadFromBytes tests the LoadTcp_map_stateFromBytes function
func TestTcp_map_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<tcp_map_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></tcp_map_state>`)

	loaded, err := LoadTcp_map_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestTcp_map_stateElementType_MarshalUnmarshal tests XML round-trip for Tcp_map_stateElementType
func TestTcp_map_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_testElement_MarshalUnmarshal tests XML round-trip for Tcp_map_testElement
func TestTcp_map_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestTcp_map_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestTcp_map_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestTcp_map_testElement_ToBytes tests the ToBytes method
func TestTcp_map_testElement_ToBytes(t *testing.T) {
	elem := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestTcp_map_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestTcp_map_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestTcp_map_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestTcp_map_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestTcp_map_testElement_SaveAndLoad tests SaveToFile and LoadTcp_map_testFromFile
func TestTcp_map_testElement_SaveAndLoad(t *testing.T) {
	elem := &Tcp_map_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "tcp_map_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadTcp_map_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestTcp_map_testElement_LoadFromBytes tests the LoadTcp_map_testFromBytes function
func TestTcp_map_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<tcp_map_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></tcp_map_test>`)

	loaded, err := LoadTcp_map_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestTcp_map_testElementType_MarshalUnmarshal tests XML round-trip for Tcp_map_testElementType
func TestTcp_map_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Tcp_map_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Tcp_map_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_objectElement_MarshalUnmarshal tests XML round-trip for Version_objectElement
func TestVersion_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVersion_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVersion_objectElement_ToBytes tests the ToBytes method
func TestVersion_objectElement_ToBytes(t *testing.T) {
	elem := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVersion_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVersion_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVersion_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVersion_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVersion_objectElement_SaveAndLoad tests SaveToFile and LoadVersion_objectFromFile
func TestVersion_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Version_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVersion_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVersion_objectElement_LoadFromBytes tests the LoadVersion_objectFromBytes function
func TestVersion_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<version_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></version_object>`)

	loaded, err := LoadVersion_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVersion_objectElementType_MarshalUnmarshal tests XML round-trip for Version_objectElementType
func TestVersion_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Version_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_stateElement_MarshalUnmarshal tests XML round-trip for Version_stateElement
func TestVersion_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVersion_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVersion_stateElement_ToBytes tests the ToBytes method
func TestVersion_stateElement_ToBytes(t *testing.T) {
	elem := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVersion_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVersion_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVersion_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVersion_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVersion_stateElement_SaveAndLoad tests SaveToFile and LoadVersion_stateFromFile
func TestVersion_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Version_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVersion_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVersion_stateElement_LoadFromBytes tests the LoadVersion_stateFromBytes function
func TestVersion_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<version_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></version_state>`)

	loaded, err := LoadVersion_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVersion_stateElementType_MarshalUnmarshal tests XML round-trip for Version_stateElementType
func TestVersion_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Version_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_testElement_MarshalUnmarshal tests XML round-trip for Version_testElement
func TestVersion_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersion_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVersion_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVersion_testElement_ToBytes tests the ToBytes method
func TestVersion_testElement_ToBytes(t *testing.T) {
	elem := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVersion_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVersion_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVersion_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVersion_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVersion_testElement_SaveAndLoad tests SaveToFile and LoadVersion_testFromFile
func TestVersion_testElement_SaveAndLoad(t *testing.T) {
	elem := &Version_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#asa", Local: "version_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVersion_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVersion_testElement_LoadFromBytes tests the LoadVersion_testFromBytes function
func TestVersion_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<version_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#asa"></version_test>`)

	loaded, err := LoadVersion_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVersion_testElementType_MarshalUnmarshal tests XML round-trip for Version_testElementType
func TestVersion_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Version_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Version_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
