// Package xmlschemaoval_definitions_5_linux generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5#linux
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/linux-definitions-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_linux

import (
	"encoding/xml"
	"os"
	"strings"

	xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	xmlschemaoval_results_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-results-5"
	xmlschemaoval_system_characteristics_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-system-characteristics-5"
	pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// Apparmorstatus_objectElement represents the XSD element 'apparmorstatus_object'
// XSD element declaration (W3C XSD §3.3)
type Apparmorstatus_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux apparmorstatus_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Apparmorstatus_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Apparmorstatus_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Apparmorstatus_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Apparmorstatus_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Apparmorstatus_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Apparmorstatus_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Apparmorstatus_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Apparmorstatus_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Apparmorstatus_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadApparmorstatus_objectFromBytes loads an element from bytes with namespace preservation
func LoadApparmorstatus_objectFromBytes(data []byte) (*Apparmorstatus_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Apparmorstatus_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadApparmorstatus_objectFromFile loads an element from a file with namespace preservation
func LoadApparmorstatus_objectFromFile(path string) (*Apparmorstatus_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadApparmorstatus_objectFromBytes(data)
}

// Dpkginfo_objectElement represents the XSD element 'dpkginfo_object'
// XSD element declaration (W3C XSD §3.3)
type Dpkginfo_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux dpkginfo_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dpkginfo_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dpkginfo_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dpkginfo_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dpkginfo_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dpkginfo_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dpkginfo_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dpkginfo_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dpkginfo_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dpkginfo_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDpkginfo_objectFromBytes loads an element from bytes with namespace preservation
func LoadDpkginfo_objectFromBytes(data []byte) (*Dpkginfo_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dpkginfo_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDpkginfo_objectFromFile loads an element from a file with namespace preservation
func LoadDpkginfo_objectFromFile(path string) (*Dpkginfo_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDpkginfo_objectFromBytes(data)
}

// Iflisteners_stateElement represents the XSD element 'iflisteners_state'
// XSD element declaration (W3C XSD §3.3)
type Iflisteners_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux iflisteners_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Interface_name represents XSD element 'interface_name'
	// minOccurs=0, maxOccurs=1
	Interface_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"interface_name,omitempty"`
	// Protocol represents XSD element 'protocol'
	// minOccurs=0, maxOccurs=1
	Protocol *EntityStateProtocolType `xml:"protocol,omitempty"`
	// Hw_address represents XSD element 'hw_address'
	// minOccurs=0, maxOccurs=1
	Hw_address *xmlschemaoval_definitions_5.EntityStateStringType `xml:"hw_address,omitempty"`
	// Program_name represents XSD element 'program_name'
	// minOccurs=0, maxOccurs=1
	Program_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"program_name,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// User_id represents XSD element 'user_id'
	// minOccurs=0, maxOccurs=1
	User_id *xmlschemaoval_definitions_5.EntityStateIntType `xml:"user_id,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Iflisteners_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Iflisteners_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Iflisteners_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Iflisteners_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Iflisteners_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Iflisteners_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Iflisteners_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Iflisteners_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Iflisteners_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadIflisteners_stateFromBytes loads an element from bytes with namespace preservation
func LoadIflisteners_stateFromBytes(data []byte) (*Iflisteners_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Iflisteners_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadIflisteners_stateFromFile loads an element from a file with namespace preservation
func LoadIflisteners_stateFromFile(path string) (*Iflisteners_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadIflisteners_stateFromBytes(data)
}

// Rpmverify_objectElement represents the XSD element 'rpmverify_object'
// XSD element declaration (W3C XSD §3.3)
type Rpmverify_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverify_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RpmVerifyBehaviors `xml:"behaviors,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filepath represents XSD element 'filepath'
	Filepath xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverify_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverify_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverify_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverify_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverify_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverify_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverify_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverify_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverify_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverify_objectFromBytes loads an element from bytes with namespace preservation
func LoadRpmverify_objectFromBytes(data []byte) (*Rpmverify_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverify_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverify_objectFromFile loads an element from a file with namespace preservation
func LoadRpmverify_objectFromFile(path string) (*Rpmverify_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverify_objectFromBytes(data)
}

// Selinuxsecuritycontext_testElement represents the XSD element 'selinuxsecuritycontext_test'
// XSD element declaration (W3C XSD §3.3)
type Selinuxsecuritycontext_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxsecuritycontext_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxsecuritycontext_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxsecuritycontext_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxsecuritycontext_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxsecuritycontext_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxsecuritycontext_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxsecuritycontext_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxsecuritycontext_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxsecuritycontext_testFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxsecuritycontext_testFromBytes(data []byte) (*Selinuxsecuritycontext_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxsecuritycontext_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxsecuritycontext_testFromFile loads an element from a file with namespace preservation
func LoadSelinuxsecuritycontext_testFromFile(path string) (*Selinuxsecuritycontext_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxsecuritycontext_testFromBytes(data)
}

// Rpmverifypackage_stateElement represents the XSD element 'rpmverifypackage_state'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifypackage_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifypackage_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Epoch represents XSD element 'epoch'
	// minOccurs=0, maxOccurs=1
	Epoch *EpochElementType `xml:"epoch,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *VersionElementType `xml:"version,omitempty"`
	// Release represents XSD element 'release'
	// minOccurs=0, maxOccurs=1
	Release *ReleaseElementType `xml:"release,omitempty"`
	// Arch represents XSD element 'arch'
	// minOccurs=0, maxOccurs=1
	Arch *xmlschemaoval_definitions_5.EntityStateStringType `xml:"arch,omitempty"`
	// Extended_name represents XSD element 'extended_name'
	// minOccurs=0, maxOccurs=1
	Extended_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"extended_name,omitempty"`
	// Dependency_check_passed represents XSD element 'dependency_check_passed'
	// minOccurs=0, maxOccurs=1
	Dependency_check_passed *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"dependency_check_passed,omitempty"`
	// Digest_check_passed represents XSD element 'digest_check_passed'
	// minOccurs=0, maxOccurs=1
	Digest_check_passed *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"digest_check_passed,omitempty"`
	// Verification_script_successful represents XSD element 'verification_script_successful'
	// minOccurs=0, maxOccurs=1
	Verification_script_successful *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"verification_script_successful,omitempty"`
	// Signature_check_passed represents XSD element 'signature_check_passed'
	// minOccurs=0, maxOccurs=1
	Signature_check_passed *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"signature_check_passed,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifypackage_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifypackage_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifypackage_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifypackage_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifypackage_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifypackage_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifypackage_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifypackage_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifypackage_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifypackage_stateFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifypackage_stateFromBytes(data []byte) (*Rpmverifypackage_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifypackage_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifypackage_stateFromFile loads an element from a file with namespace preservation
func LoadRpmverifypackage_stateFromFile(path string) (*Rpmverifypackage_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifypackage_stateFromBytes(data)
}

// Apparmorstatus_testElement represents the XSD element 'apparmorstatus_test'
// XSD element declaration (W3C XSD §3.3)
type Apparmorstatus_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux apparmorstatus_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Apparmorstatus_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Apparmorstatus_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Apparmorstatus_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Apparmorstatus_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Apparmorstatus_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Apparmorstatus_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Apparmorstatus_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Apparmorstatus_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Apparmorstatus_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadApparmorstatus_testFromBytes loads an element from bytes with namespace preservation
func LoadApparmorstatus_testFromBytes(data []byte) (*Apparmorstatus_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Apparmorstatus_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadApparmorstatus_testFromFile loads an element from a file with namespace preservation
func LoadApparmorstatus_testFromFile(path string) (*Apparmorstatus_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadApparmorstatus_testFromBytes(data)
}

// Partition_testElement represents the XSD element 'partition_test'
// XSD element declaration (W3C XSD §3.3)
type Partition_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux partition_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Partition_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Partition_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Partition_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Partition_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Partition_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Partition_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Partition_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Partition_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Partition_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPartition_testFromBytes loads an element from bytes with namespace preservation
func LoadPartition_testFromBytes(data []byte) (*Partition_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Partition_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPartition_testFromFile loads an element from a file with namespace preservation
func LoadPartition_testFromFile(path string) (*Partition_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPartition_testFromBytes(data)
}

// Rpmverify_stateElement represents the XSD element 'rpmverify_state'
// XSD element declaration (W3C XSD §3.3)
type Rpmverify_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverify_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Size_differs represents XSD element 'size_differs'
	// minOccurs=0, maxOccurs=1
	Size_differs *EntityStateRpmVerifyResultType `xml:"size_differs,omitempty"`
	// Mode_differs represents XSD element 'mode_differs'
	// minOccurs=0, maxOccurs=1
	Mode_differs *EntityStateRpmVerifyResultType `xml:"mode_differs,omitempty"`
	// Md5_differs represents XSD element 'md5_differs'
	// minOccurs=0, maxOccurs=1
	Md5_differs *EntityStateRpmVerifyResultType `xml:"md5_differs,omitempty"`
	// Device_differs represents XSD element 'device_differs'
	// minOccurs=0, maxOccurs=1
	Device_differs *EntityStateRpmVerifyResultType `xml:"device_differs,omitempty"`
	// Link_mismatch represents XSD element 'link_mismatch'
	// minOccurs=0, maxOccurs=1
	Link_mismatch *EntityStateRpmVerifyResultType `xml:"link_mismatch,omitempty"`
	// Ownership_differs represents XSD element 'ownership_differs'
	// minOccurs=0, maxOccurs=1
	Ownership_differs *EntityStateRpmVerifyResultType `xml:"ownership_differs,omitempty"`
	// Group_differs represents XSD element 'group_differs'
	// minOccurs=0, maxOccurs=1
	Group_differs *EntityStateRpmVerifyResultType `xml:"group_differs,omitempty"`
	// Mtime_differs represents XSD element 'mtime_differs'
	// minOccurs=0, maxOccurs=1
	Mtime_differs *EntityStateRpmVerifyResultType `xml:"mtime_differs,omitempty"`
	// Capabilities_differ represents XSD element 'capabilities_differ'
	// minOccurs=0, maxOccurs=1
	Capabilities_differ *EntityStateRpmVerifyResultType `xml:"capabilities_differ,omitempty"`
	// Configuration_file represents XSD element 'configuration_file'
	// minOccurs=0, maxOccurs=1
	Configuration_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"configuration_file,omitempty"`
	// Documentation_file represents XSD element 'documentation_file'
	// minOccurs=0, maxOccurs=1
	Documentation_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"documentation_file,omitempty"`
	// Ghost_file represents XSD element 'ghost_file'
	// minOccurs=0, maxOccurs=1
	Ghost_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"ghost_file,omitempty"`
	// License_file represents XSD element 'license_file'
	// minOccurs=0, maxOccurs=1
	License_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"license_file,omitempty"`
	// Readme_file represents XSD element 'readme_file'
	// minOccurs=0, maxOccurs=1
	Readme_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"readme_file,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverify_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverify_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverify_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverify_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverify_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverify_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverify_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverify_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverify_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverify_stateFromBytes loads an element from bytes with namespace preservation
func LoadRpmverify_stateFromBytes(data []byte) (*Rpmverify_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverify_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverify_stateFromFile loads an element from a file with namespace preservation
func LoadRpmverify_stateFromFile(path string) (*Rpmverify_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverify_stateFromBytes(data)
}

// Rpmverifypackage_testElement represents the XSD element 'rpmverifypackage_test'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifypackage_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifypackage_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifypackage_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifypackage_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifypackage_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifypackage_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifypackage_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifypackage_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifypackage_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifypackage_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifypackage_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifypackage_testFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifypackage_testFromBytes(data []byte) (*Rpmverifypackage_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifypackage_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifypackage_testFromFile loads an element from a file with namespace preservation
func LoadRpmverifypackage_testFromFile(path string) (*Rpmverifypackage_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifypackage_testFromBytes(data)
}

// Selinuxboolean_objectElement represents the XSD element 'selinuxboolean_object'
// XSD element declaration (W3C XSD §3.3)
type Selinuxboolean_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxboolean_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxboolean_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxboolean_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxboolean_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxboolean_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxboolean_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxboolean_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxboolean_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxboolean_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxboolean_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxboolean_objectFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxboolean_objectFromBytes(data []byte) (*Selinuxboolean_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxboolean_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxboolean_objectFromFile loads an element from a file with namespace preservation
func LoadSelinuxboolean_objectFromFile(path string) (*Selinuxboolean_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxboolean_objectFromBytes(data)
}

// Selinuxboolean_stateElement represents the XSD element 'selinuxboolean_state'
// XSD element declaration (W3C XSD §3.3)
type Selinuxboolean_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxboolean_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Current_status represents XSD element 'current_status'
	// minOccurs=0, maxOccurs=1
	Current_status *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"current_status,omitempty"`
	// Pending_status represents XSD element 'pending_status'
	// minOccurs=0, maxOccurs=1
	Pending_status *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"pending_status,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxboolean_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxboolean_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxboolean_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxboolean_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxboolean_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxboolean_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxboolean_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxboolean_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxboolean_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxboolean_stateFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxboolean_stateFromBytes(data []byte) (*Selinuxboolean_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxboolean_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxboolean_stateFromFile loads an element from a file with namespace preservation
func LoadSelinuxboolean_stateFromFile(path string) (*Selinuxboolean_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxboolean_stateFromBytes(data)
}

// Systemdunitproperty_testElement represents the XSD element 'systemdunitproperty_test'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitproperty_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitproperty_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitproperty_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitproperty_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitproperty_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitproperty_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitproperty_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitproperty_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitproperty_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitproperty_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitproperty_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitproperty_testFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitproperty_testFromBytes(data []byte) (*Systemdunitproperty_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitproperty_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitproperty_testFromFile loads an element from a file with namespace preservation
func LoadSystemdunitproperty_testFromFile(path string) (*Systemdunitproperty_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitproperty_testFromBytes(data)
}

// Iflisteners_testElement represents the XSD element 'iflisteners_test'
// XSD element declaration (W3C XSD §3.3)
type Iflisteners_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux iflisteners_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Iflisteners_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Iflisteners_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Iflisteners_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Iflisteners_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Iflisteners_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Iflisteners_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Iflisteners_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Iflisteners_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Iflisteners_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadIflisteners_testFromBytes loads an element from bytes with namespace preservation
func LoadIflisteners_testFromBytes(data []byte) (*Iflisteners_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Iflisteners_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadIflisteners_testFromFile loads an element from a file with namespace preservation
func LoadIflisteners_testFromFile(path string) (*Iflisteners_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadIflisteners_testFromBytes(data)
}

// Inetlisteningservers_objectElement represents the XSD element 'inetlisteningservers_object'
// XSD element declaration (W3C XSD §3.3)
type Inetlisteningservers_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux inetlisteningservers_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Protocol represents XSD element 'protocol'
	Protocol xmlschemaoval_definitions_5.EntityObjectStringType `xml:"protocol"`
	// Local_address represents XSD element 'local_address'
	Local_address xmlschemaoval_definitions_5.EntityObjectIPAddressStringType `xml:"local_address"`
	// Local_port represents XSD element 'local_port'
	Local_port xmlschemaoval_definitions_5.EntityObjectIntType `xml:"local_port"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Inetlisteningservers_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Inetlisteningservers_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Inetlisteningservers_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Inetlisteningservers_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Inetlisteningservers_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Inetlisteningservers_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Inetlisteningservers_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Inetlisteningservers_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Inetlisteningservers_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInetlisteningservers_objectFromBytes loads an element from bytes with namespace preservation
func LoadInetlisteningservers_objectFromBytes(data []byte) (*Inetlisteningservers_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Inetlisteningservers_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInetlisteningservers_objectFromFile loads an element from a file with namespace preservation
func LoadInetlisteningservers_objectFromFile(path string) (*Inetlisteningservers_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInetlisteningservers_objectFromBytes(data)
}

// Inetlisteningservers_stateElement represents the XSD element 'inetlisteningservers_state'
// XSD element declaration (W3C XSD §3.3)
type Inetlisteningservers_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux inetlisteningservers_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Protocol represents XSD element 'protocol'
	// minOccurs=0, maxOccurs=1
	Protocol *xmlschemaoval_definitions_5.EntityStateStringType `xml:"protocol,omitempty"`
	// Local_address represents XSD element 'local_address'
	// minOccurs=0, maxOccurs=1
	Local_address *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"local_address,omitempty"`
	// Local_port represents XSD element 'local_port'
	// minOccurs=0, maxOccurs=1
	Local_port *xmlschemaoval_definitions_5.EntityStateIntType `xml:"local_port,omitempty"`
	// Local_full_address represents XSD element 'local_full_address'
	// minOccurs=0, maxOccurs=1
	Local_full_address *xmlschemaoval_definitions_5.EntityStateStringType `xml:"local_full_address,omitempty"`
	// Program_name represents XSD element 'program_name'
	// minOccurs=0, maxOccurs=1
	Program_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"program_name,omitempty"`
	// Foreign_address represents XSD element 'foreign_address'
	// minOccurs=0, maxOccurs=1
	Foreign_address *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"foreign_address,omitempty"`
	// Foreign_port represents XSD element 'foreign_port'
	// minOccurs=0, maxOccurs=1
	Foreign_port *xmlschemaoval_definitions_5.EntityStateIntType `xml:"foreign_port,omitempty"`
	// Foreign_full_address represents XSD element 'foreign_full_address'
	// minOccurs=0, maxOccurs=1
	Foreign_full_address *xmlschemaoval_definitions_5.EntityStateStringType `xml:"foreign_full_address,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// User_id represents XSD element 'user_id'
	// minOccurs=0, maxOccurs=1
	User_id *xmlschemaoval_definitions_5.EntityStateIntType `xml:"user_id,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Inetlisteningservers_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Inetlisteningservers_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Inetlisteningservers_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Inetlisteningservers_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Inetlisteningservers_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Inetlisteningservers_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Inetlisteningservers_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Inetlisteningservers_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Inetlisteningservers_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInetlisteningservers_stateFromBytes loads an element from bytes with namespace preservation
func LoadInetlisteningservers_stateFromBytes(data []byte) (*Inetlisteningservers_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Inetlisteningservers_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInetlisteningservers_stateFromFile loads an element from a file with namespace preservation
func LoadInetlisteningservers_stateFromFile(path string) (*Inetlisteningservers_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInetlisteningservers_stateFromBytes(data)
}

// Rpminfo_objectElement represents the XSD element 'rpminfo_object'
// XSD element declaration (W3C XSD §3.3)
type Rpminfo_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpminfo_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RpmInfoBehaviors `xml:"behaviors,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpminfo_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpminfo_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpminfo_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpminfo_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpminfo_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpminfo_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpminfo_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpminfo_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpminfo_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpminfo_objectFromBytes loads an element from bytes with namespace preservation
func LoadRpminfo_objectFromBytes(data []byte) (*Rpminfo_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpminfo_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpminfo_objectFromFile loads an element from a file with namespace preservation
func LoadRpminfo_objectFromFile(path string) (*Rpminfo_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpminfo_objectFromBytes(data)
}

// Slackwarepkginfo_testElement represents the XSD element 'slackwarepkginfo_test'
// XSD element declaration (W3C XSD §3.3)
type Slackwarepkginfo_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux slackwarepkginfo_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Slackwarepkginfo_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Slackwarepkginfo_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Slackwarepkginfo_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Slackwarepkginfo_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Slackwarepkginfo_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Slackwarepkginfo_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Slackwarepkginfo_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSlackwarepkginfo_testFromBytes loads an element from bytes with namespace preservation
func LoadSlackwarepkginfo_testFromBytes(data []byte) (*Slackwarepkginfo_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Slackwarepkginfo_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSlackwarepkginfo_testFromFile loads an element from a file with namespace preservation
func LoadSlackwarepkginfo_testFromFile(path string) (*Slackwarepkginfo_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSlackwarepkginfo_testFromBytes(data)
}

// Slackwarepkginfo_objectElement represents the XSD element 'slackwarepkginfo_object'
// XSD element declaration (W3C XSD §3.3)
type Slackwarepkginfo_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux slackwarepkginfo_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Slackwarepkginfo_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Slackwarepkginfo_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Slackwarepkginfo_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Slackwarepkginfo_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Slackwarepkginfo_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Slackwarepkginfo_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Slackwarepkginfo_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSlackwarepkginfo_objectFromBytes loads an element from bytes with namespace preservation
func LoadSlackwarepkginfo_objectFromBytes(data []byte) (*Slackwarepkginfo_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Slackwarepkginfo_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSlackwarepkginfo_objectFromFile loads an element from a file with namespace preservation
func LoadSlackwarepkginfo_objectFromFile(path string) (*Slackwarepkginfo_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSlackwarepkginfo_objectFromBytes(data)
}

// Systemdunitdependency_objectElement represents the XSD element 'systemdunitdependency_object'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitdependency_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitdependency_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Unit represents XSD element 'unit'
	Unit xmlschemaoval_definitions_5.EntityObjectStringType `xml:"unit"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitdependency_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitdependency_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitdependency_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitdependency_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitdependency_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitdependency_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitdependency_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitdependency_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitdependency_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitdependency_objectFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitdependency_objectFromBytes(data []byte) (*Systemdunitdependency_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitdependency_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitdependency_objectFromFile loads an element from a file with namespace preservation
func LoadSystemdunitdependency_objectFromFile(path string) (*Systemdunitdependency_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitdependency_objectFromBytes(data)
}

// Selinuxboolean_testElement represents the XSD element 'selinuxboolean_test'
// XSD element declaration (W3C XSD §3.3)
type Selinuxboolean_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxboolean_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxboolean_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxboolean_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxboolean_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxboolean_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxboolean_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxboolean_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxboolean_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxboolean_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxboolean_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxboolean_testFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxboolean_testFromBytes(data []byte) (*Selinuxboolean_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxboolean_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxboolean_testFromFile loads an element from a file with namespace preservation
func LoadSelinuxboolean_testFromFile(path string) (*Selinuxboolean_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxboolean_testFromBytes(data)
}

// Iflisteners_objectElement represents the XSD element 'iflisteners_object'
// XSD element declaration (W3C XSD §3.3)
type Iflisteners_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux iflisteners_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Interface_name represents XSD element 'interface_name'
	Interface_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"interface_name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Iflisteners_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Iflisteners_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Iflisteners_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Iflisteners_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Iflisteners_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Iflisteners_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Iflisteners_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Iflisteners_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Iflisteners_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadIflisteners_objectFromBytes loads an element from bytes with namespace preservation
func LoadIflisteners_objectFromBytes(data []byte) (*Iflisteners_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Iflisteners_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadIflisteners_objectFromFile loads an element from a file with namespace preservation
func LoadIflisteners_objectFromFile(path string) (*Iflisteners_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadIflisteners_objectFromBytes(data)
}

// Inetlisteningservers_testElement represents the XSD element 'inetlisteningservers_test'
// XSD element declaration (W3C XSD §3.3)
type Inetlisteningservers_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux inetlisteningservers_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Inetlisteningservers_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Inetlisteningservers_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Inetlisteningservers_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Inetlisteningservers_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Inetlisteningservers_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Inetlisteningservers_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Inetlisteningservers_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Inetlisteningservers_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Inetlisteningservers_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInetlisteningservers_testFromBytes loads an element from bytes with namespace preservation
func LoadInetlisteningservers_testFromBytes(data []byte) (*Inetlisteningservers_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Inetlisteningservers_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInetlisteningservers_testFromFile loads an element from a file with namespace preservation
func LoadInetlisteningservers_testFromFile(path string) (*Inetlisteningservers_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInetlisteningservers_testFromBytes(data)
}

// Partition_objectElement represents the XSD element 'partition_object'
// XSD element declaration (W3C XSD §3.3)
type Partition_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux partition_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Mount_point represents XSD element 'mount_point'
	Mount_point xmlschemaoval_definitions_5.EntityObjectStringType `xml:"mount_point"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Partition_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Partition_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Partition_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Partition_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Partition_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Partition_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Partition_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Partition_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Partition_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPartition_objectFromBytes loads an element from bytes with namespace preservation
func LoadPartition_objectFromBytes(data []byte) (*Partition_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Partition_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPartition_objectFromFile loads an element from a file with namespace preservation
func LoadPartition_objectFromFile(path string) (*Partition_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPartition_objectFromBytes(data)
}

// Rpmverify_testElement represents the XSD element 'rpmverify_test'
// XSD element declaration (W3C XSD §3.3)
type Rpmverify_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverify_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverify_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverify_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverify_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverify_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverify_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverify_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverify_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverify_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverify_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverify_testFromBytes loads an element from bytes with namespace preservation
func LoadRpmverify_testFromBytes(data []byte) (*Rpmverify_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverify_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverify_testFromFile loads an element from a file with namespace preservation
func LoadRpmverify_testFromFile(path string) (*Rpmverify_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverify_testFromBytes(data)
}

// Dpkginfo_testElement represents the XSD element 'dpkginfo_test'
// XSD element declaration (W3C XSD §3.3)
type Dpkginfo_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux dpkginfo_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dpkginfo_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dpkginfo_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dpkginfo_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dpkginfo_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dpkginfo_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dpkginfo_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dpkginfo_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dpkginfo_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dpkginfo_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDpkginfo_testFromBytes loads an element from bytes with namespace preservation
func LoadDpkginfo_testFromBytes(data []byte) (*Dpkginfo_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dpkginfo_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDpkginfo_testFromFile loads an element from a file with namespace preservation
func LoadDpkginfo_testFromFile(path string) (*Dpkginfo_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDpkginfo_testFromBytes(data)
}

// Partition_stateElement represents the XSD element 'partition_state'
// XSD element declaration (W3C XSD §3.3)
type Partition_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux partition_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Mount_point represents XSD element 'mount_point'
	// minOccurs=0, maxOccurs=1
	Mount_point *xmlschemaoval_definitions_5.EntityStateStringType `xml:"mount_point,omitempty"`
	// Device represents XSD element 'device'
	// minOccurs=0, maxOccurs=1
	Device *xmlschemaoval_definitions_5.EntityStateStringType `xml:"device,omitempty"`
	// Uuid represents XSD element 'uuid'
	// minOccurs=0, maxOccurs=1
	Uuid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"uuid,omitempty"`
	// Fs_type represents XSD element 'fs_type'
	// minOccurs=0, maxOccurs=1
	Fs_type *xmlschemaoval_definitions_5.EntityStateStringType `xml:"fs_type,omitempty"`
	// Mount_options represents XSD element 'mount_options'
	// minOccurs=0, maxOccurs=1
	Mount_options *xmlschemaoval_definitions_5.EntityStateStringType `xml:"mount_options,omitempty"`
	// Total_space represents XSD element 'total_space'
	// minOccurs=0, maxOccurs=1
	Total_space *xmlschemaoval_definitions_5.EntityStateIntType `xml:"total_space,omitempty"`
	// Space_used represents XSD element 'space_used'
	// minOccurs=0, maxOccurs=1
	Space_used *xmlschemaoval_definitions_5.EntityStateIntType `xml:"space_used,omitempty"`
	// Space_left represents XSD element 'space_left'
	// minOccurs=0, maxOccurs=1
	Space_left *xmlschemaoval_definitions_5.EntityStateIntType `xml:"space_left,omitempty"`
	// Space_left_for_unprivileged_users represents XSD element 'space_left_for_unprivileged_users'
	// minOccurs=0, maxOccurs=1
	Space_left_for_unprivileged_users *xmlschemaoval_definitions_5.EntityStateIntType `xml:"space_left_for_unprivileged_users,omitempty"`
	// Block_size represents XSD element 'block_size'
	// minOccurs=0, maxOccurs=1
	Block_size *xmlschemaoval_definitions_5.EntityStateIntType `xml:"block_size,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Partition_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Partition_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Partition_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Partition_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Partition_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Partition_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Partition_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Partition_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Partition_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPartition_stateFromBytes loads an element from bytes with namespace preservation
func LoadPartition_stateFromBytes(data []byte) (*Partition_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Partition_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPartition_stateFromFile loads an element from a file with namespace preservation
func LoadPartition_stateFromFile(path string) (*Partition_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPartition_stateFromBytes(data)
}

// Rpminfo_stateElement represents the XSD element 'rpminfo_state'
// XSD element declaration (W3C XSD §3.3)
type Rpminfo_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpminfo_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Arch represents XSD element 'arch'
	// minOccurs=0, maxOccurs=1
	Arch *xmlschemaoval_definitions_5.EntityStateStringType `xml:"arch,omitempty"`
	// Epoch represents XSD element 'epoch'
	// minOccurs=0, maxOccurs=1
	Epoch *EpochElementType1 `xml:"epoch,omitempty"`
	// Release represents XSD element 'release'
	// minOccurs=0, maxOccurs=1
	Release *ReleaseElementType1 `xml:"release,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *VersionElementType1 `xml:"version,omitempty"`
	// Evr represents XSD element 'evr'
	// minOccurs=0, maxOccurs=1
	Evr *xmlschemaoval_definitions_5.EntityStateEVRStringType `xml:"evr,omitempty"`
	// Signature_keyid represents XSD element 'signature_keyid'
	// minOccurs=0, maxOccurs=1
	Signature_keyid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"signature_keyid,omitempty"`
	// Extended_name represents XSD element 'extended_name'
	// minOccurs=0, maxOccurs=1
	Extended_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"extended_name,omitempty"`
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpminfo_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpminfo_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpminfo_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpminfo_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpminfo_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpminfo_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpminfo_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpminfo_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpminfo_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpminfo_stateFromBytes loads an element from bytes with namespace preservation
func LoadRpminfo_stateFromBytes(data []byte) (*Rpminfo_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpminfo_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpminfo_stateFromFile loads an element from a file with namespace preservation
func LoadRpminfo_stateFromFile(path string) (*Rpminfo_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpminfo_stateFromBytes(data)
}

// Rpmverifyfile_testElement represents the XSD element 'rpmverifyfile_test'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifyfile_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifyfile_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifyfile_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifyfile_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifyfile_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifyfile_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifyfile_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifyfile_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifyfile_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifyfile_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifyfile_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifyfile_testFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifyfile_testFromBytes(data []byte) (*Rpmverifyfile_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifyfile_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifyfile_testFromFile loads an element from a file with namespace preservation
func LoadRpmverifyfile_testFromFile(path string) (*Rpmverifyfile_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifyfile_testFromBytes(data)
}

// Rpmverifypackage_objectElement represents the XSD element 'rpmverifypackage_object'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifypackage_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifypackage_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RpmVerifyPackageBehaviors `xml:"behaviors,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Epoch represents XSD element 'epoch'
	Epoch EpochElementType2 `xml:"epoch"`
	// Version represents XSD element 'version'
	Version VersionElementType2 `xml:"version"`
	// Release represents XSD element 'release'
	Release ReleaseElementType2 `xml:"release"`
	// Arch represents XSD element 'arch'
	Arch xmlschemaoval_definitions_5.EntityObjectStringType `xml:"arch"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifypackage_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifypackage_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifypackage_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifypackage_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifypackage_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifypackage_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifypackage_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifypackage_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifypackage_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifypackage_objectFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifypackage_objectFromBytes(data []byte) (*Rpmverifypackage_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifypackage_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifypackage_objectFromFile loads an element from a file with namespace preservation
func LoadRpmverifypackage_objectFromFile(path string) (*Rpmverifypackage_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifypackage_objectFromBytes(data)
}

// Slackwarepkginfo_stateElement represents the XSD element 'slackwarepkginfo_state'
// XSD element declaration (W3C XSD §3.3)
type Slackwarepkginfo_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux slackwarepkginfo_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *VersionElementType3 `xml:"version,omitempty"`
	// Architecture represents XSD element 'architecture'
	// minOccurs=0, maxOccurs=1
	Architecture *xmlschemaoval_definitions_5.EntityStateStringType `xml:"architecture,omitempty"`
	// Revision represents XSD element 'revision'
	// minOccurs=0, maxOccurs=1
	Revision *xmlschemaoval_definitions_5.EntityStateStringType `xml:"revision,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Slackwarepkginfo_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Slackwarepkginfo_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Slackwarepkginfo_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Slackwarepkginfo_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Slackwarepkginfo_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Slackwarepkginfo_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Slackwarepkginfo_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Slackwarepkginfo_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSlackwarepkginfo_stateFromBytes loads an element from bytes with namespace preservation
func LoadSlackwarepkginfo_stateFromBytes(data []byte) (*Slackwarepkginfo_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Slackwarepkginfo_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSlackwarepkginfo_stateFromFile loads an element from a file with namespace preservation
func LoadSlackwarepkginfo_stateFromFile(path string) (*Slackwarepkginfo_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSlackwarepkginfo_stateFromBytes(data)
}

// Systemdunitdependency_testElement represents the XSD element 'systemdunitdependency_test'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitdependency_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitdependency_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitdependency_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitdependency_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitdependency_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitdependency_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitdependency_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitdependency_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitdependency_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitdependency_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitdependency_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitdependency_testFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitdependency_testFromBytes(data []byte) (*Systemdunitdependency_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitdependency_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitdependency_testFromFile loads an element from a file with namespace preservation
func LoadSystemdunitdependency_testFromFile(path string) (*Systemdunitdependency_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitdependency_testFromBytes(data)
}

// Systemdunitdependency_stateElement represents the XSD element 'systemdunitdependency_state'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitdependency_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitdependency_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Unit represents XSD element 'unit'
	// minOccurs=0, maxOccurs=1
	Unit *xmlschemaoval_definitions_5.EntityStateStringType `xml:"unit,omitempty"`
	// Dependency represents XSD element 'dependency'
	// minOccurs=0, maxOccurs=1
	Dependency *xmlschemaoval_definitions_5.EntityStateStringType `xml:"dependency,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitdependency_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitdependency_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitdependency_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitdependency_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitdependency_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitdependency_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitdependency_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitdependency_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitdependency_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitdependency_stateFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitdependency_stateFromBytes(data []byte) (*Systemdunitdependency_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitdependency_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitdependency_stateFromFile loads an element from a file with namespace preservation
func LoadSystemdunitdependency_stateFromFile(path string) (*Systemdunitdependency_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitdependency_stateFromBytes(data)
}

// Dpkginfo_stateElement represents the XSD element 'dpkginfo_state'
// XSD element declaration (W3C XSD §3.3)
type Dpkginfo_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux dpkginfo_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Arch represents XSD element 'arch'
	// minOccurs=0, maxOccurs=1
	Arch *xmlschemaoval_definitions_5.EntityStateStringType `xml:"arch,omitempty"`
	// Epoch represents XSD element 'epoch'
	// minOccurs=0, maxOccurs=1
	Epoch *EpochElementType3 `xml:"epoch,omitempty"`
	// Release represents XSD element 'release'
	// minOccurs=0, maxOccurs=1
	Release *ReleaseElementType3 `xml:"release,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *VersionElementType4 `xml:"version,omitempty"`
	// Evr represents XSD element 'evr'
	// minOccurs=0, maxOccurs=1
	Evr *EvrElementType `xml:"evr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dpkginfo_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dpkginfo_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dpkginfo_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dpkginfo_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dpkginfo_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dpkginfo_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dpkginfo_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dpkginfo_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dpkginfo_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDpkginfo_stateFromBytes loads an element from bytes with namespace preservation
func LoadDpkginfo_stateFromBytes(data []byte) (*Dpkginfo_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dpkginfo_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDpkginfo_stateFromFile loads an element from a file with namespace preservation
func LoadDpkginfo_stateFromFile(path string) (*Dpkginfo_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDpkginfo_stateFromBytes(data)
}

// Selinuxsecuritycontext_objectElement represents the XSD element 'selinuxsecuritycontext_object'
// XSD element declaration (W3C XSD §3.3)
type Selinuxsecuritycontext_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxsecuritycontext_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileBehaviors `xml:"behaviors,omitempty"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// Filepath represents XSD element 'filepath'
	Filepath *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath,omitempty"`
	// Pid represents XSD element 'pid'
	Pid *xmlschemaoval_definitions_5.EntityObjectIntType `xml:"pid,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxsecuritycontext_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxsecuritycontext_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxsecuritycontext_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxsecuritycontext_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxsecuritycontext_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxsecuritycontext_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxsecuritycontext_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxsecuritycontext_objectFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxsecuritycontext_objectFromBytes(data []byte) (*Selinuxsecuritycontext_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxsecuritycontext_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxsecuritycontext_objectFromFile loads an element from a file with namespace preservation
func LoadSelinuxsecuritycontext_objectFromFile(path string) (*Selinuxsecuritycontext_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxsecuritycontext_objectFromBytes(data)
}

// Selinuxsecuritycontext_stateElement represents the XSD element 'selinuxsecuritycontext_state'
// XSD element declaration (W3C XSD §3.3)
type Selinuxsecuritycontext_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux selinuxsecuritycontext_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// User represents XSD element 'user'
	// minOccurs=0, maxOccurs=1
	User *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user,omitempty"`
	// Role represents XSD element 'role'
	// minOccurs=0, maxOccurs=1
	Role *xmlschemaoval_definitions_5.EntityStateStringType `xml:"role,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *xmlschemaoval_definitions_5.EntityStateStringType `xml:"type,omitempty"`
	// Low_sensitivity represents XSD element 'low_sensitivity'
	// minOccurs=0, maxOccurs=1
	Low_sensitivity *xmlschemaoval_definitions_5.EntityStateStringType `xml:"low_sensitivity,omitempty"`
	// Low_category represents XSD element 'low_category'
	// minOccurs=0, maxOccurs=1
	Low_category *xmlschemaoval_definitions_5.EntityStateStringType `xml:"low_category,omitempty"`
	// High_sensitivity represents XSD element 'high_sensitivity'
	// minOccurs=0, maxOccurs=1
	High_sensitivity *xmlschemaoval_definitions_5.EntityStateStringType `xml:"high_sensitivity,omitempty"`
	// High_category represents XSD element 'high_category'
	// minOccurs=0, maxOccurs=1
	High_category *xmlschemaoval_definitions_5.EntityStateStringType `xml:"high_category,omitempty"`
	// Rawlow_sensitivity represents XSD element 'rawlow_sensitivity'
	// minOccurs=0, maxOccurs=1
	Rawlow_sensitivity *xmlschemaoval_definitions_5.EntityStateStringType `xml:"rawlow_sensitivity,omitempty"`
	// Rawlow_category represents XSD element 'rawlow_category'
	// minOccurs=0, maxOccurs=1
	Rawlow_category *xmlschemaoval_definitions_5.EntityStateStringType `xml:"rawlow_category,omitempty"`
	// Rawhigh_sensitivity represents XSD element 'rawhigh_sensitivity'
	// minOccurs=0, maxOccurs=1
	Rawhigh_sensitivity *xmlschemaoval_definitions_5.EntityStateStringType `xml:"rawhigh_sensitivity,omitempty"`
	// Rawhigh_category represents XSD element 'rawhigh_category'
	// minOccurs=0, maxOccurs=1
	Rawhigh_category *xmlschemaoval_definitions_5.EntityStateStringType `xml:"rawhigh_category,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Selinuxsecuritycontext_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Selinuxsecuritycontext_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Selinuxsecuritycontext_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Selinuxsecuritycontext_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Selinuxsecuritycontext_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Selinuxsecuritycontext_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Selinuxsecuritycontext_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Selinuxsecuritycontext_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSelinuxsecuritycontext_stateFromBytes loads an element from bytes with namespace preservation
func LoadSelinuxsecuritycontext_stateFromBytes(data []byte) (*Selinuxsecuritycontext_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Selinuxsecuritycontext_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSelinuxsecuritycontext_stateFromFile loads an element from a file with namespace preservation
func LoadSelinuxsecuritycontext_stateFromFile(path string) (*Selinuxsecuritycontext_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSelinuxsecuritycontext_stateFromBytes(data)
}

// Systemdunitproperty_objectElement represents the XSD element 'systemdunitproperty_object'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitproperty_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitproperty_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Unit represents XSD element 'unit'
	Unit xmlschemaoval_definitions_5.EntityObjectStringType `xml:"unit"`
	// Property represents XSD element 'property'
	Property xmlschemaoval_definitions_5.EntityObjectStringType `xml:"property"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitproperty_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitproperty_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitproperty_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitproperty_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitproperty_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitproperty_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitproperty_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitproperty_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitproperty_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitproperty_objectFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitproperty_objectFromBytes(data []byte) (*Systemdunitproperty_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitproperty_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitproperty_objectFromFile loads an element from a file with namespace preservation
func LoadSystemdunitproperty_objectFromFile(path string) (*Systemdunitproperty_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitproperty_objectFromBytes(data)
}

// Apparmorstatus_stateElement represents the XSD element 'apparmorstatus_state'
// XSD element declaration (W3C XSD §3.3)
type Apparmorstatus_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux apparmorstatus_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Loaded_profiles_count represents XSD element 'loaded_profiles_count'
	// minOccurs=0, maxOccurs=1
	Loaded_profiles_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"loaded_profiles_count,omitempty"`
	// Enforce_mode_profiles_count represents XSD element 'enforce_mode_profiles_count'
	// minOccurs=0, maxOccurs=1
	Enforce_mode_profiles_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"enforce_mode_profiles_count,omitempty"`
	// Complain_mode_profiles_count represents XSD element 'complain_mode_profiles_count'
	// minOccurs=0, maxOccurs=1
	Complain_mode_profiles_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"complain_mode_profiles_count,omitempty"`
	// Processes_with_profiles_count represents XSD element 'processes_with_profiles_count'
	// minOccurs=0, maxOccurs=1
	Processes_with_profiles_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"processes_with_profiles_count,omitempty"`
	// Enforce_mode_processes_count represents XSD element 'enforce_mode_processes_count'
	// minOccurs=0, maxOccurs=1
	Enforce_mode_processes_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"enforce_mode_processes_count,omitempty"`
	// Complain_mode_processes_count represents XSD element 'complain_mode_processes_count'
	// minOccurs=0, maxOccurs=1
	Complain_mode_processes_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"complain_mode_processes_count,omitempty"`
	// Unconfined_processes_with_profiles_count represents XSD element 'unconfined_processes_with_profiles_count'
	// minOccurs=0, maxOccurs=1
	Unconfined_processes_with_profiles_count *xmlschemaoval_definitions_5.EntityStateIntType `xml:"unconfined_processes_with_profiles_count,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Apparmorstatus_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Apparmorstatus_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Apparmorstatus_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Apparmorstatus_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Apparmorstatus_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Apparmorstatus_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Apparmorstatus_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Apparmorstatus_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Apparmorstatus_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadApparmorstatus_stateFromBytes loads an element from bytes with namespace preservation
func LoadApparmorstatus_stateFromBytes(data []byte) (*Apparmorstatus_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Apparmorstatus_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadApparmorstatus_stateFromFile loads an element from a file with namespace preservation
func LoadApparmorstatus_stateFromFile(path string) (*Apparmorstatus_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadApparmorstatus_stateFromBytes(data)
}

// Rpminfo_testElement represents the XSD element 'rpminfo_test'
// XSD element declaration (W3C XSD §3.3)
type Rpminfo_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpminfo_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpminfo_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpminfo_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpminfo_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpminfo_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpminfo_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpminfo_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpminfo_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpminfo_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpminfo_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpminfo_testFromBytes loads an element from bytes with namespace preservation
func LoadRpminfo_testFromBytes(data []byte) (*Rpminfo_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpminfo_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpminfo_testFromFile loads an element from a file with namespace preservation
func LoadRpminfo_testFromFile(path string) (*Rpminfo_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpminfo_testFromBytes(data)
}

// Rpmverifyfile_objectElement represents the XSD element 'rpmverifyfile_object'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifyfile_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifyfile_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RpmVerifyFileBehaviors `xml:"behaviors,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Epoch represents XSD element 'epoch'
	Epoch EpochElementType4 `xml:"epoch"`
	// Version represents XSD element 'version'
	Version VersionElementType5 `xml:"version"`
	// Release represents XSD element 'release'
	Release ReleaseElementType4 `xml:"release"`
	// Arch represents XSD element 'arch'
	Arch xmlschemaoval_definitions_5.EntityObjectStringType `xml:"arch"`
	// Filepath represents XSD element 'filepath'
	Filepath xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifyfile_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifyfile_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifyfile_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifyfile_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifyfile_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifyfile_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifyfile_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifyfile_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifyfile_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifyfile_objectFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifyfile_objectFromBytes(data []byte) (*Rpmverifyfile_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifyfile_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifyfile_objectFromFile loads an element from a file with namespace preservation
func LoadRpmverifyfile_objectFromFile(path string) (*Rpmverifyfile_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifyfile_objectFromBytes(data)
}

// Rpmverifyfile_stateElement represents the XSD element 'rpmverifyfile_state'
// XSD element declaration (W3C XSD §3.3)
type Rpmverifyfile_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux rpmverifyfile_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Epoch represents XSD element 'epoch'
	// minOccurs=0, maxOccurs=1
	Epoch *EpochElementType5 `xml:"epoch,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *VersionElementType6 `xml:"version,omitempty"`
	// Release represents XSD element 'release'
	// minOccurs=0, maxOccurs=1
	Release *ReleaseElementType5 `xml:"release,omitempty"`
	// Arch represents XSD element 'arch'
	// minOccurs=0, maxOccurs=1
	Arch *xmlschemaoval_definitions_5.EntityStateStringType `xml:"arch,omitempty"`
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Extended_name represents XSD element 'extended_name'
	// minOccurs=0, maxOccurs=1
	Extended_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"extended_name,omitempty"`
	// Size_differs represents XSD element 'size_differs'
	// minOccurs=0, maxOccurs=1
	Size_differs *EntityStateRpmVerifyResultType `xml:"size_differs,omitempty"`
	// Mode_differs represents XSD element 'mode_differs'
	// minOccurs=0, maxOccurs=1
	Mode_differs *EntityStateRpmVerifyResultType `xml:"mode_differs,omitempty"`
	// Md5_differs represents XSD element 'md5_differs'
	// minOccurs=0, maxOccurs=1
	Md5_differs *EntityStateRpmVerifyResultType `xml:"md5_differs,omitempty"`
	// Filedigest_differs represents XSD element 'filedigest_differs'
	// minOccurs=0, maxOccurs=1
	Filedigest_differs *EntityStateRpmVerifyResultType `xml:"filedigest_differs,omitempty"`
	// Device_differs represents XSD element 'device_differs'
	// minOccurs=0, maxOccurs=1
	Device_differs *EntityStateRpmVerifyResultType `xml:"device_differs,omitempty"`
	// Link_mismatch represents XSD element 'link_mismatch'
	// minOccurs=0, maxOccurs=1
	Link_mismatch *EntityStateRpmVerifyResultType `xml:"link_mismatch,omitempty"`
	// Ownership_differs represents XSD element 'ownership_differs'
	// minOccurs=0, maxOccurs=1
	Ownership_differs *EntityStateRpmVerifyResultType `xml:"ownership_differs,omitempty"`
	// Group_differs represents XSD element 'group_differs'
	// minOccurs=0, maxOccurs=1
	Group_differs *EntityStateRpmVerifyResultType `xml:"group_differs,omitempty"`
	// Mtime_differs represents XSD element 'mtime_differs'
	// minOccurs=0, maxOccurs=1
	Mtime_differs *EntityStateRpmVerifyResultType `xml:"mtime_differs,omitempty"`
	// Capabilities_differ represents XSD element 'capabilities_differ'
	// minOccurs=0, maxOccurs=1
	Capabilities_differ *EntityStateRpmVerifyResultType `xml:"capabilities_differ,omitempty"`
	// Configuration_file represents XSD element 'configuration_file'
	// minOccurs=0, maxOccurs=1
	Configuration_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"configuration_file,omitempty"`
	// Documentation_file represents XSD element 'documentation_file'
	// minOccurs=0, maxOccurs=1
	Documentation_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"documentation_file,omitempty"`
	// Ghost_file represents XSD element 'ghost_file'
	// minOccurs=0, maxOccurs=1
	Ghost_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"ghost_file,omitempty"`
	// License_file represents XSD element 'license_file'
	// minOccurs=0, maxOccurs=1
	License_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"license_file,omitempty"`
	// Readme_file represents XSD element 'readme_file'
	// minOccurs=0, maxOccurs=1
	Readme_file *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"readme_file,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Rpmverifyfile_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Rpmverifyfile_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Rpmverifyfile_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Rpmverifyfile_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Rpmverifyfile_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Rpmverifyfile_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Rpmverifyfile_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Rpmverifyfile_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Rpmverifyfile_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRpmverifyfile_stateFromBytes loads an element from bytes with namespace preservation
func LoadRpmverifyfile_stateFromBytes(data []byte) (*Rpmverifyfile_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Rpmverifyfile_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRpmverifyfile_stateFromFile loads an element from a file with namespace preservation
func LoadRpmverifyfile_stateFromFile(path string) (*Rpmverifyfile_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRpmverifyfile_stateFromBytes(data)
}

// Systemdunitproperty_stateElement represents the XSD element 'systemdunitproperty_state'
// XSD element declaration (W3C XSD §3.3)
type Systemdunitproperty_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#linux systemdunitproperty_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Unit represents XSD element 'unit'
	// minOccurs=0, maxOccurs=1
	Unit *xmlschemaoval_definitions_5.EntityStateStringType `xml:"unit,omitempty"`
	// Property represents XSD element 'property'
	// minOccurs=0, maxOccurs=1
	Property *xmlschemaoval_definitions_5.EntityStateStringType `xml:"property,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemdunitproperty_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemdunitproperty_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemdunitproperty_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemdunitproperty_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemdunitproperty_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemdunitproperty_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemdunitproperty_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemdunitproperty_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemdunitproperty_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemdunitproperty_stateFromBytes loads an element from bytes with namespace preservation
func LoadSystemdunitproperty_stateFromBytes(data []byte) (*Systemdunitproperty_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemdunitproperty_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemdunitproperty_stateFromFile loads an element from a file with namespace preservation
func LoadSystemdunitproperty_stateFromFile(path string) (*Systemdunitproperty_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemdunitproperty_stateFromBytes(data)
}
