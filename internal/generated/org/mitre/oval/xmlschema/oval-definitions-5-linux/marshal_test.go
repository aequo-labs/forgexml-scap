// Package xmlschemaoval_definitions_5_linux - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_linux

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestApparmorstatus_objectElement_MarshalUnmarshal tests XML round-trip for Apparmorstatus_objectElement
func TestApparmorstatus_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestApparmorstatus_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestApparmorstatus_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestApparmorstatus_objectElement_ToBytes tests the ToBytes method
func TestApparmorstatus_objectElement_ToBytes(t *testing.T) {
	elem := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestApparmorstatus_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestApparmorstatus_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestApparmorstatus_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestApparmorstatus_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestApparmorstatus_objectElement_SaveAndLoad tests SaveToFile and LoadApparmorstatus_objectFromFile
func TestApparmorstatus_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Apparmorstatus_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadApparmorstatus_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestApparmorstatus_objectElement_LoadFromBytes tests the LoadApparmorstatus_objectFromBytes function
func TestApparmorstatus_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<apparmorstatus_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></apparmorstatus_object>`)

	loaded, err := LoadApparmorstatus_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestApparmorstatus_objectElementType_MarshalUnmarshal tests XML round-trip for Apparmorstatus_objectElementType
func TestApparmorstatus_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestApparmorstatus_stateElement_MarshalUnmarshal tests XML round-trip for Apparmorstatus_stateElement
func TestApparmorstatus_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestApparmorstatus_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestApparmorstatus_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestApparmorstatus_stateElement_ToBytes tests the ToBytes method
func TestApparmorstatus_stateElement_ToBytes(t *testing.T) {
	elem := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestApparmorstatus_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestApparmorstatus_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestApparmorstatus_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestApparmorstatus_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestApparmorstatus_stateElement_SaveAndLoad tests SaveToFile and LoadApparmorstatus_stateFromFile
func TestApparmorstatus_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Apparmorstatus_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadApparmorstatus_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestApparmorstatus_stateElement_LoadFromBytes tests the LoadApparmorstatus_stateFromBytes function
func TestApparmorstatus_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<apparmorstatus_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></apparmorstatus_state>`)

	loaded, err := LoadApparmorstatus_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestApparmorstatus_stateElementType_MarshalUnmarshal tests XML round-trip for Apparmorstatus_stateElementType
func TestApparmorstatus_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestApparmorstatus_testElement_MarshalUnmarshal tests XML round-trip for Apparmorstatus_testElement
func TestApparmorstatus_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestApparmorstatus_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestApparmorstatus_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestApparmorstatus_testElement_ToBytes tests the ToBytes method
func TestApparmorstatus_testElement_ToBytes(t *testing.T) {
	elem := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestApparmorstatus_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestApparmorstatus_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestApparmorstatus_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestApparmorstatus_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestApparmorstatus_testElement_SaveAndLoad tests SaveToFile and LoadApparmorstatus_testFromFile
func TestApparmorstatus_testElement_SaveAndLoad(t *testing.T) {
	elem := &Apparmorstatus_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "apparmorstatus_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadApparmorstatus_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestApparmorstatus_testElement_LoadFromBytes tests the LoadApparmorstatus_testFromBytes function
func TestApparmorstatus_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<apparmorstatus_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></apparmorstatus_test>`)

	loaded, err := LoadApparmorstatus_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestApparmorstatus_testElementType_MarshalUnmarshal tests XML round-trip for Apparmorstatus_testElementType
func TestApparmorstatus_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Apparmorstatus_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Apparmorstatus_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_objectElement_MarshalUnmarshal tests XML round-trip for Dpkginfo_objectElement
func TestDpkginfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDpkginfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDpkginfo_objectElement_ToBytes tests the ToBytes method
func TestDpkginfo_objectElement_ToBytes(t *testing.T) {
	elem := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDpkginfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDpkginfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDpkginfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDpkginfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDpkginfo_objectElement_SaveAndLoad tests SaveToFile and LoadDpkginfo_objectFromFile
func TestDpkginfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Dpkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDpkginfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDpkginfo_objectElement_LoadFromBytes tests the LoadDpkginfo_objectFromBytes function
func TestDpkginfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dpkginfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></dpkginfo_object>`)

	loaded, err := LoadDpkginfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDpkginfo_objectElementType_MarshalUnmarshal tests XML round-trip for Dpkginfo_objectElementType
func TestDpkginfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_stateElement_MarshalUnmarshal tests XML round-trip for Dpkginfo_stateElement
func TestDpkginfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDpkginfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDpkginfo_stateElement_ToBytes tests the ToBytes method
func TestDpkginfo_stateElement_ToBytes(t *testing.T) {
	elem := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDpkginfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDpkginfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDpkginfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDpkginfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDpkginfo_stateElement_SaveAndLoad tests SaveToFile and LoadDpkginfo_stateFromFile
func TestDpkginfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Dpkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDpkginfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDpkginfo_stateElement_LoadFromBytes tests the LoadDpkginfo_stateFromBytes function
func TestDpkginfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dpkginfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></dpkginfo_state>`)

	loaded, err := LoadDpkginfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDpkginfo_stateElementType_MarshalUnmarshal tests XML round-trip for Dpkginfo_stateElementType
func TestDpkginfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_testElement_MarshalUnmarshal tests XML round-trip for Dpkginfo_testElement
func TestDpkginfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDpkginfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDpkginfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDpkginfo_testElement_ToBytes tests the ToBytes method
func TestDpkginfo_testElement_ToBytes(t *testing.T) {
	elem := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDpkginfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDpkginfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDpkginfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDpkginfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDpkginfo_testElement_SaveAndLoad tests SaveToFile and LoadDpkginfo_testFromFile
func TestDpkginfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Dpkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "dpkginfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDpkginfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDpkginfo_testElement_LoadFromBytes tests the LoadDpkginfo_testFromBytes function
func TestDpkginfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dpkginfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></dpkginfo_test>`)

	loaded, err := LoadDpkginfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDpkginfo_testElementType_MarshalUnmarshal tests XML round-trip for Dpkginfo_testElementType
func TestDpkginfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dpkginfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dpkginfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateProtocolType_MarshalUnmarshal tests XML round-trip for EntityStateProtocolType
func TestEntityStateProtocolType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateProtocolType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateProtocolType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateRpmVerifyResultType_MarshalUnmarshal tests XML round-trip for EntityStateRpmVerifyResultType
func TestEntityStateRpmVerifyResultType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateRpmVerifyResultType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateRpmVerifyResultType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType_MarshalUnmarshal tests XML round-trip for EpochElementType
func TestEpochElementType_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType1_MarshalUnmarshal tests XML round-trip for EpochElementType1
func TestEpochElementType1_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType2_MarshalUnmarshal tests XML round-trip for EpochElementType2
func TestEpochElementType2_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType2{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType2
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType3_MarshalUnmarshal tests XML round-trip for EpochElementType3
func TestEpochElementType3_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType3{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType3
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType4_MarshalUnmarshal tests XML round-trip for EpochElementType4
func TestEpochElementType4_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType4{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType4
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEpochElementType5_MarshalUnmarshal tests XML round-trip for EpochElementType5
func TestEpochElementType5_MarshalUnmarshal(t *testing.T) {
	original := &EpochElementType5{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EpochElementType5
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEvrElementType_MarshalUnmarshal tests XML round-trip for EvrElementType
func TestEvrElementType_MarshalUnmarshal(t *testing.T) {
	original := &EvrElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EvrElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileBehaviors_MarshalUnmarshal tests XML round-trip for FileBehaviors
func TestFileBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_objectElement_MarshalUnmarshal tests XML round-trip for Iflisteners_objectElement
func TestIflisteners_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIflisteners_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIflisteners_objectElement_ToBytes tests the ToBytes method
func TestIflisteners_objectElement_ToBytes(t *testing.T) {
	elem := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIflisteners_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIflisteners_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIflisteners_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIflisteners_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIflisteners_objectElement_SaveAndLoad tests SaveToFile and LoadIflisteners_objectFromFile
func TestIflisteners_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Iflisteners_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIflisteners_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIflisteners_objectElement_LoadFromBytes tests the LoadIflisteners_objectFromBytes function
func TestIflisteners_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<iflisteners_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></iflisteners_object>`)

	loaded, err := LoadIflisteners_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIflisteners_objectElementType_MarshalUnmarshal tests XML round-trip for Iflisteners_objectElementType
func TestIflisteners_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_stateElement_MarshalUnmarshal tests XML round-trip for Iflisteners_stateElement
func TestIflisteners_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIflisteners_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIflisteners_stateElement_ToBytes tests the ToBytes method
func TestIflisteners_stateElement_ToBytes(t *testing.T) {
	elem := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIflisteners_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIflisteners_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIflisteners_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIflisteners_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIflisteners_stateElement_SaveAndLoad tests SaveToFile and LoadIflisteners_stateFromFile
func TestIflisteners_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Iflisteners_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIflisteners_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIflisteners_stateElement_LoadFromBytes tests the LoadIflisteners_stateFromBytes function
func TestIflisteners_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<iflisteners_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></iflisteners_state>`)

	loaded, err := LoadIflisteners_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIflisteners_stateElementType_MarshalUnmarshal tests XML round-trip for Iflisteners_stateElementType
func TestIflisteners_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_testElement_MarshalUnmarshal tests XML round-trip for Iflisteners_testElement
func TestIflisteners_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIflisteners_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIflisteners_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIflisteners_testElement_ToBytes tests the ToBytes method
func TestIflisteners_testElement_ToBytes(t *testing.T) {
	elem := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIflisteners_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIflisteners_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIflisteners_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIflisteners_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIflisteners_testElement_SaveAndLoad tests SaveToFile and LoadIflisteners_testFromFile
func TestIflisteners_testElement_SaveAndLoad(t *testing.T) {
	elem := &Iflisteners_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "iflisteners_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIflisteners_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIflisteners_testElement_LoadFromBytes tests the LoadIflisteners_testFromBytes function
func TestIflisteners_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<iflisteners_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></iflisteners_test>`)

	loaded, err := LoadIflisteners_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIflisteners_testElementType_MarshalUnmarshal tests XML round-trip for Iflisteners_testElementType
func TestIflisteners_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Iflisteners_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Iflisteners_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_objectElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_objectElement
func TestInetlisteningservers_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_objectElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_objectElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_objectElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_objectFromFile
func TestInetlisteningservers_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_objectElement_LoadFromBytes tests the LoadInetlisteningservers_objectFromBytes function
func TestInetlisteningservers_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></inetlisteningservers_object>`)

	loaded, err := LoadInetlisteningservers_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_objectElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_objectElementType
func TestInetlisteningservers_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_stateElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_stateElement
func TestInetlisteningservers_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_stateElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_stateElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_stateElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_stateFromFile
func TestInetlisteningservers_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_stateElement_LoadFromBytes tests the LoadInetlisteningservers_stateFromBytes function
func TestInetlisteningservers_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></inetlisteningservers_state>`)

	loaded, err := LoadInetlisteningservers_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_stateElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_stateElementType
func TestInetlisteningservers_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_testElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_testElement
func TestInetlisteningservers_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_testElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_testElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_testElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_testFromFile
func TestInetlisteningservers_testElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "inetlisteningservers_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_testElement_LoadFromBytes tests the LoadInetlisteningservers_testFromBytes function
func TestInetlisteningservers_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></inetlisteningservers_test>`)

	loaded, err := LoadInetlisteningservers_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_testElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_testElementType
func TestInetlisteningservers_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_objectElement_MarshalUnmarshal tests XML round-trip for Partition_objectElement
func TestPartition_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPartition_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPartition_objectElement_ToBytes tests the ToBytes method
func TestPartition_objectElement_ToBytes(t *testing.T) {
	elem := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPartition_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPartition_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPartition_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPartition_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPartition_objectElement_SaveAndLoad tests SaveToFile and LoadPartition_objectFromFile
func TestPartition_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Partition_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPartition_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPartition_objectElement_LoadFromBytes tests the LoadPartition_objectFromBytes function
func TestPartition_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<partition_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></partition_object>`)

	loaded, err := LoadPartition_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPartition_objectElementType_MarshalUnmarshal tests XML round-trip for Partition_objectElementType
func TestPartition_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Partition_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_stateElement_MarshalUnmarshal tests XML round-trip for Partition_stateElement
func TestPartition_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPartition_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPartition_stateElement_ToBytes tests the ToBytes method
func TestPartition_stateElement_ToBytes(t *testing.T) {
	elem := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPartition_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPartition_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPartition_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPartition_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPartition_stateElement_SaveAndLoad tests SaveToFile and LoadPartition_stateFromFile
func TestPartition_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Partition_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPartition_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPartition_stateElement_LoadFromBytes tests the LoadPartition_stateFromBytes function
func TestPartition_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<partition_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></partition_state>`)

	loaded, err := LoadPartition_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPartition_stateElementType_MarshalUnmarshal tests XML round-trip for Partition_stateElementType
func TestPartition_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Partition_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_testElement_MarshalUnmarshal tests XML round-trip for Partition_testElement
func TestPartition_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPartition_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPartition_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPartition_testElement_ToBytes tests the ToBytes method
func TestPartition_testElement_ToBytes(t *testing.T) {
	elem := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPartition_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPartition_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPartition_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPartition_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPartition_testElement_SaveAndLoad tests SaveToFile and LoadPartition_testFromFile
func TestPartition_testElement_SaveAndLoad(t *testing.T) {
	elem := &Partition_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "partition_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPartition_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPartition_testElement_LoadFromBytes tests the LoadPartition_testFromBytes function
func TestPartition_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<partition_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></partition_test>`)

	loaded, err := LoadPartition_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPartition_testElementType_MarshalUnmarshal tests XML round-trip for Partition_testElementType
func TestPartition_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Partition_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Partition_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType_MarshalUnmarshal tests XML round-trip for ReleaseElementType
func TestReleaseElementType_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType1_MarshalUnmarshal tests XML round-trip for ReleaseElementType1
func TestReleaseElementType1_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType2_MarshalUnmarshal tests XML round-trip for ReleaseElementType2
func TestReleaseElementType2_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType2{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType2
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType3_MarshalUnmarshal tests XML round-trip for ReleaseElementType3
func TestReleaseElementType3_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType3{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType3
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType4_MarshalUnmarshal tests XML round-trip for ReleaseElementType4
func TestReleaseElementType4_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType4{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType4
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReleaseElementType5_MarshalUnmarshal tests XML round-trip for ReleaseElementType5
func TestReleaseElementType5_MarshalUnmarshal(t *testing.T) {
	original := &ReleaseElementType5{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReleaseElementType5
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmInfoBehaviors_MarshalUnmarshal tests XML round-trip for RpmInfoBehaviors
func TestRpmInfoBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RpmInfoBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RpmInfoBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmVerifyBehaviors_MarshalUnmarshal tests XML round-trip for RpmVerifyBehaviors
func TestRpmVerifyBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RpmVerifyBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RpmVerifyBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmVerifyFileBehaviors_MarshalUnmarshal tests XML round-trip for RpmVerifyFileBehaviors
func TestRpmVerifyFileBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RpmVerifyFileBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RpmVerifyFileBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmVerifyPackageBehaviors_MarshalUnmarshal tests XML round-trip for RpmVerifyPackageBehaviors
func TestRpmVerifyPackageBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RpmVerifyPackageBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RpmVerifyPackageBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_objectElement_MarshalUnmarshal tests XML round-trip for Rpminfo_objectElement
func TestRpminfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpminfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpminfo_objectElement_ToBytes tests the ToBytes method
func TestRpminfo_objectElement_ToBytes(t *testing.T) {
	elem := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpminfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpminfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpminfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpminfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpminfo_objectElement_SaveAndLoad tests SaveToFile and LoadRpminfo_objectFromFile
func TestRpminfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Rpminfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpminfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpminfo_objectElement_LoadFromBytes tests the LoadRpminfo_objectFromBytes function
func TestRpminfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpminfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpminfo_object>`)

	loaded, err := LoadRpminfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpminfo_objectElementType_MarshalUnmarshal tests XML round-trip for Rpminfo_objectElementType
func TestRpminfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_stateElement_MarshalUnmarshal tests XML round-trip for Rpminfo_stateElement
func TestRpminfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpminfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpminfo_stateElement_ToBytes tests the ToBytes method
func TestRpminfo_stateElement_ToBytes(t *testing.T) {
	elem := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpminfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpminfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpminfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpminfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpminfo_stateElement_SaveAndLoad tests SaveToFile and LoadRpminfo_stateFromFile
func TestRpminfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Rpminfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpminfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpminfo_stateElement_LoadFromBytes tests the LoadRpminfo_stateFromBytes function
func TestRpminfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpminfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpminfo_state>`)

	loaded, err := LoadRpminfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpminfo_stateElementType_MarshalUnmarshal tests XML round-trip for Rpminfo_stateElementType
func TestRpminfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_testElement_MarshalUnmarshal tests XML round-trip for Rpminfo_testElement
func TestRpminfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpminfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpminfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpminfo_testElement_ToBytes tests the ToBytes method
func TestRpminfo_testElement_ToBytes(t *testing.T) {
	elem := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpminfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpminfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpminfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpminfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpminfo_testElement_SaveAndLoad tests SaveToFile and LoadRpminfo_testFromFile
func TestRpminfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Rpminfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpminfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpminfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpminfo_testElement_LoadFromBytes tests the LoadRpminfo_testFromBytes function
func TestRpminfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpminfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpminfo_test>`)

	loaded, err := LoadRpminfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpminfo_testElementType_MarshalUnmarshal tests XML round-trip for Rpminfo_testElementType
func TestRpminfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpminfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpminfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_objectElement_MarshalUnmarshal tests XML round-trip for Rpmverify_objectElement
func TestRpmverify_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverify_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverify_objectElement_ToBytes tests the ToBytes method
func TestRpmverify_objectElement_ToBytes(t *testing.T) {
	elem := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverify_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverify_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverify_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverify_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverify_objectElement_SaveAndLoad tests SaveToFile and LoadRpmverify_objectFromFile
func TestRpmverify_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverify_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverify_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverify_objectElement_LoadFromBytes tests the LoadRpmverify_objectFromBytes function
func TestRpmverify_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverify_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverify_object>`)

	loaded, err := LoadRpmverify_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverify_objectElementType_MarshalUnmarshal tests XML round-trip for Rpmverify_objectElementType
func TestRpmverify_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_stateElement_MarshalUnmarshal tests XML round-trip for Rpmverify_stateElement
func TestRpmverify_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverify_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverify_stateElement_ToBytes tests the ToBytes method
func TestRpmverify_stateElement_ToBytes(t *testing.T) {
	elem := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverify_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverify_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverify_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverify_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverify_stateElement_SaveAndLoad tests SaveToFile and LoadRpmverify_stateFromFile
func TestRpmverify_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverify_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverify_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverify_stateElement_LoadFromBytes tests the LoadRpmverify_stateFromBytes function
func TestRpmverify_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverify_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverify_state>`)

	loaded, err := LoadRpmverify_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverify_stateElementType_MarshalUnmarshal tests XML round-trip for Rpmverify_stateElementType
func TestRpmverify_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_testElement_MarshalUnmarshal tests XML round-trip for Rpmverify_testElement
func TestRpmverify_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverify_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverify_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverify_testElement_ToBytes tests the ToBytes method
func TestRpmverify_testElement_ToBytes(t *testing.T) {
	elem := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverify_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverify_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverify_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverify_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverify_testElement_SaveAndLoad tests SaveToFile and LoadRpmverify_testFromFile
func TestRpmverify_testElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverify_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverify_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverify_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverify_testElement_LoadFromBytes tests the LoadRpmverify_testFromBytes function
func TestRpmverify_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverify_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverify_test>`)

	loaded, err := LoadRpmverify_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverify_testElementType_MarshalUnmarshal tests XML round-trip for Rpmverify_testElementType
func TestRpmverify_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverify_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverify_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_objectElement_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_objectElement
func TestRpmverifyfile_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifyfile_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifyfile_objectElement_ToBytes tests the ToBytes method
func TestRpmverifyfile_objectElement_ToBytes(t *testing.T) {
	elem := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifyfile_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifyfile_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifyfile_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_objectElement_SaveAndLoad tests SaveToFile and LoadRpmverifyfile_objectFromFile
func TestRpmverifyfile_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifyfile_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifyfile_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifyfile_objectElement_LoadFromBytes tests the LoadRpmverifyfile_objectFromBytes function
func TestRpmverifyfile_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifyfile_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifyfile_object>`)

	loaded, err := LoadRpmverifyfile_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifyfile_objectElementType_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_objectElementType
func TestRpmverifyfile_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_stateElement_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_stateElement
func TestRpmverifyfile_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifyfile_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifyfile_stateElement_ToBytes tests the ToBytes method
func TestRpmverifyfile_stateElement_ToBytes(t *testing.T) {
	elem := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifyfile_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifyfile_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifyfile_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_stateElement_SaveAndLoad tests SaveToFile and LoadRpmverifyfile_stateFromFile
func TestRpmverifyfile_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifyfile_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifyfile_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifyfile_stateElement_LoadFromBytes tests the LoadRpmverifyfile_stateFromBytes function
func TestRpmverifyfile_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifyfile_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifyfile_state>`)

	loaded, err := LoadRpmverifyfile_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifyfile_stateElementType_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_stateElementType
func TestRpmverifyfile_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_testElement_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_testElement
func TestRpmverifyfile_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifyfile_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifyfile_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifyfile_testElement_ToBytes tests the ToBytes method
func TestRpmverifyfile_testElement_ToBytes(t *testing.T) {
	elem := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifyfile_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifyfile_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifyfile_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifyfile_testElement_SaveAndLoad tests SaveToFile and LoadRpmverifyfile_testFromFile
func TestRpmverifyfile_testElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifyfile_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifyfile_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifyfile_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifyfile_testElement_LoadFromBytes tests the LoadRpmverifyfile_testFromBytes function
func TestRpmverifyfile_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifyfile_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifyfile_test>`)

	loaded, err := LoadRpmverifyfile_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifyfile_testElementType_MarshalUnmarshal tests XML round-trip for Rpmverifyfile_testElementType
func TestRpmverifyfile_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifyfile_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifyfile_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_objectElement_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_objectElement
func TestRpmverifypackage_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifypackage_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifypackage_objectElement_ToBytes tests the ToBytes method
func TestRpmverifypackage_objectElement_ToBytes(t *testing.T) {
	elem := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifypackage_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifypackage_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifypackage_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_objectElement_SaveAndLoad tests SaveToFile and LoadRpmverifypackage_objectFromFile
func TestRpmverifypackage_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifypackage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifypackage_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifypackage_objectElement_LoadFromBytes tests the LoadRpmverifypackage_objectFromBytes function
func TestRpmverifypackage_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifypackage_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifypackage_object>`)

	loaded, err := LoadRpmverifypackage_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifypackage_objectElementType_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_objectElementType
func TestRpmverifypackage_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_stateElement_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_stateElement
func TestRpmverifypackage_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifypackage_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifypackage_stateElement_ToBytes tests the ToBytes method
func TestRpmverifypackage_stateElement_ToBytes(t *testing.T) {
	elem := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifypackage_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifypackage_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifypackage_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_stateElement_SaveAndLoad tests SaveToFile and LoadRpmverifypackage_stateFromFile
func TestRpmverifypackage_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifypackage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifypackage_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifypackage_stateElement_LoadFromBytes tests the LoadRpmverifypackage_stateFromBytes function
func TestRpmverifypackage_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifypackage_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifypackage_state>`)

	loaded, err := LoadRpmverifypackage_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifypackage_stateElementType_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_stateElementType
func TestRpmverifypackage_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_testElement_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_testElement
func TestRpmverifypackage_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRpmverifypackage_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRpmverifypackage_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRpmverifypackage_testElement_ToBytes tests the ToBytes method
func TestRpmverifypackage_testElement_ToBytes(t *testing.T) {
	elem := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRpmverifypackage_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRpmverifypackage_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRpmverifypackage_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRpmverifypackage_testElement_SaveAndLoad tests SaveToFile and LoadRpmverifypackage_testFromFile
func TestRpmverifypackage_testElement_SaveAndLoad(t *testing.T) {
	elem := &Rpmverifypackage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "rpmverifypackage_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRpmverifypackage_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRpmverifypackage_testElement_LoadFromBytes tests the LoadRpmverifypackage_testFromBytes function
func TestRpmverifypackage_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rpmverifypackage_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></rpmverifypackage_test>`)

	loaded, err := LoadRpmverifypackage_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRpmverifypackage_testElementType_MarshalUnmarshal tests XML round-trip for Rpmverifypackage_testElementType
func TestRpmverifypackage_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rpmverifypackage_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rpmverifypackage_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_objectElement_MarshalUnmarshal tests XML round-trip for Selinuxboolean_objectElement
func TestSelinuxboolean_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxboolean_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxboolean_objectElement_ToBytes tests the ToBytes method
func TestSelinuxboolean_objectElement_ToBytes(t *testing.T) {
	elem := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxboolean_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxboolean_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxboolean_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_objectElement_SaveAndLoad tests SaveToFile and LoadSelinuxboolean_objectFromFile
func TestSelinuxboolean_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxboolean_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxboolean_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxboolean_objectElement_LoadFromBytes tests the LoadSelinuxboolean_objectFromBytes function
func TestSelinuxboolean_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxboolean_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxboolean_object>`)

	loaded, err := LoadSelinuxboolean_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxboolean_objectElementType_MarshalUnmarshal tests XML round-trip for Selinuxboolean_objectElementType
func TestSelinuxboolean_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_stateElement_MarshalUnmarshal tests XML round-trip for Selinuxboolean_stateElement
func TestSelinuxboolean_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxboolean_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxboolean_stateElement_ToBytes tests the ToBytes method
func TestSelinuxboolean_stateElement_ToBytes(t *testing.T) {
	elem := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxboolean_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxboolean_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxboolean_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_stateElement_SaveAndLoad tests SaveToFile and LoadSelinuxboolean_stateFromFile
func TestSelinuxboolean_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxboolean_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxboolean_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxboolean_stateElement_LoadFromBytes tests the LoadSelinuxboolean_stateFromBytes function
func TestSelinuxboolean_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxboolean_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxboolean_state>`)

	loaded, err := LoadSelinuxboolean_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxboolean_stateElementType_MarshalUnmarshal tests XML round-trip for Selinuxboolean_stateElementType
func TestSelinuxboolean_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_testElement_MarshalUnmarshal tests XML round-trip for Selinuxboolean_testElement
func TestSelinuxboolean_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxboolean_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxboolean_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxboolean_testElement_ToBytes tests the ToBytes method
func TestSelinuxboolean_testElement_ToBytes(t *testing.T) {
	elem := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxboolean_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxboolean_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxboolean_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxboolean_testElement_SaveAndLoad tests SaveToFile and LoadSelinuxboolean_testFromFile
func TestSelinuxboolean_testElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxboolean_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxboolean_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxboolean_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxboolean_testElement_LoadFromBytes tests the LoadSelinuxboolean_testFromBytes function
func TestSelinuxboolean_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxboolean_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxboolean_test>`)

	loaded, err := LoadSelinuxboolean_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxboolean_testElementType_MarshalUnmarshal tests XML round-trip for Selinuxboolean_testElementType
func TestSelinuxboolean_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxboolean_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxboolean_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_objectElement_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_objectElement
func TestSelinuxsecuritycontext_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxsecuritycontext_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxsecuritycontext_objectElement_ToBytes tests the ToBytes method
func TestSelinuxsecuritycontext_objectElement_ToBytes(t *testing.T) {
	elem := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxsecuritycontext_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxsecuritycontext_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxsecuritycontext_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_objectElement_SaveAndLoad tests SaveToFile and LoadSelinuxsecuritycontext_objectFromFile
func TestSelinuxsecuritycontext_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxsecuritycontext_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxsecuritycontext_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxsecuritycontext_objectElement_LoadFromBytes tests the LoadSelinuxsecuritycontext_objectFromBytes function
func TestSelinuxsecuritycontext_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxsecuritycontext_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxsecuritycontext_object>`)

	loaded, err := LoadSelinuxsecuritycontext_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxsecuritycontext_objectElementType_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_objectElementType
func TestSelinuxsecuritycontext_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_stateElement_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_stateElement
func TestSelinuxsecuritycontext_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxsecuritycontext_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxsecuritycontext_stateElement_ToBytes tests the ToBytes method
func TestSelinuxsecuritycontext_stateElement_ToBytes(t *testing.T) {
	elem := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxsecuritycontext_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxsecuritycontext_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxsecuritycontext_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_stateElement_SaveAndLoad tests SaveToFile and LoadSelinuxsecuritycontext_stateFromFile
func TestSelinuxsecuritycontext_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxsecuritycontext_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxsecuritycontext_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxsecuritycontext_stateElement_LoadFromBytes tests the LoadSelinuxsecuritycontext_stateFromBytes function
func TestSelinuxsecuritycontext_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxsecuritycontext_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxsecuritycontext_state>`)

	loaded, err := LoadSelinuxsecuritycontext_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxsecuritycontext_stateElementType_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_stateElementType
func TestSelinuxsecuritycontext_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_testElement_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_testElement
func TestSelinuxsecuritycontext_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSelinuxsecuritycontext_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSelinuxsecuritycontext_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSelinuxsecuritycontext_testElement_ToBytes tests the ToBytes method
func TestSelinuxsecuritycontext_testElement_ToBytes(t *testing.T) {
	elem := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSelinuxsecuritycontext_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSelinuxsecuritycontext_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSelinuxsecuritycontext_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSelinuxsecuritycontext_testElement_SaveAndLoad tests SaveToFile and LoadSelinuxsecuritycontext_testFromFile
func TestSelinuxsecuritycontext_testElement_SaveAndLoad(t *testing.T) {
	elem := &Selinuxsecuritycontext_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "selinuxsecuritycontext_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSelinuxsecuritycontext_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSelinuxsecuritycontext_testElement_LoadFromBytes tests the LoadSelinuxsecuritycontext_testFromBytes function
func TestSelinuxsecuritycontext_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<selinuxsecuritycontext_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></selinuxsecuritycontext_test>`)

	loaded, err := LoadSelinuxsecuritycontext_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSelinuxsecuritycontext_testElementType_MarshalUnmarshal tests XML round-trip for Selinuxsecuritycontext_testElementType
func TestSelinuxsecuritycontext_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Selinuxsecuritycontext_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Selinuxsecuritycontext_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_objectElement_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_objectElement
func TestSlackwarepkginfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSlackwarepkginfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSlackwarepkginfo_objectElement_ToBytes tests the ToBytes method
func TestSlackwarepkginfo_objectElement_ToBytes(t *testing.T) {
	elem := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSlackwarepkginfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSlackwarepkginfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSlackwarepkginfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_objectElement_SaveAndLoad tests SaveToFile and LoadSlackwarepkginfo_objectFromFile
func TestSlackwarepkginfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Slackwarepkginfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSlackwarepkginfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSlackwarepkginfo_objectElement_LoadFromBytes tests the LoadSlackwarepkginfo_objectFromBytes function
func TestSlackwarepkginfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<slackwarepkginfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></slackwarepkginfo_object>`)

	loaded, err := LoadSlackwarepkginfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSlackwarepkginfo_objectElementType_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_objectElementType
func TestSlackwarepkginfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_stateElement_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_stateElement
func TestSlackwarepkginfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSlackwarepkginfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSlackwarepkginfo_stateElement_ToBytes tests the ToBytes method
func TestSlackwarepkginfo_stateElement_ToBytes(t *testing.T) {
	elem := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSlackwarepkginfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSlackwarepkginfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSlackwarepkginfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_stateElement_SaveAndLoad tests SaveToFile and LoadSlackwarepkginfo_stateFromFile
func TestSlackwarepkginfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Slackwarepkginfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSlackwarepkginfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSlackwarepkginfo_stateElement_LoadFromBytes tests the LoadSlackwarepkginfo_stateFromBytes function
func TestSlackwarepkginfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<slackwarepkginfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></slackwarepkginfo_state>`)

	loaded, err := LoadSlackwarepkginfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSlackwarepkginfo_stateElementType_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_stateElementType
func TestSlackwarepkginfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_testElement_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_testElement
func TestSlackwarepkginfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSlackwarepkginfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSlackwarepkginfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSlackwarepkginfo_testElement_ToBytes tests the ToBytes method
func TestSlackwarepkginfo_testElement_ToBytes(t *testing.T) {
	elem := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSlackwarepkginfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSlackwarepkginfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSlackwarepkginfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSlackwarepkginfo_testElement_SaveAndLoad tests SaveToFile and LoadSlackwarepkginfo_testFromFile
func TestSlackwarepkginfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Slackwarepkginfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "slackwarepkginfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSlackwarepkginfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSlackwarepkginfo_testElement_LoadFromBytes tests the LoadSlackwarepkginfo_testFromBytes function
func TestSlackwarepkginfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<slackwarepkginfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></slackwarepkginfo_test>`)

	loaded, err := LoadSlackwarepkginfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSlackwarepkginfo_testElementType_MarshalUnmarshal tests XML round-trip for Slackwarepkginfo_testElementType
func TestSlackwarepkginfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Slackwarepkginfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Slackwarepkginfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_objectElement_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_objectElement
func TestSystemdunitdependency_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitdependency_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitdependency_objectElement_ToBytes tests the ToBytes method
func TestSystemdunitdependency_objectElement_ToBytes(t *testing.T) {
	elem := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitdependency_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitdependency_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitdependency_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_objectElement_SaveAndLoad tests SaveToFile and LoadSystemdunitdependency_objectFromFile
func TestSystemdunitdependency_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitdependency_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitdependency_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitdependency_objectElement_LoadFromBytes tests the LoadSystemdunitdependency_objectFromBytes function
func TestSystemdunitdependency_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitdependency_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitdependency_object>`)

	loaded, err := LoadSystemdunitdependency_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitdependency_objectElementType_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_objectElementType
func TestSystemdunitdependency_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_stateElement_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_stateElement
func TestSystemdunitdependency_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitdependency_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitdependency_stateElement_ToBytes tests the ToBytes method
func TestSystemdunitdependency_stateElement_ToBytes(t *testing.T) {
	elem := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitdependency_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitdependency_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitdependency_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_stateElement_SaveAndLoad tests SaveToFile and LoadSystemdunitdependency_stateFromFile
func TestSystemdunitdependency_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitdependency_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitdependency_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitdependency_stateElement_LoadFromBytes tests the LoadSystemdunitdependency_stateFromBytes function
func TestSystemdunitdependency_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitdependency_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitdependency_state>`)

	loaded, err := LoadSystemdunitdependency_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitdependency_stateElementType_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_stateElementType
func TestSystemdunitdependency_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_testElement_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_testElement
func TestSystemdunitdependency_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitdependency_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitdependency_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitdependency_testElement_ToBytes tests the ToBytes method
func TestSystemdunitdependency_testElement_ToBytes(t *testing.T) {
	elem := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitdependency_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitdependency_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitdependency_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitdependency_testElement_SaveAndLoad tests SaveToFile and LoadSystemdunitdependency_testFromFile
func TestSystemdunitdependency_testElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitdependency_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitdependency_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitdependency_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitdependency_testElement_LoadFromBytes tests the LoadSystemdunitdependency_testFromBytes function
func TestSystemdunitdependency_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitdependency_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitdependency_test>`)

	loaded, err := LoadSystemdunitdependency_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitdependency_testElementType_MarshalUnmarshal tests XML round-trip for Systemdunitdependency_testElementType
func TestSystemdunitdependency_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitdependency_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitdependency_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_objectElement_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_objectElement
func TestSystemdunitproperty_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitproperty_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitproperty_objectElement_ToBytes tests the ToBytes method
func TestSystemdunitproperty_objectElement_ToBytes(t *testing.T) {
	elem := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitproperty_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitproperty_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitproperty_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_objectElement_SaveAndLoad tests SaveToFile and LoadSystemdunitproperty_objectFromFile
func TestSystemdunitproperty_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitproperty_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitproperty_objectElement_LoadFromBytes tests the LoadSystemdunitproperty_objectFromBytes function
func TestSystemdunitproperty_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitproperty_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitproperty_object>`)

	loaded, err := LoadSystemdunitproperty_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitproperty_objectElementType_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_objectElementType
func TestSystemdunitproperty_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_stateElement_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_stateElement
func TestSystemdunitproperty_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitproperty_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitproperty_stateElement_ToBytes tests the ToBytes method
func TestSystemdunitproperty_stateElement_ToBytes(t *testing.T) {
	elem := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitproperty_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitproperty_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitproperty_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_stateElement_SaveAndLoad tests SaveToFile and LoadSystemdunitproperty_stateFromFile
func TestSystemdunitproperty_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitproperty_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitproperty_stateElement_LoadFromBytes tests the LoadSystemdunitproperty_stateFromBytes function
func TestSystemdunitproperty_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitproperty_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitproperty_state>`)

	loaded, err := LoadSystemdunitproperty_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitproperty_stateElementType_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_stateElementType
func TestSystemdunitproperty_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_testElement_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_testElement
func TestSystemdunitproperty_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemdunitproperty_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemdunitproperty_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemdunitproperty_testElement_ToBytes tests the ToBytes method
func TestSystemdunitproperty_testElement_ToBytes(t *testing.T) {
	elem := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemdunitproperty_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemdunitproperty_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemdunitproperty_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemdunitproperty_testElement_SaveAndLoad tests SaveToFile and LoadSystemdunitproperty_testFromFile
func TestSystemdunitproperty_testElement_SaveAndLoad(t *testing.T) {
	elem := &Systemdunitproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#linux", Local: "systemdunitproperty_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemdunitproperty_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemdunitproperty_testElement_LoadFromBytes tests the LoadSystemdunitproperty_testFromBytes function
func TestSystemdunitproperty_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemdunitproperty_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#linux"></systemdunitproperty_test>`)

	loaded, err := LoadSystemdunitproperty_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemdunitproperty_testElementType_MarshalUnmarshal tests XML round-trip for Systemdunitproperty_testElementType
func TestSystemdunitproperty_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemdunitproperty_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemdunitproperty_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType_MarshalUnmarshal tests XML round-trip for VersionElementType
func TestVersionElementType_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType1_MarshalUnmarshal tests XML round-trip for VersionElementType1
func TestVersionElementType1_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType2_MarshalUnmarshal tests XML round-trip for VersionElementType2
func TestVersionElementType2_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType2{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType2
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType3_MarshalUnmarshal tests XML round-trip for VersionElementType3
func TestVersionElementType3_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType3{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType3
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType4_MarshalUnmarshal tests XML round-trip for VersionElementType4
func TestVersionElementType4_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType4{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType4
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType5_MarshalUnmarshal tests XML round-trip for VersionElementType5
func TestVersionElementType5_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType5{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType5
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVersionElementType6_MarshalUnmarshal tests XML round-trip for VersionElementType6
func TestVersionElementType6_MarshalUnmarshal(t *testing.T) {
	original := &VersionElementType6{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VersionElementType6
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
