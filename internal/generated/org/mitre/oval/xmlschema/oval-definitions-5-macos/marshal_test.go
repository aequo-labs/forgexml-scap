// Package xmlschemaoval_definitions_5_macos - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_macos

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestAccountinfo_objectElement_MarshalUnmarshal tests XML round-trip for Accountinfo_objectElement
func TestAccountinfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccountinfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccountinfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccountinfo_objectElement_ToBytes tests the ToBytes method
func TestAccountinfo_objectElement_ToBytes(t *testing.T) {
	elem := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccountinfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccountinfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccountinfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccountinfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccountinfo_objectElement_SaveAndLoad tests SaveToFile and LoadAccountinfo_objectFromFile
func TestAccountinfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Accountinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccountinfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccountinfo_objectElement_LoadFromBytes tests the LoadAccountinfo_objectFromBytes function
func TestAccountinfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accountinfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></accountinfo_object>`)

	loaded, err := LoadAccountinfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccountinfo_objectElementType_MarshalUnmarshal tests XML round-trip for Accountinfo_objectElementType
func TestAccountinfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccountinfo_stateElement_MarshalUnmarshal tests XML round-trip for Accountinfo_stateElement
func TestAccountinfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccountinfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccountinfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccountinfo_stateElement_ToBytes tests the ToBytes method
func TestAccountinfo_stateElement_ToBytes(t *testing.T) {
	elem := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccountinfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccountinfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccountinfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccountinfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccountinfo_stateElement_SaveAndLoad tests SaveToFile and LoadAccountinfo_stateFromFile
func TestAccountinfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Accountinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccountinfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccountinfo_stateElement_LoadFromBytes tests the LoadAccountinfo_stateFromBytes function
func TestAccountinfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accountinfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></accountinfo_state>`)

	loaded, err := LoadAccountinfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccountinfo_stateElementType_MarshalUnmarshal tests XML round-trip for Accountinfo_stateElementType
func TestAccountinfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccountinfo_testElement_MarshalUnmarshal tests XML round-trip for Accountinfo_testElement
func TestAccountinfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccountinfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccountinfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccountinfo_testElement_ToBytes tests the ToBytes method
func TestAccountinfo_testElement_ToBytes(t *testing.T) {
	elem := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccountinfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccountinfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccountinfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccountinfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccountinfo_testElement_SaveAndLoad tests SaveToFile and LoadAccountinfo_testFromFile
func TestAccountinfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Accountinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "accountinfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccountinfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccountinfo_testElement_LoadFromBytes tests the LoadAccountinfo_testFromBytes function
func TestAccountinfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accountinfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></accountinfo_test>`)

	loaded, err := LoadAccountinfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccountinfo_testElementType_MarshalUnmarshal tests XML round-trip for Accountinfo_testElementType
func TestAccountinfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accountinfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accountinfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_objectElement_MarshalUnmarshal tests XML round-trip for Authorizationdb_objectElement
func TestAuthorizationdb_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuthorizationdb_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuthorizationdb_objectElement_ToBytes tests the ToBytes method
func TestAuthorizationdb_objectElement_ToBytes(t *testing.T) {
	elem := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuthorizationdb_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuthorizationdb_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuthorizationdb_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_objectElement_SaveAndLoad tests SaveToFile and LoadAuthorizationdb_objectFromFile
func TestAuthorizationdb_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Authorizationdb_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuthorizationdb_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuthorizationdb_objectElement_LoadFromBytes tests the LoadAuthorizationdb_objectFromBytes function
func TestAuthorizationdb_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<authorizationdb_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></authorizationdb_object>`)

	loaded, err := LoadAuthorizationdb_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuthorizationdb_objectElementType_MarshalUnmarshal tests XML round-trip for Authorizationdb_objectElementType
func TestAuthorizationdb_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_stateElement_MarshalUnmarshal tests XML round-trip for Authorizationdb_stateElement
func TestAuthorizationdb_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuthorizationdb_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuthorizationdb_stateElement_ToBytes tests the ToBytes method
func TestAuthorizationdb_stateElement_ToBytes(t *testing.T) {
	elem := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuthorizationdb_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuthorizationdb_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuthorizationdb_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_stateElement_SaveAndLoad tests SaveToFile and LoadAuthorizationdb_stateFromFile
func TestAuthorizationdb_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Authorizationdb_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuthorizationdb_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuthorizationdb_stateElement_LoadFromBytes tests the LoadAuthorizationdb_stateFromBytes function
func TestAuthorizationdb_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<authorizationdb_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></authorizationdb_state>`)

	loaded, err := LoadAuthorizationdb_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuthorizationdb_stateElementType_MarshalUnmarshal tests XML round-trip for Authorizationdb_stateElementType
func TestAuthorizationdb_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_testElement_MarshalUnmarshal tests XML round-trip for Authorizationdb_testElement
func TestAuthorizationdb_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuthorizationdb_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuthorizationdb_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuthorizationdb_testElement_ToBytes tests the ToBytes method
func TestAuthorizationdb_testElement_ToBytes(t *testing.T) {
	elem := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuthorizationdb_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuthorizationdb_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuthorizationdb_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuthorizationdb_testElement_SaveAndLoad tests SaveToFile and LoadAuthorizationdb_testFromFile
func TestAuthorizationdb_testElement_SaveAndLoad(t *testing.T) {
	elem := &Authorizationdb_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "authorizationdb_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuthorizationdb_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuthorizationdb_testElement_LoadFromBytes tests the LoadAuthorizationdb_testFromBytes function
func TestAuthorizationdb_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<authorizationdb_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></authorizationdb_test>`)

	loaded, err := LoadAuthorizationdb_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuthorizationdb_testElementType_MarshalUnmarshal tests XML round-trip for Authorizationdb_testElementType
func TestAuthorizationdb_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Authorizationdb_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Authorizationdb_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_objectElement_MarshalUnmarshal tests XML round-trip for Corestorage_objectElement
func TestCorestorage_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCorestorage_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCorestorage_objectElement_ToBytes tests the ToBytes method
func TestCorestorage_objectElement_ToBytes(t *testing.T) {
	elem := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCorestorage_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCorestorage_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCorestorage_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCorestorage_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCorestorage_objectElement_SaveAndLoad tests SaveToFile and LoadCorestorage_objectFromFile
func TestCorestorage_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Corestorage_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCorestorage_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCorestorage_objectElement_LoadFromBytes tests the LoadCorestorage_objectFromBytes function
func TestCorestorage_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<corestorage_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></corestorage_object>`)

	loaded, err := LoadCorestorage_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCorestorage_objectElementType_MarshalUnmarshal tests XML round-trip for Corestorage_objectElementType
func TestCorestorage_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_stateElement_MarshalUnmarshal tests XML round-trip for Corestorage_stateElement
func TestCorestorage_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCorestorage_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCorestorage_stateElement_ToBytes tests the ToBytes method
func TestCorestorage_stateElement_ToBytes(t *testing.T) {
	elem := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCorestorage_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCorestorage_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCorestorage_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCorestorage_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCorestorage_stateElement_SaveAndLoad tests SaveToFile and LoadCorestorage_stateFromFile
func TestCorestorage_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Corestorage_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCorestorage_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCorestorage_stateElement_LoadFromBytes tests the LoadCorestorage_stateFromBytes function
func TestCorestorage_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<corestorage_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></corestorage_state>`)

	loaded, err := LoadCorestorage_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCorestorage_stateElementType_MarshalUnmarshal tests XML round-trip for Corestorage_stateElementType
func TestCorestorage_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_testElement_MarshalUnmarshal tests XML round-trip for Corestorage_testElement
func TestCorestorage_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCorestorage_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCorestorage_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCorestorage_testElement_ToBytes tests the ToBytes method
func TestCorestorage_testElement_ToBytes(t *testing.T) {
	elem := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCorestorage_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCorestorage_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCorestorage_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCorestorage_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCorestorage_testElement_SaveAndLoad tests SaveToFile and LoadCorestorage_testFromFile
func TestCorestorage_testElement_SaveAndLoad(t *testing.T) {
	elem := &Corestorage_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "corestorage_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCorestorage_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCorestorage_testElement_LoadFromBytes tests the LoadCorestorage_testFromBytes function
func TestCorestorage_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<corestorage_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></corestorage_test>`)

	loaded, err := LoadCorestorage_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCorestorage_testElementType_MarshalUnmarshal tests XML round-trip for Corestorage_testElementType
func TestCorestorage_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Corestorage_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Corestorage_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_objectElement_MarshalUnmarshal tests XML round-trip for Diskutil_objectElement
func TestDiskutil_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDiskutil_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDiskutil_objectElement_ToBytes tests the ToBytes method
func TestDiskutil_objectElement_ToBytes(t *testing.T) {
	elem := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDiskutil_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDiskutil_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDiskutil_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDiskutil_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDiskutil_objectElement_SaveAndLoad tests SaveToFile and LoadDiskutil_objectFromFile
func TestDiskutil_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Diskutil_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDiskutil_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDiskutil_objectElement_LoadFromBytes tests the LoadDiskutil_objectFromBytes function
func TestDiskutil_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<diskutil_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></diskutil_object>`)

	loaded, err := LoadDiskutil_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDiskutil_objectElementType_MarshalUnmarshal tests XML round-trip for Diskutil_objectElementType
func TestDiskutil_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_stateElement_MarshalUnmarshal tests XML round-trip for Diskutil_stateElement
func TestDiskutil_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDiskutil_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDiskutil_stateElement_ToBytes tests the ToBytes method
func TestDiskutil_stateElement_ToBytes(t *testing.T) {
	elem := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDiskutil_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDiskutil_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDiskutil_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDiskutil_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDiskutil_stateElement_SaveAndLoad tests SaveToFile and LoadDiskutil_stateFromFile
func TestDiskutil_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Diskutil_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDiskutil_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDiskutil_stateElement_LoadFromBytes tests the LoadDiskutil_stateFromBytes function
func TestDiskutil_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<diskutil_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></diskutil_state>`)

	loaded, err := LoadDiskutil_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDiskutil_stateElementType_MarshalUnmarshal tests XML round-trip for Diskutil_stateElementType
func TestDiskutil_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_testElement_MarshalUnmarshal tests XML round-trip for Diskutil_testElement
func TestDiskutil_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDiskutil_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDiskutil_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDiskutil_testElement_ToBytes tests the ToBytes method
func TestDiskutil_testElement_ToBytes(t *testing.T) {
	elem := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDiskutil_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDiskutil_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDiskutil_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDiskutil_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDiskutil_testElement_SaveAndLoad tests SaveToFile and LoadDiskutil_testFromFile
func TestDiskutil_testElement_SaveAndLoad(t *testing.T) {
	elem := &Diskutil_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "diskutil_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDiskutil_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDiskutil_testElement_LoadFromBytes tests the LoadDiskutil_testFromBytes function
func TestDiskutil_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<diskutil_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></diskutil_test>`)

	loaded, err := LoadDiskutil_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDiskutil_testElementType_MarshalUnmarshal tests XML round-trip for Diskutil_testElementType
func TestDiskutil_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Diskutil_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Diskutil_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectDataTypeType_MarshalUnmarshal tests XML round-trip for EntityObjectDataTypeType
func TestEntityObjectDataTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectDataTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectDataTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateDataTypeType_MarshalUnmarshal tests XML round-trip for EntityStateDataTypeType
func TestEntityStateDataTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateDataTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateDataTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePermissionCompareType_MarshalUnmarshal tests XML round-trip for EntityStatePermissionCompareType
func TestEntityStatePermissionCompareType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePermissionCompareType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePermissionCompareType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePlistTypeType_MarshalUnmarshal tests XML round-trip for EntityStatePlistTypeType
func TestEntityStatePlistTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePlistTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePlistTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_objectElement_MarshalUnmarshal tests XML round-trip for Gatekeeper_objectElement
func TestGatekeeper_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGatekeeper_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGatekeeper_objectElement_ToBytes tests the ToBytes method
func TestGatekeeper_objectElement_ToBytes(t *testing.T) {
	elem := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGatekeeper_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGatekeeper_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGatekeeper_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGatekeeper_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGatekeeper_objectElement_SaveAndLoad tests SaveToFile and LoadGatekeeper_objectFromFile
func TestGatekeeper_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Gatekeeper_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGatekeeper_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGatekeeper_objectElement_LoadFromBytes tests the LoadGatekeeper_objectFromBytes function
func TestGatekeeper_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gatekeeper_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></gatekeeper_object>`)

	loaded, err := LoadGatekeeper_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGatekeeper_objectElementType_MarshalUnmarshal tests XML round-trip for Gatekeeper_objectElementType
func TestGatekeeper_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_stateElement_MarshalUnmarshal tests XML round-trip for Gatekeeper_stateElement
func TestGatekeeper_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGatekeeper_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGatekeeper_stateElement_ToBytes tests the ToBytes method
func TestGatekeeper_stateElement_ToBytes(t *testing.T) {
	elem := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGatekeeper_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGatekeeper_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGatekeeper_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGatekeeper_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGatekeeper_stateElement_SaveAndLoad tests SaveToFile and LoadGatekeeper_stateFromFile
func TestGatekeeper_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Gatekeeper_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGatekeeper_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGatekeeper_stateElement_LoadFromBytes tests the LoadGatekeeper_stateFromBytes function
func TestGatekeeper_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gatekeeper_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></gatekeeper_state>`)

	loaded, err := LoadGatekeeper_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGatekeeper_stateElementType_MarshalUnmarshal tests XML round-trip for Gatekeeper_stateElementType
func TestGatekeeper_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_testElement_MarshalUnmarshal tests XML round-trip for Gatekeeper_testElement
func TestGatekeeper_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGatekeeper_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGatekeeper_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGatekeeper_testElement_ToBytes tests the ToBytes method
func TestGatekeeper_testElement_ToBytes(t *testing.T) {
	elem := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGatekeeper_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGatekeeper_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGatekeeper_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGatekeeper_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGatekeeper_testElement_SaveAndLoad tests SaveToFile and LoadGatekeeper_testFromFile
func TestGatekeeper_testElement_SaveAndLoad(t *testing.T) {
	elem := &Gatekeeper_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "gatekeeper_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGatekeeper_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGatekeeper_testElement_LoadFromBytes tests the LoadGatekeeper_testFromBytes function
func TestGatekeeper_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gatekeeper_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></gatekeeper_test>`)

	loaded, err := LoadGatekeeper_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGatekeeper_testElementType_MarshalUnmarshal tests XML round-trip for Gatekeeper_testElementType
func TestGatekeeper_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gatekeeper_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gatekeeper_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_objectElement_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_objectElement
func TestInetlisteningserver510_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningserver510_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningserver510_objectElement_ToBytes tests the ToBytes method
func TestInetlisteningserver510_objectElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningserver510_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningserver510_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningserver510_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_objectElement_SaveAndLoad tests SaveToFile and LoadInetlisteningserver510_objectFromFile
func TestInetlisteningserver510_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningserver510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningserver510_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningserver510_objectElement_LoadFromBytes tests the LoadInetlisteningserver510_objectFromBytes function
func TestInetlisteningserver510_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningserver510_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningserver510_object>`)

	loaded, err := LoadInetlisteningserver510_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningserver510_objectElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_objectElementType
func TestInetlisteningserver510_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_stateElement_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_stateElement
func TestInetlisteningserver510_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningserver510_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningserver510_stateElement_ToBytes tests the ToBytes method
func TestInetlisteningserver510_stateElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningserver510_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningserver510_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningserver510_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_stateElement_SaveAndLoad tests SaveToFile and LoadInetlisteningserver510_stateFromFile
func TestInetlisteningserver510_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningserver510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningserver510_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningserver510_stateElement_LoadFromBytes tests the LoadInetlisteningserver510_stateFromBytes function
func TestInetlisteningserver510_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningserver510_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningserver510_state>`)

	loaded, err := LoadInetlisteningserver510_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningserver510_stateElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_stateElementType
func TestInetlisteningserver510_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_testElement_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_testElement
func TestInetlisteningserver510_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningserver510_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningserver510_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningserver510_testElement_ToBytes tests the ToBytes method
func TestInetlisteningserver510_testElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningserver510_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningserver510_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningserver510_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningserver510_testElement_SaveAndLoad tests SaveToFile and LoadInetlisteningserver510_testFromFile
func TestInetlisteningserver510_testElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningserver510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningserver510_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningserver510_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningserver510_testElement_LoadFromBytes tests the LoadInetlisteningserver510_testFromBytes function
func TestInetlisteningserver510_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningserver510_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningserver510_test>`)

	loaded, err := LoadInetlisteningserver510_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningserver510_testElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningserver510_testElementType
func TestInetlisteningserver510_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningserver510_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningserver510_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_objectElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_objectElement
func TestInetlisteningservers_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_objectElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_objectElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_objectElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_objectFromFile
func TestInetlisteningservers_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_objectElement_LoadFromBytes tests the LoadInetlisteningservers_objectFromBytes function
func TestInetlisteningservers_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningservers_object>`)

	loaded, err := LoadInetlisteningservers_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_objectElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_objectElementType
func TestInetlisteningservers_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_stateElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_stateElement
func TestInetlisteningservers_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_stateElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_stateElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_stateElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_stateFromFile
func TestInetlisteningservers_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_stateElement_LoadFromBytes tests the LoadInetlisteningservers_stateFromBytes function
func TestInetlisteningservers_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningservers_state>`)

	loaded, err := LoadInetlisteningservers_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_stateElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_stateElementType
func TestInetlisteningservers_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_testElement_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_testElement
func TestInetlisteningservers_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetlisteningservers_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetlisteningservers_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetlisteningservers_testElement_ToBytes tests the ToBytes method
func TestInetlisteningservers_testElement_ToBytes(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetlisteningservers_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetlisteningservers_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetlisteningservers_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetlisteningservers_testElement_SaveAndLoad tests SaveToFile and LoadInetlisteningservers_testFromFile
func TestInetlisteningservers_testElement_SaveAndLoad(t *testing.T) {
	elem := &Inetlisteningservers_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "inetlisteningservers_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetlisteningservers_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetlisteningservers_testElement_LoadFromBytes tests the LoadInetlisteningservers_testFromBytes function
func TestInetlisteningservers_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetlisteningservers_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></inetlisteningservers_test>`)

	loaded, err := LoadInetlisteningservers_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetlisteningservers_testElementType_MarshalUnmarshal tests XML round-trip for Inetlisteningservers_testElementType
func TestInetlisteningservers_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetlisteningservers_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetlisteningservers_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_objectElement_MarshalUnmarshal tests XML round-trip for Keychain_objectElement
func TestKeychain_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestKeychain_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestKeychain_objectElement_ToBytes tests the ToBytes method
func TestKeychain_objectElement_ToBytes(t *testing.T) {
	elem := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestKeychain_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestKeychain_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestKeychain_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestKeychain_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestKeychain_objectElement_SaveAndLoad tests SaveToFile and LoadKeychain_objectFromFile
func TestKeychain_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Keychain_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadKeychain_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestKeychain_objectElement_LoadFromBytes tests the LoadKeychain_objectFromBytes function
func TestKeychain_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<keychain_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></keychain_object>`)

	loaded, err := LoadKeychain_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestKeychain_objectElementType_MarshalUnmarshal tests XML round-trip for Keychain_objectElementType
func TestKeychain_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_stateElement_MarshalUnmarshal tests XML round-trip for Keychain_stateElement
func TestKeychain_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestKeychain_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestKeychain_stateElement_ToBytes tests the ToBytes method
func TestKeychain_stateElement_ToBytes(t *testing.T) {
	elem := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestKeychain_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestKeychain_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestKeychain_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestKeychain_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestKeychain_stateElement_SaveAndLoad tests SaveToFile and LoadKeychain_stateFromFile
func TestKeychain_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Keychain_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadKeychain_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestKeychain_stateElement_LoadFromBytes tests the LoadKeychain_stateFromBytes function
func TestKeychain_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<keychain_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></keychain_state>`)

	loaded, err := LoadKeychain_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestKeychain_stateElementType_MarshalUnmarshal tests XML round-trip for Keychain_stateElementType
func TestKeychain_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_testElement_MarshalUnmarshal tests XML round-trip for Keychain_testElement
func TestKeychain_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestKeychain_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestKeychain_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestKeychain_testElement_ToBytes tests the ToBytes method
func TestKeychain_testElement_ToBytes(t *testing.T) {
	elem := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestKeychain_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestKeychain_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestKeychain_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestKeychain_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestKeychain_testElement_SaveAndLoad tests SaveToFile and LoadKeychain_testFromFile
func TestKeychain_testElement_SaveAndLoad(t *testing.T) {
	elem := &Keychain_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "keychain_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadKeychain_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestKeychain_testElement_LoadFromBytes tests the LoadKeychain_testFromBytes function
func TestKeychain_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<keychain_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></keychain_test>`)

	loaded, err := LoadKeychain_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestKeychain_testElementType_MarshalUnmarshal tests XML round-trip for Keychain_testElementType
func TestKeychain_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Keychain_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Keychain_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_objectElement_MarshalUnmarshal tests XML round-trip for Launchd_objectElement
func TestLaunchd_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLaunchd_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLaunchd_objectElement_ToBytes tests the ToBytes method
func TestLaunchd_objectElement_ToBytes(t *testing.T) {
	elem := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLaunchd_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLaunchd_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLaunchd_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLaunchd_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLaunchd_objectElement_SaveAndLoad tests SaveToFile and LoadLaunchd_objectFromFile
func TestLaunchd_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Launchd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLaunchd_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLaunchd_objectElement_LoadFromBytes tests the LoadLaunchd_objectFromBytes function
func TestLaunchd_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<launchd_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></launchd_object>`)

	loaded, err := LoadLaunchd_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLaunchd_objectElementType_MarshalUnmarshal tests XML round-trip for Launchd_objectElementType
func TestLaunchd_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_stateElement_MarshalUnmarshal tests XML round-trip for Launchd_stateElement
func TestLaunchd_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLaunchd_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLaunchd_stateElement_ToBytes tests the ToBytes method
func TestLaunchd_stateElement_ToBytes(t *testing.T) {
	elem := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLaunchd_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLaunchd_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLaunchd_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLaunchd_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLaunchd_stateElement_SaveAndLoad tests SaveToFile and LoadLaunchd_stateFromFile
func TestLaunchd_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Launchd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLaunchd_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLaunchd_stateElement_LoadFromBytes tests the LoadLaunchd_stateFromBytes function
func TestLaunchd_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<launchd_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></launchd_state>`)

	loaded, err := LoadLaunchd_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLaunchd_stateElementType_MarshalUnmarshal tests XML round-trip for Launchd_stateElementType
func TestLaunchd_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_testElement_MarshalUnmarshal tests XML round-trip for Launchd_testElement
func TestLaunchd_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLaunchd_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLaunchd_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLaunchd_testElement_ToBytes tests the ToBytes method
func TestLaunchd_testElement_ToBytes(t *testing.T) {
	elem := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLaunchd_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLaunchd_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLaunchd_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLaunchd_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLaunchd_testElement_SaveAndLoad tests SaveToFile and LoadLaunchd_testFromFile
func TestLaunchd_testElement_SaveAndLoad(t *testing.T) {
	elem := &Launchd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "launchd_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLaunchd_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLaunchd_testElement_LoadFromBytes tests the LoadLaunchd_testFromBytes function
func TestLaunchd_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<launchd_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></launchd_test>`)

	loaded, err := LoadLaunchd_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLaunchd_testElementType_MarshalUnmarshal tests XML round-trip for Launchd_testElementType
func TestLaunchd_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Launchd_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Launchd_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_objectElement_MarshalUnmarshal tests XML round-trip for Nvram_objectElement
func TestNvram_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNvram_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNvram_objectElement_ToBytes tests the ToBytes method
func TestNvram_objectElement_ToBytes(t *testing.T) {
	elem := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNvram_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNvram_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNvram_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNvram_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNvram_objectElement_SaveAndLoad tests SaveToFile and LoadNvram_objectFromFile
func TestNvram_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Nvram_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNvram_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNvram_objectElement_LoadFromBytes tests the LoadNvram_objectFromBytes function
func TestNvram_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<nvram_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></nvram_object>`)

	loaded, err := LoadNvram_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNvram_objectElementType_MarshalUnmarshal tests XML round-trip for Nvram_objectElementType
func TestNvram_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_stateElement_MarshalUnmarshal tests XML round-trip for Nvram_stateElement
func TestNvram_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNvram_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNvram_stateElement_ToBytes tests the ToBytes method
func TestNvram_stateElement_ToBytes(t *testing.T) {
	elem := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNvram_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNvram_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNvram_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNvram_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNvram_stateElement_SaveAndLoad tests SaveToFile and LoadNvram_stateFromFile
func TestNvram_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Nvram_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNvram_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNvram_stateElement_LoadFromBytes tests the LoadNvram_stateFromBytes function
func TestNvram_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<nvram_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></nvram_state>`)

	loaded, err := LoadNvram_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNvram_stateElementType_MarshalUnmarshal tests XML round-trip for Nvram_stateElementType
func TestNvram_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_testElement_MarshalUnmarshal tests XML round-trip for Nvram_testElement
func TestNvram_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNvram_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNvram_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNvram_testElement_ToBytes tests the ToBytes method
func TestNvram_testElement_ToBytes(t *testing.T) {
	elem := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNvram_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNvram_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNvram_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNvram_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNvram_testElement_SaveAndLoad tests SaveToFile and LoadNvram_testFromFile
func TestNvram_testElement_SaveAndLoad(t *testing.T) {
	elem := &Nvram_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "nvram_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNvram_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNvram_testElement_LoadFromBytes tests the LoadNvram_testFromBytes function
func TestNvram_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<nvram_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></nvram_test>`)

	loaded, err := LoadNvram_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNvram_testElementType_MarshalUnmarshal tests XML round-trip for Nvram_testElementType
func TestNvram_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Nvram_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Nvram_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_objectElement_MarshalUnmarshal tests XML round-trip for Plist510_objectElement
func TestPlist510_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist510_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist510_objectElement_ToBytes tests the ToBytes method
func TestPlist510_objectElement_ToBytes(t *testing.T) {
	elem := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist510_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist510_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist510_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist510_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist510_objectElement_SaveAndLoad tests SaveToFile and LoadPlist510_objectFromFile
func TestPlist510_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Plist510_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist510_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist510_objectElement_LoadFromBytes tests the LoadPlist510_objectFromBytes function
func TestPlist510_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist510_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist510_object>`)

	loaded, err := LoadPlist510_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist510_objectElementType_MarshalUnmarshal tests XML round-trip for Plist510_objectElementType
func TestPlist510_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_stateElement_MarshalUnmarshal tests XML round-trip for Plist510_stateElement
func TestPlist510_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist510_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist510_stateElement_ToBytes tests the ToBytes method
func TestPlist510_stateElement_ToBytes(t *testing.T) {
	elem := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist510_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist510_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist510_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist510_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist510_stateElement_SaveAndLoad tests SaveToFile and LoadPlist510_stateFromFile
func TestPlist510_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Plist510_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist510_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist510_stateElement_LoadFromBytes tests the LoadPlist510_stateFromBytes function
func TestPlist510_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist510_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist510_state>`)

	loaded, err := LoadPlist510_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist510_stateElementType_MarshalUnmarshal tests XML round-trip for Plist510_stateElementType
func TestPlist510_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_testElement_MarshalUnmarshal tests XML round-trip for Plist510_testElement
func TestPlist510_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist510_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist510_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist510_testElement_ToBytes tests the ToBytes method
func TestPlist510_testElement_ToBytes(t *testing.T) {
	elem := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist510_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist510_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist510_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist510_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist510_testElement_SaveAndLoad tests SaveToFile and LoadPlist510_testFromFile
func TestPlist510_testElement_SaveAndLoad(t *testing.T) {
	elem := &Plist510_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist510_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist510_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist510_testElement_LoadFromBytes tests the LoadPlist510_testFromBytes function
func TestPlist510_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist510_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist510_test>`)

	loaded, err := LoadPlist510_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist510_testElementType_MarshalUnmarshal tests XML round-trip for Plist510_testElementType
func TestPlist510_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist510_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist510_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_objectElement_MarshalUnmarshal tests XML round-trip for Plist511_objectElement
func TestPlist511_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist511_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist511_objectElement_ToBytes tests the ToBytes method
func TestPlist511_objectElement_ToBytes(t *testing.T) {
	elem := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist511_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist511_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist511_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist511_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist511_objectElement_SaveAndLoad tests SaveToFile and LoadPlist511_objectFromFile
func TestPlist511_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Plist511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist511_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist511_objectElement_LoadFromBytes tests the LoadPlist511_objectFromBytes function
func TestPlist511_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist511_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist511_object>`)

	loaded, err := LoadPlist511_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist511_objectElementType_MarshalUnmarshal tests XML round-trip for Plist511_objectElementType
func TestPlist511_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_stateElement_MarshalUnmarshal tests XML round-trip for Plist511_stateElement
func TestPlist511_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist511_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist511_stateElement_ToBytes tests the ToBytes method
func TestPlist511_stateElement_ToBytes(t *testing.T) {
	elem := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist511_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist511_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist511_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist511_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist511_stateElement_SaveAndLoad tests SaveToFile and LoadPlist511_stateFromFile
func TestPlist511_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Plist511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist511_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist511_stateElement_LoadFromBytes tests the LoadPlist511_stateFromBytes function
func TestPlist511_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist511_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist511_state>`)

	loaded, err := LoadPlist511_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist511_stateElementType_MarshalUnmarshal tests XML round-trip for Plist511_stateElementType
func TestPlist511_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_testElement_MarshalUnmarshal tests XML round-trip for Plist511_testElement
func TestPlist511_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist511_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist511_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist511_testElement_ToBytes tests the ToBytes method
func TestPlist511_testElement_ToBytes(t *testing.T) {
	elem := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist511_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist511_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist511_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist511_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist511_testElement_SaveAndLoad tests SaveToFile and LoadPlist511_testFromFile
func TestPlist511_testElement_SaveAndLoad(t *testing.T) {
	elem := &Plist511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist511_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist511_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist511_testElement_LoadFromBytes tests the LoadPlist511_testFromBytes function
func TestPlist511_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist511_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist511_test>`)

	loaded, err := LoadPlist511_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist511_testElementType_MarshalUnmarshal tests XML round-trip for Plist511_testElementType
func TestPlist511_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist511_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist511_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_objectElement_MarshalUnmarshal tests XML round-trip for Plist_objectElement
func TestPlist_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist_objectElement_ToBytes tests the ToBytes method
func TestPlist_objectElement_ToBytes(t *testing.T) {
	elem := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist_objectElement_SaveAndLoad tests SaveToFile and LoadPlist_objectFromFile
func TestPlist_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Plist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist_objectElement_LoadFromBytes tests the LoadPlist_objectFromBytes function
func TestPlist_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist_object>`)

	loaded, err := LoadPlist_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist_objectElementType_MarshalUnmarshal tests XML round-trip for Plist_objectElementType
func TestPlist_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_stateElement_MarshalUnmarshal tests XML round-trip for Plist_stateElement
func TestPlist_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist_stateElement_ToBytes tests the ToBytes method
func TestPlist_stateElement_ToBytes(t *testing.T) {
	elem := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist_stateElement_SaveAndLoad tests SaveToFile and LoadPlist_stateFromFile
func TestPlist_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Plist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist_stateElement_LoadFromBytes tests the LoadPlist_stateFromBytes function
func TestPlist_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist_state>`)

	loaded, err := LoadPlist_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist_stateElementType_MarshalUnmarshal tests XML round-trip for Plist_stateElementType
func TestPlist_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_testElement_MarshalUnmarshal tests XML round-trip for Plist_testElement
func TestPlist_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPlist_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPlist_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPlist_testElement_ToBytes tests the ToBytes method
func TestPlist_testElement_ToBytes(t *testing.T) {
	elem := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPlist_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPlist_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPlist_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPlist_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPlist_testElement_SaveAndLoad tests SaveToFile and LoadPlist_testFromFile
func TestPlist_testElement_SaveAndLoad(t *testing.T) {
	elem := &Plist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "plist_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPlist_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPlist_testElement_LoadFromBytes tests the LoadPlist_testFromBytes function
func TestPlist_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<plist_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></plist_test>`)

	loaded, err := LoadPlist_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPlist_testElementType_MarshalUnmarshal tests XML round-trip for Plist_testElementType
func TestPlist_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Plist_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Plist_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_objectElement_MarshalUnmarshal tests XML round-trip for Pwpolicy59_objectElement
func TestPwpolicy59_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy59_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy59_objectElement_ToBytes tests the ToBytes method
func TestPwpolicy59_objectElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy59_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy59_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy59_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy59_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy59_objectElement_SaveAndLoad tests SaveToFile and LoadPwpolicy59_objectFromFile
func TestPwpolicy59_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy59_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy59_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy59_objectElement_LoadFromBytes tests the LoadPwpolicy59_objectFromBytes function
func TestPwpolicy59_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy59_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy59_object>`)

	loaded, err := LoadPwpolicy59_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy59_objectElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy59_objectElementType
func TestPwpolicy59_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_stateElement_MarshalUnmarshal tests XML round-trip for Pwpolicy59_stateElement
func TestPwpolicy59_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy59_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy59_stateElement_ToBytes tests the ToBytes method
func TestPwpolicy59_stateElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy59_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy59_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy59_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy59_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy59_stateElement_SaveAndLoad tests SaveToFile and LoadPwpolicy59_stateFromFile
func TestPwpolicy59_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy59_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy59_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy59_stateElement_LoadFromBytes tests the LoadPwpolicy59_stateFromBytes function
func TestPwpolicy59_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy59_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy59_state>`)

	loaded, err := LoadPwpolicy59_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy59_stateElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy59_stateElementType
func TestPwpolicy59_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_testElement_MarshalUnmarshal tests XML round-trip for Pwpolicy59_testElement
func TestPwpolicy59_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy59_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy59_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy59_testElement_ToBytes tests the ToBytes method
func TestPwpolicy59_testElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy59_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy59_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy59_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy59_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy59_testElement_SaveAndLoad tests SaveToFile and LoadPwpolicy59_testFromFile
func TestPwpolicy59_testElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy59_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy59_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy59_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy59_testElement_LoadFromBytes tests the LoadPwpolicy59_testFromBytes function
func TestPwpolicy59_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy59_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy59_test>`)

	loaded, err := LoadPwpolicy59_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy59_testElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy59_testElementType
func TestPwpolicy59_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy59_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy59_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_objectElement_MarshalUnmarshal tests XML round-trip for Pwpolicy_objectElement
func TestPwpolicy_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy_objectElement_ToBytes tests the ToBytes method
func TestPwpolicy_objectElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy_objectElement_SaveAndLoad tests SaveToFile and LoadPwpolicy_objectFromFile
func TestPwpolicy_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy_objectElement_LoadFromBytes tests the LoadPwpolicy_objectFromBytes function
func TestPwpolicy_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy_object>`)

	loaded, err := LoadPwpolicy_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy_objectElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy_objectElementType
func TestPwpolicy_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_stateElement_MarshalUnmarshal tests XML round-trip for Pwpolicy_stateElement
func TestPwpolicy_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy_stateElement_ToBytes tests the ToBytes method
func TestPwpolicy_stateElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy_stateElement_SaveAndLoad tests SaveToFile and LoadPwpolicy_stateFromFile
func TestPwpolicy_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy_stateElement_LoadFromBytes tests the LoadPwpolicy_stateFromBytes function
func TestPwpolicy_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy_state>`)

	loaded, err := LoadPwpolicy_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy_stateElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy_stateElementType
func TestPwpolicy_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_testElement_MarshalUnmarshal tests XML round-trip for Pwpolicy_testElement
func TestPwpolicy_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPwpolicy_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPwpolicy_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPwpolicy_testElement_ToBytes tests the ToBytes method
func TestPwpolicy_testElement_ToBytes(t *testing.T) {
	elem := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPwpolicy_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPwpolicy_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPwpolicy_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPwpolicy_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPwpolicy_testElement_SaveAndLoad tests SaveToFile and LoadPwpolicy_testFromFile
func TestPwpolicy_testElement_SaveAndLoad(t *testing.T) {
	elem := &Pwpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "pwpolicy_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPwpolicy_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPwpolicy_testElement_LoadFromBytes tests the LoadPwpolicy_testFromBytes function
func TestPwpolicy_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<pwpolicy_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></pwpolicy_test>`)

	loaded, err := LoadPwpolicy_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPwpolicy_testElementType_MarshalUnmarshal tests XML round-trip for Pwpolicy_testElementType
func TestPwpolicy_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Pwpolicy_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Pwpolicy_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_objectElement_MarshalUnmarshal tests XML round-trip for Rlimit_objectElement
func TestRlimit_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRlimit_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRlimit_objectElement_ToBytes tests the ToBytes method
func TestRlimit_objectElement_ToBytes(t *testing.T) {
	elem := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRlimit_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRlimit_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRlimit_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRlimit_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRlimit_objectElement_SaveAndLoad tests SaveToFile and LoadRlimit_objectFromFile
func TestRlimit_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Rlimit_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRlimit_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRlimit_objectElement_LoadFromBytes tests the LoadRlimit_objectFromBytes function
func TestRlimit_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rlimit_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></rlimit_object>`)

	loaded, err := LoadRlimit_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRlimit_objectElementType_MarshalUnmarshal tests XML round-trip for Rlimit_objectElementType
func TestRlimit_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_stateElement_MarshalUnmarshal tests XML round-trip for Rlimit_stateElement
func TestRlimit_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRlimit_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRlimit_stateElement_ToBytes tests the ToBytes method
func TestRlimit_stateElement_ToBytes(t *testing.T) {
	elem := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRlimit_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRlimit_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRlimit_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRlimit_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRlimit_stateElement_SaveAndLoad tests SaveToFile and LoadRlimit_stateFromFile
func TestRlimit_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Rlimit_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRlimit_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRlimit_stateElement_LoadFromBytes tests the LoadRlimit_stateFromBytes function
func TestRlimit_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rlimit_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></rlimit_state>`)

	loaded, err := LoadRlimit_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRlimit_stateElementType_MarshalUnmarshal tests XML round-trip for Rlimit_stateElementType
func TestRlimit_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_testElement_MarshalUnmarshal tests XML round-trip for Rlimit_testElement
func TestRlimit_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRlimit_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRlimit_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRlimit_testElement_ToBytes tests the ToBytes method
func TestRlimit_testElement_ToBytes(t *testing.T) {
	elem := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRlimit_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRlimit_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRlimit_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRlimit_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRlimit_testElement_SaveAndLoad tests SaveToFile and LoadRlimit_testFromFile
func TestRlimit_testElement_SaveAndLoad(t *testing.T) {
	elem := &Rlimit_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "rlimit_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRlimit_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRlimit_testElement_LoadFromBytes tests the LoadRlimit_testFromBytes function
func TestRlimit_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<rlimit_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></rlimit_test>`)

	loaded, err := LoadRlimit_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRlimit_testElementType_MarshalUnmarshal tests XML round-trip for Rlimit_testElementType
func TestRlimit_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Rlimit_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Rlimit_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_objectElement_MarshalUnmarshal tests XML round-trip for Softwareupdate_objectElement
func TestSoftwareupdate_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSoftwareupdate_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSoftwareupdate_objectElement_ToBytes tests the ToBytes method
func TestSoftwareupdate_objectElement_ToBytes(t *testing.T) {
	elem := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSoftwareupdate_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSoftwareupdate_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSoftwareupdate_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_objectElement_SaveAndLoad tests SaveToFile and LoadSoftwareupdate_objectFromFile
func TestSoftwareupdate_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Softwareupdate_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSoftwareupdate_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSoftwareupdate_objectElement_LoadFromBytes tests the LoadSoftwareupdate_objectFromBytes function
func TestSoftwareupdate_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<softwareupdate_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></softwareupdate_object>`)

	loaded, err := LoadSoftwareupdate_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSoftwareupdate_objectElementType_MarshalUnmarshal tests XML round-trip for Softwareupdate_objectElementType
func TestSoftwareupdate_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_stateElement_MarshalUnmarshal tests XML round-trip for Softwareupdate_stateElement
func TestSoftwareupdate_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSoftwareupdate_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSoftwareupdate_stateElement_ToBytes tests the ToBytes method
func TestSoftwareupdate_stateElement_ToBytes(t *testing.T) {
	elem := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSoftwareupdate_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSoftwareupdate_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSoftwareupdate_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_stateElement_SaveAndLoad tests SaveToFile and LoadSoftwareupdate_stateFromFile
func TestSoftwareupdate_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Softwareupdate_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSoftwareupdate_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSoftwareupdate_stateElement_LoadFromBytes tests the LoadSoftwareupdate_stateFromBytes function
func TestSoftwareupdate_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<softwareupdate_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></softwareupdate_state>`)

	loaded, err := LoadSoftwareupdate_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSoftwareupdate_stateElementType_MarshalUnmarshal tests XML round-trip for Softwareupdate_stateElementType
func TestSoftwareupdate_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_testElement_MarshalUnmarshal tests XML round-trip for Softwareupdate_testElement
func TestSoftwareupdate_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSoftwareupdate_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSoftwareupdate_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSoftwareupdate_testElement_ToBytes tests the ToBytes method
func TestSoftwareupdate_testElement_ToBytes(t *testing.T) {
	elem := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSoftwareupdate_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSoftwareupdate_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSoftwareupdate_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSoftwareupdate_testElement_SaveAndLoad tests SaveToFile and LoadSoftwareupdate_testFromFile
func TestSoftwareupdate_testElement_SaveAndLoad(t *testing.T) {
	elem := &Softwareupdate_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "softwareupdate_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSoftwareupdate_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSoftwareupdate_testElement_LoadFromBytes tests the LoadSoftwareupdate_testFromBytes function
func TestSoftwareupdate_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<softwareupdate_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></softwareupdate_test>`)

	loaded, err := LoadSoftwareupdate_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSoftwareupdate_testElementType_MarshalUnmarshal tests XML round-trip for Softwareupdate_testElementType
func TestSoftwareupdate_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Softwareupdate_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Softwareupdate_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_objectElement_MarshalUnmarshal tests XML round-trip for Systemprofiler_objectElement
func TestSystemprofiler_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemprofiler_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemprofiler_objectElement_ToBytes tests the ToBytes method
func TestSystemprofiler_objectElement_ToBytes(t *testing.T) {
	elem := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemprofiler_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemprofiler_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemprofiler_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemprofiler_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemprofiler_objectElement_SaveAndLoad tests SaveToFile and LoadSystemprofiler_objectFromFile
func TestSystemprofiler_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Systemprofiler_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemprofiler_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemprofiler_objectElement_LoadFromBytes tests the LoadSystemprofiler_objectFromBytes function
func TestSystemprofiler_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemprofiler_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemprofiler_object>`)

	loaded, err := LoadSystemprofiler_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemprofiler_objectElementType_MarshalUnmarshal tests XML round-trip for Systemprofiler_objectElementType
func TestSystemprofiler_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_stateElement_MarshalUnmarshal tests XML round-trip for Systemprofiler_stateElement
func TestSystemprofiler_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemprofiler_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemprofiler_stateElement_ToBytes tests the ToBytes method
func TestSystemprofiler_stateElement_ToBytes(t *testing.T) {
	elem := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemprofiler_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemprofiler_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemprofiler_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemprofiler_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemprofiler_stateElement_SaveAndLoad tests SaveToFile and LoadSystemprofiler_stateFromFile
func TestSystemprofiler_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Systemprofiler_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemprofiler_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemprofiler_stateElement_LoadFromBytes tests the LoadSystemprofiler_stateFromBytes function
func TestSystemprofiler_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemprofiler_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemprofiler_state>`)

	loaded, err := LoadSystemprofiler_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemprofiler_stateElementType_MarshalUnmarshal tests XML round-trip for Systemprofiler_stateElementType
func TestSystemprofiler_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_testElement_MarshalUnmarshal tests XML round-trip for Systemprofiler_testElement
func TestSystemprofiler_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemprofiler_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemprofiler_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemprofiler_testElement_ToBytes tests the ToBytes method
func TestSystemprofiler_testElement_ToBytes(t *testing.T) {
	elem := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemprofiler_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemprofiler_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemprofiler_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemprofiler_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemprofiler_testElement_SaveAndLoad tests SaveToFile and LoadSystemprofiler_testFromFile
func TestSystemprofiler_testElement_SaveAndLoad(t *testing.T) {
	elem := &Systemprofiler_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemprofiler_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemprofiler_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemprofiler_testElement_LoadFromBytes tests the LoadSystemprofiler_testFromBytes function
func TestSystemprofiler_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemprofiler_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemprofiler_test>`)

	loaded, err := LoadSystemprofiler_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemprofiler_testElementType_MarshalUnmarshal tests XML round-trip for Systemprofiler_testElementType
func TestSystemprofiler_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemprofiler_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemprofiler_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_objectElement_MarshalUnmarshal tests XML round-trip for Systemsetup_objectElement
func TestSystemsetup_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemsetup_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemsetup_objectElement_ToBytes tests the ToBytes method
func TestSystemsetup_objectElement_ToBytes(t *testing.T) {
	elem := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemsetup_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemsetup_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemsetup_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemsetup_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemsetup_objectElement_SaveAndLoad tests SaveToFile and LoadSystemsetup_objectFromFile
func TestSystemsetup_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Systemsetup_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemsetup_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemsetup_objectElement_LoadFromBytes tests the LoadSystemsetup_objectFromBytes function
func TestSystemsetup_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemsetup_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemsetup_object>`)

	loaded, err := LoadSystemsetup_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemsetup_objectElementType_MarshalUnmarshal tests XML round-trip for Systemsetup_objectElementType
func TestSystemsetup_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_stateElement_MarshalUnmarshal tests XML round-trip for Systemsetup_stateElement
func TestSystemsetup_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemsetup_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemsetup_stateElement_ToBytes tests the ToBytes method
func TestSystemsetup_stateElement_ToBytes(t *testing.T) {
	elem := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemsetup_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemsetup_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemsetup_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemsetup_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemsetup_stateElement_SaveAndLoad tests SaveToFile and LoadSystemsetup_stateFromFile
func TestSystemsetup_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Systemsetup_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemsetup_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemsetup_stateElement_LoadFromBytes tests the LoadSystemsetup_stateFromBytes function
func TestSystemsetup_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemsetup_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemsetup_state>`)

	loaded, err := LoadSystemsetup_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemsetup_stateElementType_MarshalUnmarshal tests XML round-trip for Systemsetup_stateElementType
func TestSystemsetup_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_testElement_MarshalUnmarshal tests XML round-trip for Systemsetup_testElement
func TestSystemsetup_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemsetup_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemsetup_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemsetup_testElement_ToBytes tests the ToBytes method
func TestSystemsetup_testElement_ToBytes(t *testing.T) {
	elem := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemsetup_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemsetup_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemsetup_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemsetup_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemsetup_testElement_SaveAndLoad tests SaveToFile and LoadSystemsetup_testFromFile
func TestSystemsetup_testElement_SaveAndLoad(t *testing.T) {
	elem := &Systemsetup_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#macos", Local: "systemsetup_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemsetup_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemsetup_testElement_LoadFromBytes tests the LoadSystemsetup_testFromBytes function
func TestSystemsetup_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemsetup_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#macos"></systemsetup_test>`)

	loaded, err := LoadSystemsetup_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemsetup_testElementType_MarshalUnmarshal tests XML round-trip for Systemsetup_testElementType
func TestSystemsetup_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemsetup_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemsetup_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
