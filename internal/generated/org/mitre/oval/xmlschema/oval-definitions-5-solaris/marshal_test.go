// Package xmlschemaoval_definitions_5_solaris - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_solaris

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestEntityObjectPublisherTypeType_MarshalUnmarshal tests XML round-trip for EntityObjectPublisherTypeType
func TestEntityObjectPublisherTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectPublisherTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectPublisherTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateClientUUIDType_MarshalUnmarshal tests XML round-trip for EntityStateClientUUIDType
func TestEntityStateClientUUIDType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateClientUUIDType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateClientUUIDType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateLDOMRoleType_MarshalUnmarshal tests XML round-trip for EntityStateLDOMRoleType
func TestEntityStateLDOMRoleType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateLDOMRoleType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateLDOMRoleType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePermissionCompareType_MarshalUnmarshal tests XML round-trip for EntityStatePermissionCompareType
func TestEntityStatePermissionCompareType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePermissionCompareType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePermissionCompareType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePublisherTypeType_MarshalUnmarshal tests XML round-trip for EntityStatePublisherTypeType
func TestEntityStatePublisherTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePublisherTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePublisherTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSmfServiceStateType_MarshalUnmarshal tests XML round-trip for EntityStateSmfServiceStateType
func TestEntityStateSmfServiceStateType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSmfServiceStateType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSmfServiceStateType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateV12NEnvType_MarshalUnmarshal tests XML round-trip for EntityStateV12NEnvType
func TestEntityStateV12NEnvType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateV12NEnvType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateV12NEnvType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_objectElement_MarshalUnmarshal tests XML round-trip for Facet_objectElement
func TestFacet_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFacet_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFacet_objectElement_ToBytes tests the ToBytes method
func TestFacet_objectElement_ToBytes(t *testing.T) {
	elem := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFacet_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFacet_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFacet_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFacet_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFacet_objectElement_SaveAndLoad tests SaveToFile and LoadFacet_objectFromFile
func TestFacet_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Facet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFacet_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFacet_objectElement_LoadFromBytes tests the LoadFacet_objectFromBytes function
func TestFacet_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<facet_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></facet_object>`)

	loaded, err := LoadFacet_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFacet_objectElementType_MarshalUnmarshal tests XML round-trip for Facet_objectElementType
func TestFacet_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Facet_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_stateElement_MarshalUnmarshal tests XML round-trip for Facet_stateElement
func TestFacet_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFacet_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFacet_stateElement_ToBytes tests the ToBytes method
func TestFacet_stateElement_ToBytes(t *testing.T) {
	elem := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFacet_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFacet_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFacet_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFacet_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFacet_stateElement_SaveAndLoad tests SaveToFile and LoadFacet_stateFromFile
func TestFacet_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Facet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFacet_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFacet_stateElement_LoadFromBytes tests the LoadFacet_stateFromBytes function
func TestFacet_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<facet_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></facet_state>`)

	loaded, err := LoadFacet_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFacet_stateElementType_MarshalUnmarshal tests XML round-trip for Facet_stateElementType
func TestFacet_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Facet_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_testElement_MarshalUnmarshal tests XML round-trip for Facet_testElement
func TestFacet_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFacet_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFacet_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFacet_testElement_ToBytes tests the ToBytes method
func TestFacet_testElement_ToBytes(t *testing.T) {
	elem := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFacet_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFacet_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFacet_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFacet_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFacet_testElement_SaveAndLoad tests SaveToFile and LoadFacet_testFromFile
func TestFacet_testElement_SaveAndLoad(t *testing.T) {
	elem := &Facet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "facet_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFacet_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFacet_testElement_LoadFromBytes tests the LoadFacet_testFromBytes function
func TestFacet_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<facet_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></facet_test>`)

	loaded, err := LoadFacet_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFacet_testElementType_MarshalUnmarshal tests XML round-trip for Facet_testElementType
func TestFacet_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Facet_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Facet_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_objectElement_MarshalUnmarshal tests XML round-trip for Image_objectElement
func TestImage_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestImage_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestImage_objectElement_ToBytes tests the ToBytes method
func TestImage_objectElement_ToBytes(t *testing.T) {
	elem := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestImage_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestImage_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestImage_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestImage_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestImage_objectElement_SaveAndLoad tests SaveToFile and LoadImage_objectFromFile
func TestImage_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Image_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadImage_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestImage_objectElement_LoadFromBytes tests the LoadImage_objectFromBytes function
func TestImage_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<image_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></image_object>`)

	loaded, err := LoadImage_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestImage_objectElementType_MarshalUnmarshal tests XML round-trip for Image_objectElementType
func TestImage_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Image_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_stateElement_MarshalUnmarshal tests XML round-trip for Image_stateElement
func TestImage_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestImage_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestImage_stateElement_ToBytes tests the ToBytes method
func TestImage_stateElement_ToBytes(t *testing.T) {
	elem := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestImage_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestImage_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestImage_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestImage_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestImage_stateElement_SaveAndLoad tests SaveToFile and LoadImage_stateFromFile
func TestImage_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Image_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadImage_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestImage_stateElement_LoadFromBytes tests the LoadImage_stateFromBytes function
func TestImage_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<image_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></image_state>`)

	loaded, err := LoadImage_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestImage_stateElementType_MarshalUnmarshal tests XML round-trip for Image_stateElementType
func TestImage_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Image_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_testElement_MarshalUnmarshal tests XML round-trip for Image_testElement
func TestImage_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestImage_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestImage_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestImage_testElement_ToBytes tests the ToBytes method
func TestImage_testElement_ToBytes(t *testing.T) {
	elem := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestImage_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestImage_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestImage_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestImage_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestImage_testElement_SaveAndLoad tests SaveToFile and LoadImage_testFromFile
func TestImage_testElement_SaveAndLoad(t *testing.T) {
	elem := &Image_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "image_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadImage_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestImage_testElement_LoadFromBytes tests the LoadImage_testFromBytes function
func TestImage_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<image_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></image_test>`)

	loaded, err := LoadImage_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestImage_testElementType_MarshalUnmarshal tests XML round-trip for Image_testElementType
func TestImage_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Image_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Image_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_objectElement_MarshalUnmarshal tests XML round-trip for Isainfo_objectElement
func TestIsainfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIsainfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIsainfo_objectElement_ToBytes tests the ToBytes method
func TestIsainfo_objectElement_ToBytes(t *testing.T) {
	elem := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIsainfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIsainfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIsainfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIsainfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIsainfo_objectElement_SaveAndLoad tests SaveToFile and LoadIsainfo_objectFromFile
func TestIsainfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Isainfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIsainfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIsainfo_objectElement_LoadFromBytes tests the LoadIsainfo_objectFromBytes function
func TestIsainfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<isainfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></isainfo_object>`)

	loaded, err := LoadIsainfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIsainfo_objectElementType_MarshalUnmarshal tests XML round-trip for Isainfo_objectElementType
func TestIsainfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_stateElement_MarshalUnmarshal tests XML round-trip for Isainfo_stateElement
func TestIsainfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIsainfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIsainfo_stateElement_ToBytes tests the ToBytes method
func TestIsainfo_stateElement_ToBytes(t *testing.T) {
	elem := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIsainfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIsainfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIsainfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIsainfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIsainfo_stateElement_SaveAndLoad tests SaveToFile and LoadIsainfo_stateFromFile
func TestIsainfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Isainfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIsainfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIsainfo_stateElement_LoadFromBytes tests the LoadIsainfo_stateFromBytes function
func TestIsainfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<isainfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></isainfo_state>`)

	loaded, err := LoadIsainfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIsainfo_stateElementType_MarshalUnmarshal tests XML round-trip for Isainfo_stateElementType
func TestIsainfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_testElement_MarshalUnmarshal tests XML round-trip for Isainfo_testElement
func TestIsainfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestIsainfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestIsainfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestIsainfo_testElement_ToBytes tests the ToBytes method
func TestIsainfo_testElement_ToBytes(t *testing.T) {
	elem := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestIsainfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestIsainfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestIsainfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestIsainfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestIsainfo_testElement_SaveAndLoad tests SaveToFile and LoadIsainfo_testFromFile
func TestIsainfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Isainfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "isainfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadIsainfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestIsainfo_testElement_LoadFromBytes tests the LoadIsainfo_testFromBytes function
func TestIsainfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<isainfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></isainfo_test>`)

	loaded, err := LoadIsainfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestIsainfo_testElementType_MarshalUnmarshal tests XML round-trip for Isainfo_testElementType
func TestIsainfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Isainfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Isainfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_objectElement_MarshalUnmarshal tests XML round-trip for Ndd_objectElement
func TestNdd_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNdd_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNdd_objectElement_ToBytes tests the ToBytes method
func TestNdd_objectElement_ToBytes(t *testing.T) {
	elem := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNdd_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNdd_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNdd_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNdd_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNdd_objectElement_SaveAndLoad tests SaveToFile and LoadNdd_objectFromFile
func TestNdd_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Ndd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNdd_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNdd_objectElement_LoadFromBytes tests the LoadNdd_objectFromBytes function
func TestNdd_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ndd_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></ndd_object>`)

	loaded, err := LoadNdd_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNdd_objectElementType_MarshalUnmarshal tests XML round-trip for Ndd_objectElementType
func TestNdd_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_stateElement_MarshalUnmarshal tests XML round-trip for Ndd_stateElement
func TestNdd_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNdd_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNdd_stateElement_ToBytes tests the ToBytes method
func TestNdd_stateElement_ToBytes(t *testing.T) {
	elem := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNdd_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNdd_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNdd_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNdd_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNdd_stateElement_SaveAndLoad tests SaveToFile and LoadNdd_stateFromFile
func TestNdd_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Ndd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNdd_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNdd_stateElement_LoadFromBytes tests the LoadNdd_stateFromBytes function
func TestNdd_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ndd_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></ndd_state>`)

	loaded, err := LoadNdd_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNdd_stateElementType_MarshalUnmarshal tests XML round-trip for Ndd_stateElementType
func TestNdd_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_testElement_MarshalUnmarshal tests XML round-trip for Ndd_testElement
func TestNdd_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNdd_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNdd_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNdd_testElement_ToBytes tests the ToBytes method
func TestNdd_testElement_ToBytes(t *testing.T) {
	elem := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNdd_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNdd_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNdd_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNdd_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNdd_testElement_SaveAndLoad tests SaveToFile and LoadNdd_testFromFile
func TestNdd_testElement_SaveAndLoad(t *testing.T) {
	elem := &Ndd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "ndd_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNdd_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNdd_testElement_LoadFromBytes tests the LoadNdd_testFromBytes function
func TestNdd_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ndd_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></ndd_test>`)

	loaded, err := LoadNdd_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNdd_testElementType_MarshalUnmarshal tests XML round-trip for Ndd_testElementType
func TestNdd_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ndd_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ndd_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_objectElement_MarshalUnmarshal tests XML round-trip for Package511_objectElement
func TestPackage511_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage511_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage511_objectElement_ToBytes tests the ToBytes method
func TestPackage511_objectElement_ToBytes(t *testing.T) {
	elem := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage511_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage511_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage511_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage511_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage511_objectElement_SaveAndLoad tests SaveToFile and LoadPackage511_objectFromFile
func TestPackage511_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Package511_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage511_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage511_objectElement_LoadFromBytes tests the LoadPackage511_objectFromBytes function
func TestPackage511_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package511_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package511_object>`)

	loaded, err := LoadPackage511_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage511_objectElementType_MarshalUnmarshal tests XML round-trip for Package511_objectElementType
func TestPackage511_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package511_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_stateElement_MarshalUnmarshal tests XML round-trip for Package511_stateElement
func TestPackage511_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage511_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage511_stateElement_ToBytes tests the ToBytes method
func TestPackage511_stateElement_ToBytes(t *testing.T) {
	elem := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage511_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage511_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage511_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage511_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage511_stateElement_SaveAndLoad tests SaveToFile and LoadPackage511_stateFromFile
func TestPackage511_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Package511_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage511_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage511_stateElement_LoadFromBytes tests the LoadPackage511_stateFromBytes function
func TestPackage511_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package511_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package511_state>`)

	loaded, err := LoadPackage511_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage511_stateElementType_MarshalUnmarshal tests XML round-trip for Package511_stateElementType
func TestPackage511_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package511_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_testElement_MarshalUnmarshal tests XML round-trip for Package511_testElement
func TestPackage511_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage511_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage511_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage511_testElement_ToBytes tests the ToBytes method
func TestPackage511_testElement_ToBytes(t *testing.T) {
	elem := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage511_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage511_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage511_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage511_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage511_testElement_SaveAndLoad tests SaveToFile and LoadPackage511_testFromFile
func TestPackage511_testElement_SaveAndLoad(t *testing.T) {
	elem := &Package511_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package511_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage511_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage511_testElement_LoadFromBytes tests the LoadPackage511_testFromBytes function
func TestPackage511_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package511_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package511_test>`)

	loaded, err := LoadPackage511_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage511_testElementType_MarshalUnmarshal tests XML round-trip for Package511_testElementType
func TestPackage511_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package511_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package511_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageCheckBehaviors_MarshalUnmarshal tests XML round-trip for PackageCheckBehaviors
func TestPackageCheckBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &PackageCheckBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PackageCheckBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_objectElement_MarshalUnmarshal tests XML round-trip for Package_objectElement
func TestPackage_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage_objectElement_ToBytes tests the ToBytes method
func TestPackage_objectElement_ToBytes(t *testing.T) {
	elem := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage_objectElement_SaveAndLoad tests SaveToFile and LoadPackage_objectFromFile
func TestPackage_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Package_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage_objectElement_LoadFromBytes tests the LoadPackage_objectFromBytes function
func TestPackage_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package_object>`)

	loaded, err := LoadPackage_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage_objectElementType_MarshalUnmarshal tests XML round-trip for Package_objectElementType
func TestPackage_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_stateElement_MarshalUnmarshal tests XML round-trip for Package_stateElement
func TestPackage_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage_stateElement_ToBytes tests the ToBytes method
func TestPackage_stateElement_ToBytes(t *testing.T) {
	elem := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage_stateElement_SaveAndLoad tests SaveToFile and LoadPackage_stateFromFile
func TestPackage_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Package_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage_stateElement_LoadFromBytes tests the LoadPackage_stateFromBytes function
func TestPackage_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package_state>`)

	loaded, err := LoadPackage_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage_stateElementType_MarshalUnmarshal tests XML round-trip for Package_stateElementType
func TestPackage_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_testElement_MarshalUnmarshal tests XML round-trip for Package_testElement
func TestPackage_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackage_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackage_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackage_testElement_ToBytes tests the ToBytes method
func TestPackage_testElement_ToBytes(t *testing.T) {
	elem := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackage_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackage_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackage_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackage_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackage_testElement_SaveAndLoad tests SaveToFile and LoadPackage_testFromFile
func TestPackage_testElement_SaveAndLoad(t *testing.T) {
	elem := &Package_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "package_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackage_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackage_testElement_LoadFromBytes tests the LoadPackage_testFromBytes function
func TestPackage_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<package_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></package_test>`)

	loaded, err := LoadPackage_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackage_testElementType_MarshalUnmarshal tests XML round-trip for Package_testElementType
func TestPackage_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Package_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Package_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_objectElement_MarshalUnmarshal tests XML round-trip for Packageavoidlist_objectElement
func TestPackageavoidlist_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackageavoidlist_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackageavoidlist_objectElement_ToBytes tests the ToBytes method
func TestPackageavoidlist_objectElement_ToBytes(t *testing.T) {
	elem := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackageavoidlist_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackageavoidlist_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackageavoidlist_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_objectElement_SaveAndLoad tests SaveToFile and LoadPackageavoidlist_objectFromFile
func TestPackageavoidlist_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Packageavoidlist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackageavoidlist_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackageavoidlist_objectElement_LoadFromBytes tests the LoadPackageavoidlist_objectFromBytes function
func TestPackageavoidlist_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packageavoidlist_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packageavoidlist_object>`)

	loaded, err := LoadPackageavoidlist_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackageavoidlist_objectElementType_MarshalUnmarshal tests XML round-trip for Packageavoidlist_objectElementType
func TestPackageavoidlist_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_stateElement_MarshalUnmarshal tests XML round-trip for Packageavoidlist_stateElement
func TestPackageavoidlist_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackageavoidlist_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackageavoidlist_stateElement_ToBytes tests the ToBytes method
func TestPackageavoidlist_stateElement_ToBytes(t *testing.T) {
	elem := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackageavoidlist_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackageavoidlist_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackageavoidlist_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_stateElement_SaveAndLoad tests SaveToFile and LoadPackageavoidlist_stateFromFile
func TestPackageavoidlist_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Packageavoidlist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackageavoidlist_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackageavoidlist_stateElement_LoadFromBytes tests the LoadPackageavoidlist_stateFromBytes function
func TestPackageavoidlist_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packageavoidlist_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packageavoidlist_state>`)

	loaded, err := LoadPackageavoidlist_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackageavoidlist_stateElementType_MarshalUnmarshal tests XML round-trip for Packageavoidlist_stateElementType
func TestPackageavoidlist_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_testElement_MarshalUnmarshal tests XML round-trip for Packageavoidlist_testElement
func TestPackageavoidlist_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackageavoidlist_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackageavoidlist_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackageavoidlist_testElement_ToBytes tests the ToBytes method
func TestPackageavoidlist_testElement_ToBytes(t *testing.T) {
	elem := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackageavoidlist_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackageavoidlist_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackageavoidlist_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackageavoidlist_testElement_SaveAndLoad tests SaveToFile and LoadPackageavoidlist_testFromFile
func TestPackageavoidlist_testElement_SaveAndLoad(t *testing.T) {
	elem := &Packageavoidlist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packageavoidlist_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackageavoidlist_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackageavoidlist_testElement_LoadFromBytes tests the LoadPackageavoidlist_testFromBytes function
func TestPackageavoidlist_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packageavoidlist_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packageavoidlist_test>`)

	loaded, err := LoadPackageavoidlist_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackageavoidlist_testElementType_MarshalUnmarshal tests XML round-trip for Packageavoidlist_testElementType
func TestPackageavoidlist_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packageavoidlist_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packageavoidlist_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_objectElement_MarshalUnmarshal tests XML round-trip for Packagecheck_objectElement
func TestPackagecheck_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagecheck_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagecheck_objectElement_ToBytes tests the ToBytes method
func TestPackagecheck_objectElement_ToBytes(t *testing.T) {
	elem := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagecheck_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagecheck_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagecheck_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagecheck_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagecheck_objectElement_SaveAndLoad tests SaveToFile and LoadPackagecheck_objectFromFile
func TestPackagecheck_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Packagecheck_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagecheck_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagecheck_objectElement_LoadFromBytes tests the LoadPackagecheck_objectFromBytes function
func TestPackagecheck_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagecheck_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagecheck_object>`)

	loaded, err := LoadPackagecheck_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagecheck_objectElementType_MarshalUnmarshal tests XML round-trip for Packagecheck_objectElementType
func TestPackagecheck_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_stateElement_MarshalUnmarshal tests XML round-trip for Packagecheck_stateElement
func TestPackagecheck_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagecheck_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagecheck_stateElement_ToBytes tests the ToBytes method
func TestPackagecheck_stateElement_ToBytes(t *testing.T) {
	elem := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagecheck_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagecheck_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagecheck_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagecheck_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagecheck_stateElement_SaveAndLoad tests SaveToFile and LoadPackagecheck_stateFromFile
func TestPackagecheck_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Packagecheck_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagecheck_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagecheck_stateElement_LoadFromBytes tests the LoadPackagecheck_stateFromBytes function
func TestPackagecheck_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagecheck_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagecheck_state>`)

	loaded, err := LoadPackagecheck_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagecheck_stateElementType_MarshalUnmarshal tests XML round-trip for Packagecheck_stateElementType
func TestPackagecheck_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_testElement_MarshalUnmarshal tests XML round-trip for Packagecheck_testElement
func TestPackagecheck_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagecheck_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagecheck_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagecheck_testElement_ToBytes tests the ToBytes method
func TestPackagecheck_testElement_ToBytes(t *testing.T) {
	elem := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagecheck_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagecheck_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagecheck_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagecheck_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagecheck_testElement_SaveAndLoad tests SaveToFile and LoadPackagecheck_testFromFile
func TestPackagecheck_testElement_SaveAndLoad(t *testing.T) {
	elem := &Packagecheck_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagecheck_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagecheck_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagecheck_testElement_LoadFromBytes tests the LoadPackagecheck_testFromBytes function
func TestPackagecheck_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagecheck_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagecheck_test>`)

	loaded, err := LoadPackagecheck_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagecheck_testElementType_MarshalUnmarshal tests XML round-trip for Packagecheck_testElementType
func TestPackagecheck_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagecheck_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagecheck_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_objectElement_MarshalUnmarshal tests XML round-trip for Packagefreezelist_objectElement
func TestPackagefreezelist_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagefreezelist_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagefreezelist_objectElement_ToBytes tests the ToBytes method
func TestPackagefreezelist_objectElement_ToBytes(t *testing.T) {
	elem := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagefreezelist_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagefreezelist_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagefreezelist_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_objectElement_SaveAndLoad tests SaveToFile and LoadPackagefreezelist_objectFromFile
func TestPackagefreezelist_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Packagefreezelist_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagefreezelist_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagefreezelist_objectElement_LoadFromBytes tests the LoadPackagefreezelist_objectFromBytes function
func TestPackagefreezelist_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagefreezelist_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagefreezelist_object>`)

	loaded, err := LoadPackagefreezelist_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagefreezelist_objectElementType_MarshalUnmarshal tests XML round-trip for Packagefreezelist_objectElementType
func TestPackagefreezelist_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_stateElement_MarshalUnmarshal tests XML round-trip for Packagefreezelist_stateElement
func TestPackagefreezelist_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagefreezelist_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagefreezelist_stateElement_ToBytes tests the ToBytes method
func TestPackagefreezelist_stateElement_ToBytes(t *testing.T) {
	elem := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagefreezelist_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagefreezelist_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagefreezelist_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_stateElement_SaveAndLoad tests SaveToFile and LoadPackagefreezelist_stateFromFile
func TestPackagefreezelist_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Packagefreezelist_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagefreezelist_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagefreezelist_stateElement_LoadFromBytes tests the LoadPackagefreezelist_stateFromBytes function
func TestPackagefreezelist_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagefreezelist_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagefreezelist_state>`)

	loaded, err := LoadPackagefreezelist_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagefreezelist_stateElementType_MarshalUnmarshal tests XML round-trip for Packagefreezelist_stateElementType
func TestPackagefreezelist_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_testElement_MarshalUnmarshal tests XML round-trip for Packagefreezelist_testElement
func TestPackagefreezelist_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagefreezelist_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagefreezelist_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagefreezelist_testElement_ToBytes tests the ToBytes method
func TestPackagefreezelist_testElement_ToBytes(t *testing.T) {
	elem := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagefreezelist_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagefreezelist_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagefreezelist_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagefreezelist_testElement_SaveAndLoad tests SaveToFile and LoadPackagefreezelist_testFromFile
func TestPackagefreezelist_testElement_SaveAndLoad(t *testing.T) {
	elem := &Packagefreezelist_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagefreezelist_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagefreezelist_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagefreezelist_testElement_LoadFromBytes tests the LoadPackagefreezelist_testFromBytes function
func TestPackagefreezelist_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagefreezelist_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagefreezelist_test>`)

	loaded, err := LoadPackagefreezelist_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagefreezelist_testElementType_MarshalUnmarshal tests XML round-trip for Packagefreezelist_testElementType
func TestPackagefreezelist_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagefreezelist_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagefreezelist_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_objectElement_MarshalUnmarshal tests XML round-trip for Packagepublisher_objectElement
func TestPackagepublisher_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagepublisher_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagepublisher_objectElement_ToBytes tests the ToBytes method
func TestPackagepublisher_objectElement_ToBytes(t *testing.T) {
	elem := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagepublisher_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagepublisher_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagepublisher_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagepublisher_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagepublisher_objectElement_SaveAndLoad tests SaveToFile and LoadPackagepublisher_objectFromFile
func TestPackagepublisher_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Packagepublisher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagepublisher_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagepublisher_objectElement_LoadFromBytes tests the LoadPackagepublisher_objectFromBytes function
func TestPackagepublisher_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagepublisher_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagepublisher_object>`)

	loaded, err := LoadPackagepublisher_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagepublisher_objectElementType_MarshalUnmarshal tests XML round-trip for Packagepublisher_objectElementType
func TestPackagepublisher_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_stateElement_MarshalUnmarshal tests XML round-trip for Packagepublisher_stateElement
func TestPackagepublisher_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagepublisher_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagepublisher_stateElement_ToBytes tests the ToBytes method
func TestPackagepublisher_stateElement_ToBytes(t *testing.T) {
	elem := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagepublisher_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagepublisher_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagepublisher_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagepublisher_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagepublisher_stateElement_SaveAndLoad tests SaveToFile and LoadPackagepublisher_stateFromFile
func TestPackagepublisher_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Packagepublisher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagepublisher_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagepublisher_stateElement_LoadFromBytes tests the LoadPackagepublisher_stateFromBytes function
func TestPackagepublisher_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagepublisher_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagepublisher_state>`)

	loaded, err := LoadPackagepublisher_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagepublisher_stateElementType_MarshalUnmarshal tests XML round-trip for Packagepublisher_stateElementType
func TestPackagepublisher_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_testElement_MarshalUnmarshal tests XML round-trip for Packagepublisher_testElement
func TestPackagepublisher_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPackagepublisher_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPackagepublisher_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPackagepublisher_testElement_ToBytes tests the ToBytes method
func TestPackagepublisher_testElement_ToBytes(t *testing.T) {
	elem := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPackagepublisher_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPackagepublisher_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPackagepublisher_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPackagepublisher_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPackagepublisher_testElement_SaveAndLoad tests SaveToFile and LoadPackagepublisher_testFromFile
func TestPackagepublisher_testElement_SaveAndLoad(t *testing.T) {
	elem := &Packagepublisher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "packagepublisher_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPackagepublisher_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPackagepublisher_testElement_LoadFromBytes tests the LoadPackagepublisher_testFromBytes function
func TestPackagepublisher_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<packagepublisher_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></packagepublisher_test>`)

	loaded, err := LoadPackagepublisher_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPackagepublisher_testElementType_MarshalUnmarshal tests XML round-trip for Packagepublisher_testElementType
func TestPackagepublisher_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Packagepublisher_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Packagepublisher_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch54_objectElement_MarshalUnmarshal tests XML round-trip for Patch54_objectElement
func TestPatch54_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch54_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch54_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPatch54_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPatch54_objectElement_ToBytes tests the ToBytes method
func TestPatch54_objectElement_ToBytes(t *testing.T) {
	elem := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPatch54_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPatch54_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPatch54_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPatch54_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPatch54_objectElement_SaveAndLoad tests SaveToFile and LoadPatch54_objectFromFile
func TestPatch54_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Patch54_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPatch54_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPatch54_objectElement_LoadFromBytes tests the LoadPatch54_objectFromBytes function
func TestPatch54_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<patch54_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></patch54_object>`)

	loaded, err := LoadPatch54_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPatch54_objectElementType_MarshalUnmarshal tests XML round-trip for Patch54_objectElementType
func TestPatch54_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Patch54_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch54_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch54_testElement_MarshalUnmarshal tests XML round-trip for Patch54_testElement
func TestPatch54_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch54_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch54_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPatch54_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPatch54_testElement_ToBytes tests the ToBytes method
func TestPatch54_testElement_ToBytes(t *testing.T) {
	elem := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPatch54_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPatch54_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPatch54_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPatch54_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPatch54_testElement_SaveAndLoad tests SaveToFile and LoadPatch54_testFromFile
func TestPatch54_testElement_SaveAndLoad(t *testing.T) {
	elem := &Patch54_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch54_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPatch54_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPatch54_testElement_LoadFromBytes tests the LoadPatch54_testFromBytes function
func TestPatch54_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<patch54_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></patch54_test>`)

	loaded, err := LoadPatch54_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPatch54_testElementType_MarshalUnmarshal tests XML round-trip for Patch54_testElementType
func TestPatch54_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Patch54_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch54_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatchBehaviors_MarshalUnmarshal tests XML round-trip for PatchBehaviors
func TestPatchBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &PatchBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PatchBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_objectElement_MarshalUnmarshal tests XML round-trip for Patch_objectElement
func TestPatch_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPatch_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPatch_objectElement_ToBytes tests the ToBytes method
func TestPatch_objectElement_ToBytes(t *testing.T) {
	elem := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPatch_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPatch_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPatch_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPatch_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPatch_objectElement_SaveAndLoad tests SaveToFile and LoadPatch_objectFromFile
func TestPatch_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Patch_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPatch_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPatch_objectElement_LoadFromBytes tests the LoadPatch_objectFromBytes function
func TestPatch_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<patch_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></patch_object>`)

	loaded, err := LoadPatch_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPatch_objectElementType_MarshalUnmarshal tests XML round-trip for Patch_objectElementType
func TestPatch_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Patch_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_stateElement_MarshalUnmarshal tests XML round-trip for Patch_stateElement
func TestPatch_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPatch_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPatch_stateElement_ToBytes tests the ToBytes method
func TestPatch_stateElement_ToBytes(t *testing.T) {
	elem := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPatch_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPatch_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPatch_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPatch_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPatch_stateElement_SaveAndLoad tests SaveToFile and LoadPatch_stateFromFile
func TestPatch_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Patch_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPatch_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPatch_stateElement_LoadFromBytes tests the LoadPatch_stateFromBytes function
func TestPatch_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<patch_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></patch_state>`)

	loaded, err := LoadPatch_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPatch_stateElementType_MarshalUnmarshal tests XML round-trip for Patch_stateElementType
func TestPatch_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Patch_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_testElement_MarshalUnmarshal tests XML round-trip for Patch_testElement
func TestPatch_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPatch_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPatch_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPatch_testElement_ToBytes tests the ToBytes method
func TestPatch_testElement_ToBytes(t *testing.T) {
	elem := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPatch_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPatch_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPatch_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPatch_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPatch_testElement_SaveAndLoad tests SaveToFile and LoadPatch_testFromFile
func TestPatch_testElement_SaveAndLoad(t *testing.T) {
	elem := &Patch_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "patch_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPatch_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPatch_testElement_LoadFromBytes tests the LoadPatch_testFromBytes function
func TestPatch_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<patch_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></patch_test>`)

	loaded, err := LoadPatch_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPatch_testElementType_MarshalUnmarshal tests XML round-trip for Patch_testElementType
func TestPatch_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Patch_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Patch_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_objectElement_MarshalUnmarshal tests XML round-trip for Smf_objectElement
func TestSmf_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmf_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmf_objectElement_ToBytes tests the ToBytes method
func TestSmf_objectElement_ToBytes(t *testing.T) {
	elem := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmf_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmf_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmf_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmf_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmf_objectElement_SaveAndLoad tests SaveToFile and LoadSmf_objectFromFile
func TestSmf_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Smf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmf_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmf_objectElement_LoadFromBytes tests the LoadSmf_objectFromBytes function
func TestSmf_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smf_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smf_object>`)

	loaded, err := LoadSmf_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmf_objectElementType_MarshalUnmarshal tests XML round-trip for Smf_objectElementType
func TestSmf_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smf_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_stateElement_MarshalUnmarshal tests XML round-trip for Smf_stateElement
func TestSmf_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmf_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmf_stateElement_ToBytes tests the ToBytes method
func TestSmf_stateElement_ToBytes(t *testing.T) {
	elem := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmf_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmf_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmf_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmf_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmf_stateElement_SaveAndLoad tests SaveToFile and LoadSmf_stateFromFile
func TestSmf_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Smf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmf_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmf_stateElement_LoadFromBytes tests the LoadSmf_stateFromBytes function
func TestSmf_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smf_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smf_state>`)

	loaded, err := LoadSmf_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmf_stateElementType_MarshalUnmarshal tests XML round-trip for Smf_stateElementType
func TestSmf_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smf_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_testElement_MarshalUnmarshal tests XML round-trip for Smf_testElement
func TestSmf_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmf_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmf_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmf_testElement_ToBytes tests the ToBytes method
func TestSmf_testElement_ToBytes(t *testing.T) {
	elem := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmf_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmf_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmf_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmf_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmf_testElement_SaveAndLoad tests SaveToFile and LoadSmf_testFromFile
func TestSmf_testElement_SaveAndLoad(t *testing.T) {
	elem := &Smf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smf_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmf_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmf_testElement_LoadFromBytes tests the LoadSmf_testFromBytes function
func TestSmf_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smf_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smf_test>`)

	loaded, err := LoadSmf_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmf_testElementType_MarshalUnmarshal tests XML round-trip for Smf_testElementType
func TestSmf_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smf_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smf_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_objectElement_MarshalUnmarshal tests XML round-trip for Smfproperty_objectElement
func TestSmfproperty_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmfproperty_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmfproperty_objectElement_ToBytes tests the ToBytes method
func TestSmfproperty_objectElement_ToBytes(t *testing.T) {
	elem := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmfproperty_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmfproperty_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmfproperty_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmfproperty_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmfproperty_objectElement_SaveAndLoad tests SaveToFile and LoadSmfproperty_objectFromFile
func TestSmfproperty_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Smfproperty_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmfproperty_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmfproperty_objectElement_LoadFromBytes tests the LoadSmfproperty_objectFromBytes function
func TestSmfproperty_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smfproperty_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smfproperty_object>`)

	loaded, err := LoadSmfproperty_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmfproperty_objectElementType_MarshalUnmarshal tests XML round-trip for Smfproperty_objectElementType
func TestSmfproperty_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_stateElement_MarshalUnmarshal tests XML round-trip for Smfproperty_stateElement
func TestSmfproperty_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmfproperty_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmfproperty_stateElement_ToBytes tests the ToBytes method
func TestSmfproperty_stateElement_ToBytes(t *testing.T) {
	elem := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmfproperty_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmfproperty_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmfproperty_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmfproperty_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmfproperty_stateElement_SaveAndLoad tests SaveToFile and LoadSmfproperty_stateFromFile
func TestSmfproperty_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Smfproperty_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmfproperty_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmfproperty_stateElement_LoadFromBytes tests the LoadSmfproperty_stateFromBytes function
func TestSmfproperty_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smfproperty_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smfproperty_state>`)

	loaded, err := LoadSmfproperty_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmfproperty_stateElementType_MarshalUnmarshal tests XML round-trip for Smfproperty_stateElementType
func TestSmfproperty_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_testElement_MarshalUnmarshal tests XML round-trip for Smfproperty_testElement
func TestSmfproperty_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSmfproperty_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSmfproperty_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSmfproperty_testElement_ToBytes tests the ToBytes method
func TestSmfproperty_testElement_ToBytes(t *testing.T) {
	elem := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSmfproperty_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSmfproperty_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSmfproperty_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSmfproperty_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSmfproperty_testElement_SaveAndLoad tests SaveToFile and LoadSmfproperty_testFromFile
func TestSmfproperty_testElement_SaveAndLoad(t *testing.T) {
	elem := &Smfproperty_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "smfproperty_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSmfproperty_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSmfproperty_testElement_LoadFromBytes tests the LoadSmfproperty_testFromBytes function
func TestSmfproperty_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<smfproperty_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></smfproperty_test>`)

	loaded, err := LoadSmfproperty_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSmfproperty_testElementType_MarshalUnmarshal tests XML round-trip for Smfproperty_testElementType
func TestSmfproperty_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Smfproperty_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Smfproperty_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_objectElement_MarshalUnmarshal tests XML round-trip for Variant_objectElement
func TestVariant_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVariant_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVariant_objectElement_ToBytes tests the ToBytes method
func TestVariant_objectElement_ToBytes(t *testing.T) {
	elem := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVariant_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVariant_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVariant_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVariant_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVariant_objectElement_SaveAndLoad tests SaveToFile and LoadVariant_objectFromFile
func TestVariant_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Variant_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVariant_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVariant_objectElement_LoadFromBytes tests the LoadVariant_objectFromBytes function
func TestVariant_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<variant_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></variant_object>`)

	loaded, err := LoadVariant_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVariant_objectElementType_MarshalUnmarshal tests XML round-trip for Variant_objectElementType
func TestVariant_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Variant_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_stateElement_MarshalUnmarshal tests XML round-trip for Variant_stateElement
func TestVariant_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVariant_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVariant_stateElement_ToBytes tests the ToBytes method
func TestVariant_stateElement_ToBytes(t *testing.T) {
	elem := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVariant_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVariant_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVariant_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVariant_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVariant_stateElement_SaveAndLoad tests SaveToFile and LoadVariant_stateFromFile
func TestVariant_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Variant_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVariant_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVariant_stateElement_LoadFromBytes tests the LoadVariant_stateFromBytes function
func TestVariant_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<variant_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></variant_state>`)

	loaded, err := LoadVariant_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVariant_stateElementType_MarshalUnmarshal tests XML round-trip for Variant_stateElementType
func TestVariant_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Variant_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_testElement_MarshalUnmarshal tests XML round-trip for Variant_testElement
func TestVariant_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariant_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVariant_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVariant_testElement_ToBytes tests the ToBytes method
func TestVariant_testElement_ToBytes(t *testing.T) {
	elem := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVariant_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVariant_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVariant_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVariant_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVariant_testElement_SaveAndLoad tests SaveToFile and LoadVariant_testFromFile
func TestVariant_testElement_SaveAndLoad(t *testing.T) {
	elem := &Variant_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "variant_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVariant_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVariant_testElement_LoadFromBytes tests the LoadVariant_testFromBytes function
func TestVariant_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<variant_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></variant_test>`)

	loaded, err := LoadVariant_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVariant_testElementType_MarshalUnmarshal tests XML round-trip for Variant_testElementType
func TestVariant_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Variant_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Variant_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_objectElement_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_objectElement
func TestVirtualizationinfo_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVirtualizationinfo_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVirtualizationinfo_objectElement_ToBytes tests the ToBytes method
func TestVirtualizationinfo_objectElement_ToBytes(t *testing.T) {
	elem := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVirtualizationinfo_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVirtualizationinfo_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVirtualizationinfo_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_objectElement_SaveAndLoad tests SaveToFile and LoadVirtualizationinfo_objectFromFile
func TestVirtualizationinfo_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Virtualizationinfo_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVirtualizationinfo_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVirtualizationinfo_objectElement_LoadFromBytes tests the LoadVirtualizationinfo_objectFromBytes function
func TestVirtualizationinfo_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<virtualizationinfo_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></virtualizationinfo_object>`)

	loaded, err := LoadVirtualizationinfo_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVirtualizationinfo_objectElementType_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_objectElementType
func TestVirtualizationinfo_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_stateElement_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_stateElement
func TestVirtualizationinfo_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVirtualizationinfo_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVirtualizationinfo_stateElement_ToBytes tests the ToBytes method
func TestVirtualizationinfo_stateElement_ToBytes(t *testing.T) {
	elem := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVirtualizationinfo_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVirtualizationinfo_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVirtualizationinfo_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_stateElement_SaveAndLoad tests SaveToFile and LoadVirtualizationinfo_stateFromFile
func TestVirtualizationinfo_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Virtualizationinfo_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVirtualizationinfo_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVirtualizationinfo_stateElement_LoadFromBytes tests the LoadVirtualizationinfo_stateFromBytes function
func TestVirtualizationinfo_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<virtualizationinfo_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></virtualizationinfo_state>`)

	loaded, err := LoadVirtualizationinfo_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVirtualizationinfo_stateElementType_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_stateElementType
func TestVirtualizationinfo_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_testElement_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_testElement
func TestVirtualizationinfo_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVirtualizationinfo_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVirtualizationinfo_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVirtualizationinfo_testElement_ToBytes tests the ToBytes method
func TestVirtualizationinfo_testElement_ToBytes(t *testing.T) {
	elem := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVirtualizationinfo_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVirtualizationinfo_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVirtualizationinfo_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVirtualizationinfo_testElement_SaveAndLoad tests SaveToFile and LoadVirtualizationinfo_testFromFile
func TestVirtualizationinfo_testElement_SaveAndLoad(t *testing.T) {
	elem := &Virtualizationinfo_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris", Local: "virtualizationinfo_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVirtualizationinfo_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVirtualizationinfo_testElement_LoadFromBytes tests the LoadVirtualizationinfo_testFromBytes function
func TestVirtualizationinfo_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<virtualizationinfo_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#solaris"></virtualizationinfo_test>`)

	loaded, err := LoadVirtualizationinfo_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVirtualizationinfo_testElementType_MarshalUnmarshal tests XML round-trip for Virtualizationinfo_testElementType
func TestVirtualizationinfo_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Virtualizationinfo_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Virtualizationinfo_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
