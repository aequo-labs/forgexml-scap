// Package xmlschemaoval_definitions_5_unix - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_unix

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestA_timeElementType_MarshalUnmarshal tests XML round-trip for A_timeElementType
func TestA_timeElementType_MarshalUnmarshal(t *testing.T) {
	original := &A_timeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded A_timeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestC_timeElementType_MarshalUnmarshal tests XML round-trip for C_timeElementType
func TestC_timeElementType_MarshalUnmarshal(t *testing.T) {
	original := &C_timeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded C_timeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestChg_allowElementType_MarshalUnmarshal tests XML round-trip for Chg_allowElementType
func TestChg_allowElementType_MarshalUnmarshal(t *testing.T) {
	original := &Chg_allowElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Chg_allowElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestChg_lstElementType_MarshalUnmarshal tests XML round-trip for Chg_lstElementType
func TestChg_lstElementType_MarshalUnmarshal(t *testing.T) {
	original := &Chg_lstElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Chg_lstElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestChg_reqElementType_MarshalUnmarshal tests XML round-trip for Chg_reqElementType
func TestChg_reqElementType_MarshalUnmarshal(t *testing.T) {
	original := &Chg_reqElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Chg_reqElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_objectElement_MarshalUnmarshal tests XML round-trip for Dnscache_objectElement
func TestDnscache_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_objectElement_ToBytes tests the ToBytes method
func TestDnscache_objectElement_ToBytes(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_objectElement_SaveAndLoad tests SaveToFile and LoadDnscache_objectFromFile
func TestDnscache_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_objectElement_LoadFromBytes tests the LoadDnscache_objectFromBytes function
func TestDnscache_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></dnscache_object>`)

	loaded, err := LoadDnscache_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_objectElementType_MarshalUnmarshal tests XML round-trip for Dnscache_objectElementType
func TestDnscache_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_stateElement_MarshalUnmarshal tests XML round-trip for Dnscache_stateElement
func TestDnscache_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_stateElement_ToBytes tests the ToBytes method
func TestDnscache_stateElement_ToBytes(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_stateElement_SaveAndLoad tests SaveToFile and LoadDnscache_stateFromFile
func TestDnscache_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_stateElement_LoadFromBytes tests the LoadDnscache_stateFromBytes function
func TestDnscache_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></dnscache_state>`)

	loaded, err := LoadDnscache_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_stateElementType_MarshalUnmarshal tests XML round-trip for Dnscache_stateElementType
func TestDnscache_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_testElement_MarshalUnmarshal tests XML round-trip for Dnscache_testElement
func TestDnscache_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_testElement_ToBytes tests the ToBytes method
func TestDnscache_testElement_ToBytes(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_testElement_SaveAndLoad tests SaveToFile and LoadDnscache_testFromFile
func TestDnscache_testElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "dnscache_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_testElement_LoadFromBytes tests the LoadDnscache_testFromBytes function
func TestDnscache_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></dnscache_test>`)

	loaded, err := LoadDnscache_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_testElementType_MarshalUnmarshal tests XML round-trip for Dnscache_testElementType
func TestDnscache_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateCapabilityType_MarshalUnmarshal tests XML round-trip for EntityStateCapabilityType
func TestEntityStateCapabilityType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateCapabilityType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateCapabilityType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateEncryptMethodType_MarshalUnmarshal tests XML round-trip for EntityStateEncryptMethodType
func TestEntityStateEncryptMethodType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateEncryptMethodType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateEncryptMethodType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateEndpointType_MarshalUnmarshal tests XML round-trip for EntityStateEndpointType
func TestEntityStateEndpointType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateEndpointType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateEndpointType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateGconfTypeType_MarshalUnmarshal tests XML round-trip for EntityStateGconfTypeType
func TestEntityStateGconfTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateGconfTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateGconfTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateInterfaceType_MarshalUnmarshal tests XML round-trip for EntityStateInterfaceType
func TestEntityStateInterfaceType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateInterfaceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateInterfaceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateRoutingTableFlagsType_MarshalUnmarshal tests XML round-trip for EntityStateRoutingTableFlagsType
func TestEntityStateRoutingTableFlagsType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateRoutingTableFlagsType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateRoutingTableFlagsType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateWaitStatusType_MarshalUnmarshal tests XML round-trip for EntityStateWaitStatusType
func TestEntityStateWaitStatusType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateWaitStatusType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateWaitStatusType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateXinetdTypeStatusType_MarshalUnmarshal tests XML round-trip for EntityStateXinetdTypeStatusType
func TestEntityStateXinetdTypeStatusType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateXinetdTypeStatusType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateXinetdTypeStatusType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExp_dateElementType_MarshalUnmarshal tests XML round-trip for Exp_dateElementType
func TestExp_dateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Exp_dateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Exp_dateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExp_inactElementType_MarshalUnmarshal tests XML round-trip for Exp_inactElementType
func TestExp_inactElementType_MarshalUnmarshal(t *testing.T) {
	original := &Exp_inactElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Exp_inactElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExp_warnElementType_MarshalUnmarshal tests XML round-trip for Exp_warnElementType
func TestExp_warnElementType_MarshalUnmarshal(t *testing.T) {
	original := &Exp_warnElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Exp_warnElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileBehaviors_MarshalUnmarshal tests XML round-trip for FileBehaviors
func TestFileBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_objectElement_MarshalUnmarshal tests XML round-trip for File_objectElement
func TestFile_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_objectElement_ToBytes tests the ToBytes method
func TestFile_objectElement_ToBytes(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_objectElement_SaveAndLoad tests SaveToFile and LoadFile_objectFromFile
func TestFile_objectElement_SaveAndLoad(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_objectElement_LoadFromBytes tests the LoadFile_objectFromBytes function
func TestFile_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></file_object>`)

	loaded, err := LoadFile_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_objectElementType_MarshalUnmarshal tests XML round-trip for File_objectElementType
func TestFile_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_stateElement_MarshalUnmarshal tests XML round-trip for File_stateElement
func TestFile_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_stateElement_ToBytes tests the ToBytes method
func TestFile_stateElement_ToBytes(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_stateElement_SaveAndLoad tests SaveToFile and LoadFile_stateFromFile
func TestFile_stateElement_SaveAndLoad(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_stateElement_LoadFromBytes tests the LoadFile_stateFromBytes function
func TestFile_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></file_state>`)

	loaded, err := LoadFile_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_stateElementType_MarshalUnmarshal tests XML round-trip for File_stateElementType
func TestFile_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_testElement_MarshalUnmarshal tests XML round-trip for File_testElement
func TestFile_testElement_MarshalUnmarshal(t *testing.T) {
	original := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_testElement_MarshalIndentClean(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_testElement_ToBytes tests the ToBytes method
func TestFile_testElement_ToBytes(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_testElement_SetElementPrefixes(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_testElement_SaveAndLoad tests SaveToFile and LoadFile_testFromFile
func TestFile_testElement_SaveAndLoad(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "file_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_testElement_LoadFromBytes tests the LoadFile_testFromBytes function
func TestFile_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></file_test>`)

	loaded, err := LoadFile_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_testElementType_MarshalUnmarshal tests XML round-trip for File_testElementType
func TestFile_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_objectElement_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_objectElement
func TestFileextendedattribute_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileextendedattribute_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileextendedattribute_objectElement_ToBytes tests the ToBytes method
func TestFileextendedattribute_objectElement_ToBytes(t *testing.T) {
	elem := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileextendedattribute_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileextendedattribute_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileextendedattribute_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_objectElement_SaveAndLoad tests SaveToFile and LoadFileextendedattribute_objectFromFile
func TestFileextendedattribute_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Fileextendedattribute_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileextendedattribute_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileextendedattribute_objectElement_LoadFromBytes tests the LoadFileextendedattribute_objectFromBytes function
func TestFileextendedattribute_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileextendedattribute_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></fileextendedattribute_object>`)

	loaded, err := LoadFileextendedattribute_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileextendedattribute_objectElementType_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_objectElementType
func TestFileextendedattribute_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_stateElement_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_stateElement
func TestFileextendedattribute_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileextendedattribute_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileextendedattribute_stateElement_ToBytes tests the ToBytes method
func TestFileextendedattribute_stateElement_ToBytes(t *testing.T) {
	elem := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileextendedattribute_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileextendedattribute_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileextendedattribute_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_stateElement_SaveAndLoad tests SaveToFile and LoadFileextendedattribute_stateFromFile
func TestFileextendedattribute_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Fileextendedattribute_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileextendedattribute_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileextendedattribute_stateElement_LoadFromBytes tests the LoadFileextendedattribute_stateFromBytes function
func TestFileextendedattribute_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileextendedattribute_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></fileextendedattribute_state>`)

	loaded, err := LoadFileextendedattribute_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileextendedattribute_stateElementType_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_stateElementType
func TestFileextendedattribute_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_testElement_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_testElement
func TestFileextendedattribute_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileextendedattribute_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileextendedattribute_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileextendedattribute_testElement_ToBytes tests the ToBytes method
func TestFileextendedattribute_testElement_ToBytes(t *testing.T) {
	elem := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileextendedattribute_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileextendedattribute_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileextendedattribute_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileextendedattribute_testElement_SaveAndLoad tests SaveToFile and LoadFileextendedattribute_testFromFile
func TestFileextendedattribute_testElement_SaveAndLoad(t *testing.T) {
	elem := &Fileextendedattribute_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "fileextendedattribute_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileextendedattribute_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileextendedattribute_testElement_LoadFromBytes tests the LoadFileextendedattribute_testFromBytes function
func TestFileextendedattribute_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileextendedattribute_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></fileextendedattribute_test>`)

	loaded, err := LoadFileextendedattribute_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileextendedattribute_testElementType_MarshalUnmarshal tests XML round-trip for Fileextendedattribute_testElementType
func TestFileextendedattribute_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileextendedattribute_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileextendedattribute_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFlagElementType_MarshalUnmarshal tests XML round-trip for FlagElementType
func TestFlagElementType_MarshalUnmarshal(t *testing.T) {
	original := &FlagElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FlagElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_objectElement_MarshalUnmarshal tests XML round-trip for Gconf_objectElement
func TestGconf_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGconf_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGconf_objectElement_ToBytes tests the ToBytes method
func TestGconf_objectElement_ToBytes(t *testing.T) {
	elem := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGconf_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGconf_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGconf_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGconf_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGconf_objectElement_SaveAndLoad tests SaveToFile and LoadGconf_objectFromFile
func TestGconf_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Gconf_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGconf_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGconf_objectElement_LoadFromBytes tests the LoadGconf_objectFromBytes function
func TestGconf_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gconf_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></gconf_object>`)

	loaded, err := LoadGconf_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGconf_objectElementType_MarshalUnmarshal tests XML round-trip for Gconf_objectElementType
func TestGconf_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_stateElement_MarshalUnmarshal tests XML round-trip for Gconf_stateElement
func TestGconf_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGconf_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGconf_stateElement_ToBytes tests the ToBytes method
func TestGconf_stateElement_ToBytes(t *testing.T) {
	elem := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGconf_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGconf_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGconf_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGconf_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGconf_stateElement_SaveAndLoad tests SaveToFile and LoadGconf_stateFromFile
func TestGconf_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Gconf_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGconf_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGconf_stateElement_LoadFromBytes tests the LoadGconf_stateFromBytes function
func TestGconf_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gconf_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></gconf_state>`)

	loaded, err := LoadGconf_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGconf_stateElementType_MarshalUnmarshal tests XML round-trip for Gconf_stateElementType
func TestGconf_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_testElement_MarshalUnmarshal tests XML round-trip for Gconf_testElement
func TestGconf_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGconf_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGconf_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGconf_testElement_ToBytes tests the ToBytes method
func TestGconf_testElement_ToBytes(t *testing.T) {
	elem := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGconf_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGconf_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGconf_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGconf_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGconf_testElement_SaveAndLoad tests SaveToFile and LoadGconf_testFromFile
func TestGconf_testElement_SaveAndLoad(t *testing.T) {
	elem := &Gconf_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "gconf_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGconf_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGconf_testElement_LoadFromBytes tests the LoadGconf_testFromBytes function
func TestGconf_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<gconf_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></gconf_test>`)

	loaded, err := LoadGconf_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGconf_testElementType_MarshalUnmarshal tests XML round-trip for Gconf_testElementType
func TestGconf_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Gconf_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Gconf_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_idElementType_MarshalUnmarshal tests XML round-trip for Group_idElementType
func TestGroup_idElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_idElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_idElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_idElementType1_MarshalUnmarshal tests XML round-trip for Group_idElementType1
func TestGroup_idElementType1_MarshalUnmarshal(t *testing.T) {
	original := &Group_idElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_idElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_objectElement_MarshalUnmarshal tests XML round-trip for Inetd_objectElement
func TestInetd_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetd_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetd_objectElement_ToBytes tests the ToBytes method
func TestInetd_objectElement_ToBytes(t *testing.T) {
	elem := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetd_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetd_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetd_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetd_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetd_objectElement_SaveAndLoad tests SaveToFile and LoadInetd_objectFromFile
func TestInetd_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Inetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetd_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetd_objectElement_LoadFromBytes tests the LoadInetd_objectFromBytes function
func TestInetd_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetd_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></inetd_object>`)

	loaded, err := LoadInetd_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetd_objectElementType_MarshalUnmarshal tests XML round-trip for Inetd_objectElementType
func TestInetd_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_stateElement_MarshalUnmarshal tests XML round-trip for Inetd_stateElement
func TestInetd_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetd_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetd_stateElement_ToBytes tests the ToBytes method
func TestInetd_stateElement_ToBytes(t *testing.T) {
	elem := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetd_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetd_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetd_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetd_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetd_stateElement_SaveAndLoad tests SaveToFile and LoadInetd_stateFromFile
func TestInetd_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Inetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetd_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetd_stateElement_LoadFromBytes tests the LoadInetd_stateFromBytes function
func TestInetd_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetd_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></inetd_state>`)

	loaded, err := LoadInetd_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetd_stateElementType_MarshalUnmarshal tests XML round-trip for Inetd_stateElementType
func TestInetd_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_testElement_MarshalUnmarshal tests XML round-trip for Inetd_testElement
func TestInetd_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInetd_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInetd_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInetd_testElement_ToBytes tests the ToBytes method
func TestInetd_testElement_ToBytes(t *testing.T) {
	elem := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInetd_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInetd_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInetd_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInetd_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInetd_testElement_SaveAndLoad tests SaveToFile and LoadInetd_testFromFile
func TestInetd_testElement_SaveAndLoad(t *testing.T) {
	elem := &Inetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "inetd_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInetd_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInetd_testElement_LoadFromBytes tests the LoadInetd_testFromBytes function
func TestInetd_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<inetd_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></inetd_test>`)

	loaded, err := LoadInetd_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInetd_testElementType_MarshalUnmarshal tests XML round-trip for Inetd_testElementType
func TestInetd_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Inetd_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Inetd_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalUnmarshal tests XML round-trip for Interface_objectElement
func TestInterface_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_objectElement_ToBytes tests the ToBytes method
func TestInterface_objectElement_ToBytes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SaveAndLoad tests SaveToFile and LoadInterface_objectFromFile
func TestInterface_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_objectElement_LoadFromBytes tests the LoadInterface_objectFromBytes function
func TestInterface_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></interface_object>`)

	loaded, err := LoadInterface_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_objectElementType_MarshalUnmarshal tests XML round-trip for Interface_objectElementType
func TestInterface_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalUnmarshal tests XML round-trip for Interface_stateElement
func TestInterface_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_stateElement_ToBytes tests the ToBytes method
func TestInterface_stateElement_ToBytes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SaveAndLoad tests SaveToFile and LoadInterface_stateFromFile
func TestInterface_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_stateElement_LoadFromBytes tests the LoadInterface_stateFromBytes function
func TestInterface_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></interface_state>`)

	loaded, err := LoadInterface_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_stateElementType_MarshalUnmarshal tests XML round-trip for Interface_stateElementType
func TestInterface_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalUnmarshal tests XML round-trip for Interface_testElement
func TestInterface_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_testElement_ToBytes tests the ToBytes method
func TestInterface_testElement_ToBytes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SaveAndLoad tests SaveToFile and LoadInterface_testFromFile
func TestInterface_testElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "interface_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_testElement_LoadFromBytes tests the LoadInterface_testFromBytes function
func TestInterface_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></interface_test>`)

	loaded, err := LoadInterface_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_testElementType_MarshalUnmarshal tests XML round-trip for Interface_testElementType
func TestInterface_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestM_timeElementType_MarshalUnmarshal tests XML round-trip for M_timeElementType
func TestM_timeElementType_MarshalUnmarshal(t *testing.T) {
	original := &M_timeElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded M_timeElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_objectElement_MarshalUnmarshal tests XML round-trip for Password_objectElement
func TestPassword_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPassword_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPassword_objectElement_ToBytes tests the ToBytes method
func TestPassword_objectElement_ToBytes(t *testing.T) {
	elem := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPassword_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPassword_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPassword_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPassword_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPassword_objectElement_SaveAndLoad tests SaveToFile and LoadPassword_objectFromFile
func TestPassword_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Password_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPassword_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPassword_objectElement_LoadFromBytes tests the LoadPassword_objectFromBytes function
func TestPassword_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<password_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></password_object>`)

	loaded, err := LoadPassword_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPassword_objectElementType_MarshalUnmarshal tests XML round-trip for Password_objectElementType
func TestPassword_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Password_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_stateElement_MarshalUnmarshal tests XML round-trip for Password_stateElement
func TestPassword_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPassword_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPassword_stateElement_ToBytes tests the ToBytes method
func TestPassword_stateElement_ToBytes(t *testing.T) {
	elem := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPassword_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPassword_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPassword_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPassword_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPassword_stateElement_SaveAndLoad tests SaveToFile and LoadPassword_stateFromFile
func TestPassword_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Password_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPassword_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPassword_stateElement_LoadFromBytes tests the LoadPassword_stateFromBytes function
func TestPassword_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<password_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></password_state>`)

	loaded, err := LoadPassword_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPassword_stateElementType_MarshalUnmarshal tests XML round-trip for Password_stateElementType
func TestPassword_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Password_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_testElement_MarshalUnmarshal tests XML round-trip for Password_testElement
func TestPassword_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPassword_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPassword_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPassword_testElement_ToBytes tests the ToBytes method
func TestPassword_testElement_ToBytes(t *testing.T) {
	elem := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPassword_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPassword_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPassword_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPassword_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPassword_testElement_SaveAndLoad tests SaveToFile and LoadPassword_testFromFile
func TestPassword_testElement_SaveAndLoad(t *testing.T) {
	elem := &Password_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "password_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPassword_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPassword_testElement_LoadFromBytes tests the LoadPassword_testFromBytes function
func TestPassword_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<password_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></password_test>`)

	loaded, err := LoadPassword_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPassword_testElementType_MarshalUnmarshal tests XML round-trip for Password_testElementType
func TestPassword_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Password_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Password_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_objectElement_MarshalUnmarshal tests XML round-trip for Process58_objectElement
func TestProcess58_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_objectElement_ToBytes tests the ToBytes method
func TestProcess58_objectElement_ToBytes(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_objectElement_SaveAndLoad tests SaveToFile and LoadProcess58_objectFromFile
func TestProcess58_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_objectElement_LoadFromBytes tests the LoadProcess58_objectFromBytes function
func TestProcess58_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process58_object>`)

	loaded, err := LoadProcess58_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_objectElementType_MarshalUnmarshal tests XML round-trip for Process58_objectElementType
func TestProcess58_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_stateElement_MarshalUnmarshal tests XML round-trip for Process58_stateElement
func TestProcess58_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_stateElement_ToBytes tests the ToBytes method
func TestProcess58_stateElement_ToBytes(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_stateElement_SaveAndLoad tests SaveToFile and LoadProcess58_stateFromFile
func TestProcess58_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_stateElement_LoadFromBytes tests the LoadProcess58_stateFromBytes function
func TestProcess58_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process58_state>`)

	loaded, err := LoadProcess58_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_stateElementType_MarshalUnmarshal tests XML round-trip for Process58_stateElementType
func TestProcess58_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_testElement_MarshalUnmarshal tests XML round-trip for Process58_testElement
func TestProcess58_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_testElement_ToBytes tests the ToBytes method
func TestProcess58_testElement_ToBytes(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_testElement_SaveAndLoad tests SaveToFile and LoadProcess58_testFromFile
func TestProcess58_testElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process58_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_testElement_LoadFromBytes tests the LoadProcess58_testFromBytes function
func TestProcess58_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process58_test>`)

	loaded, err := LoadProcess58_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_testElementType_MarshalUnmarshal tests XML round-trip for Process58_testElementType
func TestProcess58_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_objectElement_MarshalUnmarshal tests XML round-trip for Process_objectElement
func TestProcess_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_objectElement_ToBytes tests the ToBytes method
func TestProcess_objectElement_ToBytes(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_objectElement_SaveAndLoad tests SaveToFile and LoadProcess_objectFromFile
func TestProcess_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_objectElement_LoadFromBytes tests the LoadProcess_objectFromBytes function
func TestProcess_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process_object>`)

	loaded, err := LoadProcess_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_objectElementType_MarshalUnmarshal tests XML round-trip for Process_objectElementType
func TestProcess_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_stateElement_MarshalUnmarshal tests XML round-trip for Process_stateElement
func TestProcess_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_stateElement_ToBytes tests the ToBytes method
func TestProcess_stateElement_ToBytes(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_stateElement_SaveAndLoad tests SaveToFile and LoadProcess_stateFromFile
func TestProcess_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_stateElement_LoadFromBytes tests the LoadProcess_stateFromBytes function
func TestProcess_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process_state>`)

	loaded, err := LoadProcess_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_stateElementType_MarshalUnmarshal tests XML round-trip for Process_stateElementType
func TestProcess_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_testElement_MarshalUnmarshal tests XML round-trip for Process_testElement
func TestProcess_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_testElement_ToBytes tests the ToBytes method
func TestProcess_testElement_ToBytes(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_testElement_SaveAndLoad tests SaveToFile and LoadProcess_testFromFile
func TestProcess_testElement_SaveAndLoad(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "process_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_testElement_LoadFromBytes tests the LoadProcess_testFromBytes function
func TestProcess_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></process_test>`)

	loaded, err := LoadProcess_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_testElementType_MarshalUnmarshal tests XML round-trip for Process_testElementType
func TestProcess_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_objectElement_MarshalUnmarshal tests XML round-trip for Routingtable_objectElement
func TestRoutingtable_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRoutingtable_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRoutingtable_objectElement_ToBytes tests the ToBytes method
func TestRoutingtable_objectElement_ToBytes(t *testing.T) {
	elem := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRoutingtable_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRoutingtable_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRoutingtable_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRoutingtable_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRoutingtable_objectElement_SaveAndLoad tests SaveToFile and LoadRoutingtable_objectFromFile
func TestRoutingtable_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Routingtable_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRoutingtable_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRoutingtable_objectElement_LoadFromBytes tests the LoadRoutingtable_objectFromBytes function
func TestRoutingtable_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<routingtable_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></routingtable_object>`)

	loaded, err := LoadRoutingtable_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRoutingtable_objectElementType_MarshalUnmarshal tests XML round-trip for Routingtable_objectElementType
func TestRoutingtable_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_stateElement_MarshalUnmarshal tests XML round-trip for Routingtable_stateElement
func TestRoutingtable_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRoutingtable_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRoutingtable_stateElement_ToBytes tests the ToBytes method
func TestRoutingtable_stateElement_ToBytes(t *testing.T) {
	elem := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRoutingtable_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRoutingtable_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRoutingtable_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRoutingtable_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRoutingtable_stateElement_SaveAndLoad tests SaveToFile and LoadRoutingtable_stateFromFile
func TestRoutingtable_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Routingtable_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRoutingtable_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRoutingtable_stateElement_LoadFromBytes tests the LoadRoutingtable_stateFromBytes function
func TestRoutingtable_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<routingtable_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></routingtable_state>`)

	loaded, err := LoadRoutingtable_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRoutingtable_stateElementType_MarshalUnmarshal tests XML round-trip for Routingtable_stateElementType
func TestRoutingtable_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_testElement_MarshalUnmarshal tests XML round-trip for Routingtable_testElement
func TestRoutingtable_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRoutingtable_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRoutingtable_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRoutingtable_testElement_ToBytes tests the ToBytes method
func TestRoutingtable_testElement_ToBytes(t *testing.T) {
	elem := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRoutingtable_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRoutingtable_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRoutingtable_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRoutingtable_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRoutingtable_testElement_SaveAndLoad tests SaveToFile and LoadRoutingtable_testFromFile
func TestRoutingtable_testElement_SaveAndLoad(t *testing.T) {
	elem := &Routingtable_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "routingtable_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRoutingtable_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRoutingtable_testElement_LoadFromBytes tests the LoadRoutingtable_testFromBytes function
func TestRoutingtable_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<routingtable_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></routingtable_test>`)

	loaded, err := LoadRoutingtable_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRoutingtable_testElementType_MarshalUnmarshal tests XML round-trip for Routingtable_testElementType
func TestRoutingtable_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Routingtable_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Routingtable_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_objectElement_MarshalUnmarshal tests XML round-trip for Runlevel_objectElement
func TestRunlevel_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRunlevel_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRunlevel_objectElement_ToBytes tests the ToBytes method
func TestRunlevel_objectElement_ToBytes(t *testing.T) {
	elem := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRunlevel_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRunlevel_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRunlevel_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRunlevel_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRunlevel_objectElement_SaveAndLoad tests SaveToFile and LoadRunlevel_objectFromFile
func TestRunlevel_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Runlevel_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRunlevel_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRunlevel_objectElement_LoadFromBytes tests the LoadRunlevel_objectFromBytes function
func TestRunlevel_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<runlevel_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></runlevel_object>`)

	loaded, err := LoadRunlevel_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRunlevel_objectElementType_MarshalUnmarshal tests XML round-trip for Runlevel_objectElementType
func TestRunlevel_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_stateElement_MarshalUnmarshal tests XML round-trip for Runlevel_stateElement
func TestRunlevel_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRunlevel_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRunlevel_stateElement_ToBytes tests the ToBytes method
func TestRunlevel_stateElement_ToBytes(t *testing.T) {
	elem := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRunlevel_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRunlevel_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRunlevel_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRunlevel_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRunlevel_stateElement_SaveAndLoad tests SaveToFile and LoadRunlevel_stateFromFile
func TestRunlevel_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Runlevel_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRunlevel_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRunlevel_stateElement_LoadFromBytes tests the LoadRunlevel_stateFromBytes function
func TestRunlevel_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<runlevel_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></runlevel_state>`)

	loaded, err := LoadRunlevel_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRunlevel_stateElementType_MarshalUnmarshal tests XML round-trip for Runlevel_stateElementType
func TestRunlevel_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_testElement_MarshalUnmarshal tests XML round-trip for Runlevel_testElement
func TestRunlevel_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRunlevel_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRunlevel_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRunlevel_testElement_ToBytes tests the ToBytes method
func TestRunlevel_testElement_ToBytes(t *testing.T) {
	elem := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRunlevel_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRunlevel_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRunlevel_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRunlevel_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRunlevel_testElement_SaveAndLoad tests SaveToFile and LoadRunlevel_testFromFile
func TestRunlevel_testElement_SaveAndLoad(t *testing.T) {
	elem := &Runlevel_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "runlevel_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRunlevel_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRunlevel_testElement_LoadFromBytes tests the LoadRunlevel_testFromBytes function
func TestRunlevel_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<runlevel_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></runlevel_test>`)

	loaded, err := LoadRunlevel_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRunlevel_testElementType_MarshalUnmarshal tests XML round-trip for Runlevel_testElementType
func TestRunlevel_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Runlevel_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Runlevel_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_objectElement_MarshalUnmarshal tests XML round-trip for Sccs_objectElement
func TestSccs_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSccs_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSccs_objectElement_ToBytes tests the ToBytes method
func TestSccs_objectElement_ToBytes(t *testing.T) {
	elem := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSccs_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSccs_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSccs_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSccs_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSccs_objectElement_SaveAndLoad tests SaveToFile and LoadSccs_objectFromFile
func TestSccs_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sccs_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSccs_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSccs_objectElement_LoadFromBytes tests the LoadSccs_objectFromBytes function
func TestSccs_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sccs_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sccs_object>`)

	loaded, err := LoadSccs_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSccs_objectElementType_MarshalUnmarshal tests XML round-trip for Sccs_objectElementType
func TestSccs_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_stateElement_MarshalUnmarshal tests XML round-trip for Sccs_stateElement
func TestSccs_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSccs_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSccs_stateElement_ToBytes tests the ToBytes method
func TestSccs_stateElement_ToBytes(t *testing.T) {
	elem := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSccs_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSccs_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSccs_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSccs_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSccs_stateElement_SaveAndLoad tests SaveToFile and LoadSccs_stateFromFile
func TestSccs_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sccs_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSccs_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSccs_stateElement_LoadFromBytes tests the LoadSccs_stateFromBytes function
func TestSccs_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sccs_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sccs_state>`)

	loaded, err := LoadSccs_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSccs_stateElementType_MarshalUnmarshal tests XML round-trip for Sccs_stateElementType
func TestSccs_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_testElement_MarshalUnmarshal tests XML round-trip for Sccs_testElement
func TestSccs_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSccs_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSccs_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSccs_testElement_ToBytes tests the ToBytes method
func TestSccs_testElement_ToBytes(t *testing.T) {
	elem := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSccs_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSccs_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSccs_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSccs_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSccs_testElement_SaveAndLoad tests SaveToFile and LoadSccs_testFromFile
func TestSccs_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sccs_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sccs_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSccs_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSccs_testElement_LoadFromBytes tests the LoadSccs_testFromBytes function
func TestSccs_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sccs_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sccs_test>`)

	loaded, err := LoadSccs_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSccs_testElementType_MarshalUnmarshal tests XML round-trip for Sccs_testElementType
func TestSccs_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sccs_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sccs_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_objectElement_MarshalUnmarshal tests XML round-trip for Shadow_objectElement
func TestShadow_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestShadow_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestShadow_objectElement_ToBytes tests the ToBytes method
func TestShadow_objectElement_ToBytes(t *testing.T) {
	elem := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestShadow_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestShadow_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestShadow_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestShadow_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestShadow_objectElement_SaveAndLoad tests SaveToFile and LoadShadow_objectFromFile
func TestShadow_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Shadow_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadShadow_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestShadow_objectElement_LoadFromBytes tests the LoadShadow_objectFromBytes function
func TestShadow_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<shadow_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></shadow_object>`)

	loaded, err := LoadShadow_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestShadow_objectElementType_MarshalUnmarshal tests XML round-trip for Shadow_objectElementType
func TestShadow_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_stateElement_MarshalUnmarshal tests XML round-trip for Shadow_stateElement
func TestShadow_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestShadow_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestShadow_stateElement_ToBytes tests the ToBytes method
func TestShadow_stateElement_ToBytes(t *testing.T) {
	elem := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestShadow_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestShadow_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestShadow_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestShadow_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestShadow_stateElement_SaveAndLoad tests SaveToFile and LoadShadow_stateFromFile
func TestShadow_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Shadow_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadShadow_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestShadow_stateElement_LoadFromBytes tests the LoadShadow_stateFromBytes function
func TestShadow_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<shadow_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></shadow_state>`)

	loaded, err := LoadShadow_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestShadow_stateElementType_MarshalUnmarshal tests XML round-trip for Shadow_stateElementType
func TestShadow_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_testElement_MarshalUnmarshal tests XML round-trip for Shadow_testElement
func TestShadow_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestShadow_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestShadow_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestShadow_testElement_ToBytes tests the ToBytes method
func TestShadow_testElement_ToBytes(t *testing.T) {
	elem := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestShadow_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestShadow_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestShadow_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestShadow_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestShadow_testElement_SaveAndLoad tests SaveToFile and LoadShadow_testFromFile
func TestShadow_testElement_SaveAndLoad(t *testing.T) {
	elem := &Shadow_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "shadow_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadShadow_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestShadow_testElement_LoadFromBytes tests the LoadShadow_testFromBytes function
func TestShadow_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<shadow_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></shadow_test>`)

	loaded, err := LoadShadow_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestShadow_testElementType_MarshalUnmarshal tests XML round-trip for Shadow_testElementType
func TestShadow_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Shadow_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Shadow_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_objectElement_MarshalUnmarshal tests XML round-trip for Symlink_objectElement
func TestSymlink_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSymlink_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSymlink_objectElement_ToBytes tests the ToBytes method
func TestSymlink_objectElement_ToBytes(t *testing.T) {
	elem := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSymlink_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSymlink_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSymlink_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSymlink_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSymlink_objectElement_SaveAndLoad tests SaveToFile and LoadSymlink_objectFromFile
func TestSymlink_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Symlink_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSymlink_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSymlink_objectElement_LoadFromBytes tests the LoadSymlink_objectFromBytes function
func TestSymlink_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<symlink_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></symlink_object>`)

	loaded, err := LoadSymlink_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSymlink_objectElementType_MarshalUnmarshal tests XML round-trip for Symlink_objectElementType
func TestSymlink_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_stateElement_MarshalUnmarshal tests XML round-trip for Symlink_stateElement
func TestSymlink_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSymlink_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSymlink_stateElement_ToBytes tests the ToBytes method
func TestSymlink_stateElement_ToBytes(t *testing.T) {
	elem := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSymlink_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSymlink_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSymlink_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSymlink_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSymlink_stateElement_SaveAndLoad tests SaveToFile and LoadSymlink_stateFromFile
func TestSymlink_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Symlink_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSymlink_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSymlink_stateElement_LoadFromBytes tests the LoadSymlink_stateFromBytes function
func TestSymlink_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<symlink_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></symlink_state>`)

	loaded, err := LoadSymlink_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSymlink_stateElementType_MarshalUnmarshal tests XML round-trip for Symlink_stateElementType
func TestSymlink_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_testElement_MarshalUnmarshal tests XML round-trip for Symlink_testElement
func TestSymlink_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSymlink_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSymlink_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSymlink_testElement_ToBytes tests the ToBytes method
func TestSymlink_testElement_ToBytes(t *testing.T) {
	elem := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSymlink_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSymlink_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSymlink_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSymlink_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSymlink_testElement_SaveAndLoad tests SaveToFile and LoadSymlink_testFromFile
func TestSymlink_testElement_SaveAndLoad(t *testing.T) {
	elem := &Symlink_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "symlink_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSymlink_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSymlink_testElement_LoadFromBytes tests the LoadSymlink_testFromBytes function
func TestSymlink_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<symlink_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></symlink_test>`)

	loaded, err := LoadSymlink_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSymlink_testElementType_MarshalUnmarshal tests XML round-trip for Symlink_testElementType
func TestSymlink_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Symlink_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Symlink_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_objectElement_MarshalUnmarshal tests XML round-trip for Sysctl_objectElement
func TestSysctl_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSysctl_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSysctl_objectElement_ToBytes tests the ToBytes method
func TestSysctl_objectElement_ToBytes(t *testing.T) {
	elem := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSysctl_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSysctl_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSysctl_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSysctl_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSysctl_objectElement_SaveAndLoad tests SaveToFile and LoadSysctl_objectFromFile
func TestSysctl_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sysctl_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSysctl_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSysctl_objectElement_LoadFromBytes tests the LoadSysctl_objectFromBytes function
func TestSysctl_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sysctl_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sysctl_object>`)

	loaded, err := LoadSysctl_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSysctl_objectElementType_MarshalUnmarshal tests XML round-trip for Sysctl_objectElementType
func TestSysctl_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_stateElement_MarshalUnmarshal tests XML round-trip for Sysctl_stateElement
func TestSysctl_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSysctl_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSysctl_stateElement_ToBytes tests the ToBytes method
func TestSysctl_stateElement_ToBytes(t *testing.T) {
	elem := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSysctl_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSysctl_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSysctl_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSysctl_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSysctl_stateElement_SaveAndLoad tests SaveToFile and LoadSysctl_stateFromFile
func TestSysctl_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sysctl_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSysctl_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSysctl_stateElement_LoadFromBytes tests the LoadSysctl_stateFromBytes function
func TestSysctl_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sysctl_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sysctl_state>`)

	loaded, err := LoadSysctl_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSysctl_stateElementType_MarshalUnmarshal tests XML round-trip for Sysctl_stateElementType
func TestSysctl_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_testElement_MarshalUnmarshal tests XML round-trip for Sysctl_testElement
func TestSysctl_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSysctl_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSysctl_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSysctl_testElement_ToBytes tests the ToBytes method
func TestSysctl_testElement_ToBytes(t *testing.T) {
	elem := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSysctl_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSysctl_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSysctl_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSysctl_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSysctl_testElement_SaveAndLoad tests SaveToFile and LoadSysctl_testFromFile
func TestSysctl_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sysctl_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "sysctl_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSysctl_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSysctl_testElement_LoadFromBytes tests the LoadSysctl_testFromBytes function
func TestSysctl_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sysctl_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></sysctl_test>`)

	loaded, err := LoadSysctl_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSysctl_testElementType_MarshalUnmarshal tests XML round-trip for Sysctl_testElementType
func TestSysctl_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sysctl_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sysctl_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_objectElement_MarshalUnmarshal tests XML round-trip for Uname_objectElement
func TestUname_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUname_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUname_objectElement_ToBytes tests the ToBytes method
func TestUname_objectElement_ToBytes(t *testing.T) {
	elem := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUname_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUname_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUname_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUname_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUname_objectElement_SaveAndLoad tests SaveToFile and LoadUname_objectFromFile
func TestUname_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Uname_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUname_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUname_objectElement_LoadFromBytes tests the LoadUname_objectFromBytes function
func TestUname_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uname_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></uname_object>`)

	loaded, err := LoadUname_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUname_objectElementType_MarshalUnmarshal tests XML round-trip for Uname_objectElementType
func TestUname_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uname_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_stateElement_MarshalUnmarshal tests XML round-trip for Uname_stateElement
func TestUname_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUname_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUname_stateElement_ToBytes tests the ToBytes method
func TestUname_stateElement_ToBytes(t *testing.T) {
	elem := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUname_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUname_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUname_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUname_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUname_stateElement_SaveAndLoad tests SaveToFile and LoadUname_stateFromFile
func TestUname_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Uname_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUname_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUname_stateElement_LoadFromBytes tests the LoadUname_stateFromBytes function
func TestUname_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uname_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></uname_state>`)

	loaded, err := LoadUname_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUname_stateElementType_MarshalUnmarshal tests XML round-trip for Uname_stateElementType
func TestUname_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uname_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_testElement_MarshalUnmarshal tests XML round-trip for Uname_testElement
func TestUname_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUname_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUname_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUname_testElement_ToBytes tests the ToBytes method
func TestUname_testElement_ToBytes(t *testing.T) {
	elem := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUname_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUname_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUname_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUname_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUname_testElement_SaveAndLoad tests SaveToFile and LoadUname_testFromFile
func TestUname_testElement_SaveAndLoad(t *testing.T) {
	elem := &Uname_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "uname_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUname_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUname_testElement_LoadFromBytes tests the LoadUname_testFromBytes function
func TestUname_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uname_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></uname_test>`)

	loaded, err := LoadUname_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUname_testElementType_MarshalUnmarshal tests XML round-trip for Uname_testElementType
func TestUname_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uname_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uname_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_idElementType_MarshalUnmarshal tests XML round-trip for User_idElementType
func TestUser_idElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_idElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_idElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_idElementType1_MarshalUnmarshal tests XML round-trip for User_idElementType1
func TestUser_idElementType1_MarshalUnmarshal(t *testing.T) {
	original := &User_idElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_idElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_objectElement_MarshalUnmarshal tests XML round-trip for Xinetd_objectElement
func TestXinetd_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestXinetd_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestXinetd_objectElement_ToBytes tests the ToBytes method
func TestXinetd_objectElement_ToBytes(t *testing.T) {
	elem := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestXinetd_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestXinetd_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestXinetd_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestXinetd_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestXinetd_objectElement_SaveAndLoad tests SaveToFile and LoadXinetd_objectFromFile
func TestXinetd_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Xinetd_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadXinetd_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestXinetd_objectElement_LoadFromBytes tests the LoadXinetd_objectFromBytes function
func TestXinetd_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<xinetd_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></xinetd_object>`)

	loaded, err := LoadXinetd_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestXinetd_objectElementType_MarshalUnmarshal tests XML round-trip for Xinetd_objectElementType
func TestXinetd_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_stateElement_MarshalUnmarshal tests XML round-trip for Xinetd_stateElement
func TestXinetd_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestXinetd_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestXinetd_stateElement_ToBytes tests the ToBytes method
func TestXinetd_stateElement_ToBytes(t *testing.T) {
	elem := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestXinetd_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestXinetd_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestXinetd_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestXinetd_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestXinetd_stateElement_SaveAndLoad tests SaveToFile and LoadXinetd_stateFromFile
func TestXinetd_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Xinetd_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadXinetd_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestXinetd_stateElement_LoadFromBytes tests the LoadXinetd_stateFromBytes function
func TestXinetd_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<xinetd_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></xinetd_state>`)

	loaded, err := LoadXinetd_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestXinetd_stateElementType_MarshalUnmarshal tests XML round-trip for Xinetd_stateElementType
func TestXinetd_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_testElement_MarshalUnmarshal tests XML round-trip for Xinetd_testElement
func TestXinetd_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestXinetd_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestXinetd_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestXinetd_testElement_ToBytes tests the ToBytes method
func TestXinetd_testElement_ToBytes(t *testing.T) {
	elem := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestXinetd_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestXinetd_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestXinetd_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestXinetd_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestXinetd_testElement_SaveAndLoad tests SaveToFile and LoadXinetd_testFromFile
func TestXinetd_testElement_SaveAndLoad(t *testing.T) {
	elem := &Xinetd_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#unix", Local: "xinetd_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadXinetd_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestXinetd_testElement_LoadFromBytes tests the LoadXinetd_testFromBytes function
func TestXinetd_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<xinetd_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#unix"></xinetd_test>`)

	loaded, err := LoadXinetd_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestXinetd_testElementType_MarshalUnmarshal tests XML round-trip for Xinetd_testElementType
func TestXinetd_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Xinetd_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Xinetd_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
