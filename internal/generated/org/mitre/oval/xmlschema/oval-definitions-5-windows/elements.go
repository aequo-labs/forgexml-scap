// Package xmlschemaoval_definitions_5_windows generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-definitions-5#windows
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/windows-definitions-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_windows

import (
	"encoding/xml"
	"os"
	"strings"

	xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	xmlschemaoval_results_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-results-5"
	xmlschemaoval_system_characteristics_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-system-characteristics-5"
	pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// Uac_testElement represents the XSD element 'uac_test'
// XSD element declaration (W3C XSD §3.3)
type Uac_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows uac_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Uac_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Uac_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Uac_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Uac_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Uac_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Uac_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Uac_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Uac_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Uac_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUac_testFromBytes loads an element from bytes with namespace preservation
func LoadUac_testFromBytes(data []byte) (*Uac_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Uac_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUac_testFromFile loads an element from a file with namespace preservation
func LoadUac_testFromFile(path string) (*Uac_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUac_testFromBytes(data)
}

// Volume_testElement represents the XSD element 'volume_test'
// XSD element declaration (W3C XSD §3.3)
type Volume_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows volume_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Volume_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Volume_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Volume_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Volume_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Volume_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Volume_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Volume_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Volume_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Volume_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadVolume_testFromBytes loads an element from bytes with namespace preservation
func LoadVolume_testFromBytes(data []byte) (*Volume_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Volume_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadVolume_testFromFile loads an element from a file with namespace preservation
func LoadVolume_testFromFile(path string) (*Volume_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadVolume_testFromBytes(data)
}

// Regkeyauditedpermissions_stateElement represents the XSD element 'regkeyauditedpermissions_state'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Hive represents XSD element 'hive'
	// minOccurs=0, maxOccurs=1
	Hive *EntityStateRegistryHiveType `xml:"hive,omitempty"`
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *EntityStateAuditType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *EntityStateAuditType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *EntityStateAuditType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *EntityStateAuditType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *EntityStateAuditType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *EntityStateAuditType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *EntityStateAuditType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *EntityStateAuditType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *EntityStateAuditType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *EntityStateAuditType `xml:"generic_all,omitempty"`
	// Key_query_value represents XSD element 'key_query_value'
	// minOccurs=0, maxOccurs=1
	Key_query_value *EntityStateAuditType `xml:"key_query_value,omitempty"`
	// Key_set_value represents XSD element 'key_set_value'
	// minOccurs=0, maxOccurs=1
	Key_set_value *EntityStateAuditType `xml:"key_set_value,omitempty"`
	// Key_create_sub_key represents XSD element 'key_create_sub_key'
	// minOccurs=0, maxOccurs=1
	Key_create_sub_key *EntityStateAuditType `xml:"key_create_sub_key,omitempty"`
	// Key_enumerate_sub_keys represents XSD element 'key_enumerate_sub_keys'
	// minOccurs=0, maxOccurs=1
	Key_enumerate_sub_keys *EntityStateAuditType `xml:"key_enumerate_sub_keys,omitempty"`
	// Key_notify represents XSD element 'key_notify'
	// minOccurs=0, maxOccurs=1
	Key_notify *EntityStateAuditType `xml:"key_notify,omitempty"`
	// Key_create_link represents XSD element 'key_create_link'
	// minOccurs=0, maxOccurs=1
	Key_create_link *EntityStateAuditType `xml:"key_create_link,omitempty"`
	// Key_wow64_64key represents XSD element 'key_wow64_64key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_64key *EntityStateAuditType `xml:"key_wow64_64key,omitempty"`
	// Key_wow64_32key represents XSD element 'key_wow64_32key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_32key *EntityStateAuditType `xml:"key_wow64_32key,omitempty"`
	// Key_wow64_res represents XSD element 'key_wow64_res'
	// minOccurs=0, maxOccurs=1
	Key_wow64_res *EntityStateAuditType `xml:"key_wow64_res,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions_stateFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions_stateFromBytes(data []byte) (*Regkeyauditedpermissions_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions_stateFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions_stateFromFile(path string) (*Regkeyauditedpermissions_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions_stateFromBytes(data)
}

// Sharedresourceeffectiverights_stateElement represents the XSD element 'sharedresourceeffectiverights_state'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceeffectiverights_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceeffectiverights_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Netname represents XSD element 'netname'
	// minOccurs=0, maxOccurs=1
	Netname *xmlschemaoval_definitions_5.EntityStateStringType `xml:"netname,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceeffectiverights_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceeffectiverights_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceeffectiverights_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceeffectiverights_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceeffectiverights_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceeffectiverights_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceeffectiverights_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceeffectiverights_stateFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceeffectiverights_stateFromBytes(data []byte) (*Sharedresourceeffectiverights_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceeffectiverights_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceeffectiverights_stateFromFile loads an element from a file with namespace preservation
func LoadSharedresourceeffectiverights_stateFromFile(path string) (*Sharedresourceeffectiverights_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceeffectiverights_stateFromBytes(data)
}

// Sid_testElement represents the XSD element 'sid_test'
// XSD element declaration (W3C XSD §3.3)
type Sid_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_testFromBytes loads an element from bytes with namespace preservation
func LoadSid_testFromBytes(data []byte) (*Sid_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_testFromFile loads an element from a file with namespace preservation
func LoadSid_testFromFile(path string) (*Sid_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_testFromBytes(data)
}

// Auditeventpolicysubcategories_testElement represents the XSD element 'auditeventpolicysubcategories_test'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicysubcategories_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicysubcategories_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicysubcategories_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicysubcategories_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicysubcategories_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicysubcategories_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicysubcategories_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicysubcategories_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicysubcategories_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicysubcategories_testFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicysubcategories_testFromBytes(data []byte) (*Auditeventpolicysubcategories_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicysubcategories_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicysubcategories_testFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicysubcategories_testFromFile(path string) (*Auditeventpolicysubcategories_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicysubcategories_testFromBytes(data)
}

// Interface_testElement represents the XSD element 'interface_test'
// XSD element declaration (W3C XSD §3.3)
type Interface_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows interface_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Interface_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Interface_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Interface_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Interface_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Interface_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Interface_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Interface_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Interface_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Interface_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInterface_testFromBytes loads an element from bytes with namespace preservation
func LoadInterface_testFromBytes(data []byte) (*Interface_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Interface_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInterface_testFromFile loads an element from a file with namespace preservation
func LoadInterface_testFromFile(path string) (*Interface_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInterface_testFromBytes(data)
}

// Ntuser_objectElement represents the XSD element 'ntuser_object'
// XSD element declaration (W3C XSD §3.3)
type Ntuser_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows ntuser_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *NTUserBehaviors `xml:"behaviors,omitempty"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Ntuser_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Ntuser_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Ntuser_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Ntuser_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Ntuser_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Ntuser_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Ntuser_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Ntuser_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Ntuser_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadNtuser_objectFromBytes loads an element from bytes with namespace preservation
func LoadNtuser_objectFromBytes(data []byte) (*Ntuser_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Ntuser_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadNtuser_objectFromFile loads an element from a file with namespace preservation
func LoadNtuser_objectFromFile(path string) (*Ntuser_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadNtuser_objectFromBytes(data)
}

// Printereffectiverights_objectElement represents the XSD element 'printereffectiverights_object'
// XSD element declaration (W3C XSD §3.3)
type Printereffectiverights_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows printereffectiverights_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *PrinterEffectiveRightsBehaviors `xml:"behaviors,omitempty"`
	// Printer_name represents XSD element 'printer_name'
	Printer_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"printer_name"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Printereffectiverights_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Printereffectiverights_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Printereffectiverights_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Printereffectiverights_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Printereffectiverights_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Printereffectiverights_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Printereffectiverights_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Printereffectiverights_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Printereffectiverights_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPrintereffectiverights_objectFromBytes loads an element from bytes with namespace preservation
func LoadPrintereffectiverights_objectFromBytes(data []byte) (*Printereffectiverights_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Printereffectiverights_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPrintereffectiverights_objectFromFile loads an element from a file with namespace preservation
func LoadPrintereffectiverights_objectFromFile(path string) (*Printereffectiverights_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPrintereffectiverights_objectFromBytes(data)
}

// Regkeyeffectiverights53_stateElement represents the XSD element 'regkeyeffectiverights53_state'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights53_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights53_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Hive represents XSD element 'hive'
	// minOccurs=0, maxOccurs=1
	Hive *EntityStateRegistryHiveType `xml:"hive,omitempty"`
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// Key_query_value represents XSD element 'key_query_value'
	// minOccurs=0, maxOccurs=1
	Key_query_value *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_query_value,omitempty"`
	// Key_set_value represents XSD element 'key_set_value'
	// minOccurs=0, maxOccurs=1
	Key_set_value *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_set_value,omitempty"`
	// Key_create_sub_key represents XSD element 'key_create_sub_key'
	// minOccurs=0, maxOccurs=1
	Key_create_sub_key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_create_sub_key,omitempty"`
	// Key_enumerate_sub_keys represents XSD element 'key_enumerate_sub_keys'
	// minOccurs=0, maxOccurs=1
	Key_enumerate_sub_keys *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_enumerate_sub_keys,omitempty"`
	// Key_notify represents XSD element 'key_notify'
	// minOccurs=0, maxOccurs=1
	Key_notify *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_notify,omitempty"`
	// Key_create_link represents XSD element 'key_create_link'
	// minOccurs=0, maxOccurs=1
	Key_create_link *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_create_link,omitempty"`
	// Key_wow64_64key represents XSD element 'key_wow64_64key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_64key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_64key,omitempty"`
	// Key_wow64_32key represents XSD element 'key_wow64_32key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_32key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_32key,omitempty"`
	// Key_wow64_res represents XSD element 'key_wow64_res'
	// minOccurs=0, maxOccurs=1
	Key_wow64_res *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_res,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights53_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights53_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights53_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights53_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights53_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights53_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights53_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights53_stateFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights53_stateFromBytes(data []byte) (*Regkeyeffectiverights53_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights53_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights53_stateFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights53_stateFromFile(path string) (*Regkeyeffectiverights53_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights53_stateFromBytes(data)
}

// Serviceeffectiverights_stateElement represents the XSD element 'serviceeffectiverights_state'
// XSD element declaration (W3C XSD §3.3)
type Serviceeffectiverights_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows serviceeffectiverights_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Service_name represents XSD element 'service_name'
	// minOccurs=0, maxOccurs=1
	Service_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"service_name,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Service_query_conf represents XSD element 'service_query_conf'
	// minOccurs=0, maxOccurs=1
	Service_query_conf *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_query_conf,omitempty"`
	// Service_change_conf represents XSD element 'service_change_conf'
	// minOccurs=0, maxOccurs=1
	Service_change_conf *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_change_conf,omitempty"`
	// Service_query_stat represents XSD element 'service_query_stat'
	// minOccurs=0, maxOccurs=1
	Service_query_stat *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_query_stat,omitempty"`
	// Service_enum_dependents represents XSD element 'service_enum_dependents'
	// minOccurs=0, maxOccurs=1
	Service_enum_dependents *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_enum_dependents,omitempty"`
	// Service_start represents XSD element 'service_start'
	// minOccurs=0, maxOccurs=1
	Service_start *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_start,omitempty"`
	// Service_stop represents XSD element 'service_stop'
	// minOccurs=0, maxOccurs=1
	Service_stop *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_stop,omitempty"`
	// Service_pause represents XSD element 'service_pause'
	// minOccurs=0, maxOccurs=1
	Service_pause *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_pause,omitempty"`
	// Service_interrogate represents XSD element 'service_interrogate'
	// minOccurs=0, maxOccurs=1
	Service_interrogate *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_interrogate,omitempty"`
	// Service_user_defined represents XSD element 'service_user_defined'
	// minOccurs=0, maxOccurs=1
	Service_user_defined *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_user_defined,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Serviceeffectiverights_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Serviceeffectiverights_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Serviceeffectiverights_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Serviceeffectiverights_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Serviceeffectiverights_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Serviceeffectiverights_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Serviceeffectiverights_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadServiceeffectiverights_stateFromBytes loads an element from bytes with namespace preservation
func LoadServiceeffectiverights_stateFromBytes(data []byte) (*Serviceeffectiverights_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Serviceeffectiverights_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadServiceeffectiverights_stateFromFile loads an element from a file with namespace preservation
func LoadServiceeffectiverights_stateFromFile(path string) (*Serviceeffectiverights_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadServiceeffectiverights_stateFromBytes(data)
}

// Sid_objectElement represents the XSD element 'sid_object'
// XSD element declaration (W3C XSD §3.3)
type Sid_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *SidBehaviors `xml:"behaviors,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	Trustee_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_objectFromBytes loads an element from bytes with namespace preservation
func LoadSid_objectFromBytes(data []byte) (*Sid_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_objectFromFile loads an element from a file with namespace preservation
func LoadSid_objectFromFile(path string) (*Sid_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_objectFromBytes(data)
}

// Lockoutpolicy_objectElement represents the XSD element 'lockoutpolicy_object'
// XSD element declaration (W3C XSD §3.3)
type Lockoutpolicy_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows lockoutpolicy_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Lockoutpolicy_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Lockoutpolicy_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Lockoutpolicy_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Lockoutpolicy_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Lockoutpolicy_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Lockoutpolicy_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Lockoutpolicy_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Lockoutpolicy_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Lockoutpolicy_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLockoutpolicy_objectFromBytes loads an element from bytes with namespace preservation
func LoadLockoutpolicy_objectFromBytes(data []byte) (*Lockoutpolicy_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Lockoutpolicy_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLockoutpolicy_objectFromFile loads an element from a file with namespace preservation
func LoadLockoutpolicy_objectFromFile(path string) (*Lockoutpolicy_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLockoutpolicy_objectFromBytes(data)
}

// Regkeyauditedpermissions53_testElement represents the XSD element 'regkeyauditedpermissions53_test'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions53_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions53_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions53_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions53_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions53_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions53_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions53_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions53_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions53_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions53_testFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions53_testFromBytes(data []byte) (*Regkeyauditedpermissions53_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions53_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions53_testFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions53_testFromFile(path string) (*Regkeyauditedpermissions53_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions53_testFromBytes(data)
}

// Sid_sid_objectElement represents the XSD element 'sid_sid_object'
// XSD element declaration (W3C XSD §3.3)
type Sid_sid_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_sid_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *SidSidBehaviors `xml:"behaviors,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_sid_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_sid_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_sid_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_sid_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_sid_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_sid_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_sid_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_sid_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_sid_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_sid_objectFromBytes loads an element from bytes with namespace preservation
func LoadSid_sid_objectFromBytes(data []byte) (*Sid_sid_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_sid_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_sid_objectFromFile loads an element from a file with namespace preservation
func LoadSid_sid_objectFromFile(path string) (*Sid_sid_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_sid_objectFromBytes(data)
}

// Volume_objectElement represents the XSD element 'volume_object'
// XSD element declaration (W3C XSD §3.3)
type Volume_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows volume_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Rootpath represents XSD element 'rootpath'
	Rootpath xmlschemaoval_definitions_5.EntityObjectStringType `xml:"rootpath"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Volume_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Volume_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Volume_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Volume_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Volume_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Volume_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Volume_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Volume_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Volume_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadVolume_objectFromBytes loads an element from bytes with namespace preservation
func LoadVolume_objectFromBytes(data []byte) (*Volume_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Volume_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadVolume_objectFromFile loads an element from a file with namespace preservation
func LoadVolume_objectFromFile(path string) (*Volume_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadVolume_objectFromBytes(data)
}

// Wuaupdatesearcher_testElement represents the XSD element 'wuaupdatesearcher_test'
// XSD element declaration (W3C XSD §3.3)
type Wuaupdatesearcher_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wuaupdatesearcher_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wuaupdatesearcher_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wuaupdatesearcher_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wuaupdatesearcher_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wuaupdatesearcher_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wuaupdatesearcher_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wuaupdatesearcher_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wuaupdatesearcher_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWuaupdatesearcher_testFromBytes loads an element from bytes with namespace preservation
func LoadWuaupdatesearcher_testFromBytes(data []byte) (*Wuaupdatesearcher_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wuaupdatesearcher_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWuaupdatesearcher_testFromFile loads an element from a file with namespace preservation
func LoadWuaupdatesearcher_testFromFile(path string) (*Wuaupdatesearcher_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWuaupdatesearcher_testFromBytes(data)
}

// Activedirectory57_objectElement represents the XSD element 'activedirectory57_object'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory57_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory57_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Naming_context represents XSD element 'naming_context'
	Naming_context EntityObjectNamingContextType `xml:"naming_context"`
	// Relative_dn represents XSD element 'relative_dn'
	Relative_dn xmlschemaoval_definitions_5.EntityObjectStringType `xml:"relative_dn"`
	// Attribute represents XSD element 'attribute'
	Attribute xmlschemaoval_definitions_5.EntityObjectStringType `xml:"attribute"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory57_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory57_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory57_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory57_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory57_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory57_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory57_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory57_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory57_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory57_objectFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory57_objectFromBytes(data []byte) (*Activedirectory57_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory57_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory57_objectFromFile loads an element from a file with namespace preservation
func LoadActivedirectory57_objectFromFile(path string) (*Activedirectory57_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory57_objectFromBytes(data)
}

// Printereffectiverights_stateElement represents the XSD element 'printereffectiverights_state'
// XSD element declaration (W3C XSD §3.3)
type Printereffectiverights_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows printereffectiverights_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Printer_name represents XSD element 'printer_name'
	// minOccurs=0, maxOccurs=1
	Printer_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"printer_name,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// Printer_access_administer represents XSD element 'printer_access_administer'
	// minOccurs=0, maxOccurs=1
	Printer_access_administer *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"printer_access_administer,omitempty"`
	// Printer_access_use represents XSD element 'printer_access_use'
	// minOccurs=0, maxOccurs=1
	Printer_access_use *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"printer_access_use,omitempty"`
	// Job_access_administer represents XSD element 'job_access_administer'
	// minOccurs=0, maxOccurs=1
	Job_access_administer *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"job_access_administer,omitempty"`
	// Job_access_read represents XSD element 'job_access_read'
	// minOccurs=0, maxOccurs=1
	Job_access_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"job_access_read,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Printereffectiverights_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Printereffectiverights_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Printereffectiverights_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Printereffectiverights_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Printereffectiverights_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Printereffectiverights_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Printereffectiverights_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Printereffectiverights_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Printereffectiverights_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPrintereffectiverights_stateFromBytes loads an element from bytes with namespace preservation
func LoadPrintereffectiverights_stateFromBytes(data []byte) (*Printereffectiverights_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Printereffectiverights_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPrintereffectiverights_stateFromFile loads an element from a file with namespace preservation
func LoadPrintereffectiverights_stateFromFile(path string) (*Printereffectiverights_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPrintereffectiverights_stateFromBytes(data)
}

// Wuaupdatesearcher_objectElement represents the XSD element 'wuaupdatesearcher_object'
// XSD element declaration (W3C XSD §3.3)
type Wuaupdatesearcher_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wuaupdatesearcher_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *WuaUpdateSearcherBehaviors `xml:"behaviors,omitempty"`
	// Search_criteria represents XSD element 'search_criteria'
	Search_criteria xmlschemaoval_definitions_5.EntityObjectStringType `xml:"search_criteria"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wuaupdatesearcher_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wuaupdatesearcher_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wuaupdatesearcher_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wuaupdatesearcher_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wuaupdatesearcher_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wuaupdatesearcher_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wuaupdatesearcher_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWuaupdatesearcher_objectFromBytes loads an element from bytes with namespace preservation
func LoadWuaupdatesearcher_objectFromBytes(data []byte) (*Wuaupdatesearcher_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wuaupdatesearcher_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWuaupdatesearcher_objectFromFile loads an element from a file with namespace preservation
func LoadWuaupdatesearcher_objectFromFile(path string) (*Wuaupdatesearcher_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWuaupdatesearcher_objectFromBytes(data)
}

// Accesstoken_objectElement represents the XSD element 'accesstoken_object'
// XSD element declaration (W3C XSD §3.3)
type Accesstoken_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows accesstoken_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *AccesstokenBehaviors `xml:"behaviors,omitempty"`
	// Security_principle represents XSD element 'security_principle'
	Security_principle xmlschemaoval_definitions_5.EntityObjectStringType `xml:"security_principle"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Accesstoken_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Accesstoken_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Accesstoken_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Accesstoken_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Accesstoken_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Accesstoken_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Accesstoken_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Accesstoken_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Accesstoken_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAccesstoken_objectFromBytes loads an element from bytes with namespace preservation
func LoadAccesstoken_objectFromBytes(data []byte) (*Accesstoken_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Accesstoken_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAccesstoken_objectFromFile loads an element from a file with namespace preservation
func LoadAccesstoken_objectFromFile(path string) (*Accesstoken_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAccesstoken_objectFromBytes(data)
}

// Lockoutpolicy_stateElement represents the XSD element 'lockoutpolicy_state'
// XSD element declaration (W3C XSD §3.3)
type Lockoutpolicy_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows lockoutpolicy_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Force_logoff represents XSD element 'force_logoff'
	// minOccurs=0, maxOccurs=1
	Force_logoff *xmlschemaoval_definitions_5.EntityStateIntType `xml:"force_logoff,omitempty"`
	// Lockout_duration represents XSD element 'lockout_duration'
	// minOccurs=0, maxOccurs=1
	Lockout_duration *xmlschemaoval_definitions_5.EntityStateIntType `xml:"lockout_duration,omitempty"`
	// Lockout_observation_window represents XSD element 'lockout_observation_window'
	// minOccurs=0, maxOccurs=1
	Lockout_observation_window *xmlschemaoval_definitions_5.EntityStateIntType `xml:"lockout_observation_window,omitempty"`
	// Lockout_threshold represents XSD element 'lockout_threshold'
	// minOccurs=0, maxOccurs=1
	Lockout_threshold *xmlschemaoval_definitions_5.EntityStateIntType `xml:"lockout_threshold,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Lockoutpolicy_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Lockoutpolicy_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Lockoutpolicy_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Lockoutpolicy_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Lockoutpolicy_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Lockoutpolicy_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Lockoutpolicy_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Lockoutpolicy_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Lockoutpolicy_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLockoutpolicy_stateFromBytes loads an element from bytes with namespace preservation
func LoadLockoutpolicy_stateFromBytes(data []byte) (*Lockoutpolicy_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Lockoutpolicy_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLockoutpolicy_stateFromFile loads an element from a file with namespace preservation
func LoadLockoutpolicy_stateFromFile(path string) (*Lockoutpolicy_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLockoutpolicy_stateFromBytes(data)
}

// Service_stateElement represents the XSD element 'service_state'
// XSD element declaration (W3C XSD §3.3)
type Service_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows service_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Service_name represents XSD element 'service_name'
	// minOccurs=0, maxOccurs=1
	Service_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"service_name,omitempty"`
	// Display_name represents XSD element 'display_name'
	// minOccurs=0, maxOccurs=1
	Display_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"display_name,omitempty"`
	// Description represents XSD element 'description'
	// minOccurs=0, maxOccurs=1
	Description *xmlschemaoval_definitions_5.EntityStateStringType `xml:"description,omitempty"`
	// Service_type represents XSD element 'service_type'
	// minOccurs=0, maxOccurs=1
	Service_type *EntityStateServiceTypeType `xml:"service_type,omitempty"`
	// Start_type represents XSD element 'start_type'
	// minOccurs=0, maxOccurs=1
	Start_type *EntityStateServiceStartTypeType `xml:"start_type,omitempty"`
	// Current_state represents XSD element 'current_state'
	// minOccurs=0, maxOccurs=1
	Current_state *EntityStateServiceCurrentStateType `xml:"current_state,omitempty"`
	// Controls_accepted represents XSD element 'controls_accepted'
	// minOccurs=0, maxOccurs=1
	Controls_accepted *EntityStateServiceControlsAcceptedType `xml:"controls_accepted,omitempty"`
	// Start_name represents XSD element 'start_name'
	// minOccurs=0, maxOccurs=1
	Start_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"start_name,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// Service_flag represents XSD element 'service_flag'
	// minOccurs=0, maxOccurs=1
	Service_flag *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"service_flag,omitempty"`
	// Dependencies represents XSD element 'dependencies'
	// minOccurs=0, maxOccurs=1
	Dependencies *xmlschemaoval_definitions_5.EntityStateStringType `xml:"dependencies,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Service_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Service_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Service_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Service_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Service_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Service_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Service_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Service_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Service_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadService_stateFromBytes loads an element from bytes with namespace preservation
func LoadService_stateFromBytes(data []byte) (*Service_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Service_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadService_stateFromFile loads an element from a file with namespace preservation
func LoadService_stateFromFile(path string) (*Service_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadService_stateFromBytes(data)
}

// Fileeffectiverights53_testElement represents the XSD element 'fileeffectiverights53_test'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights53_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights53_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights53_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights53_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights53_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights53_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights53_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights53_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights53_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights53_testFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights53_testFromBytes(data []byte) (*Fileeffectiverights53_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights53_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights53_testFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights53_testFromFile(path string) (*Fileeffectiverights53_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights53_testFromBytes(data)
}

// Ntuser_stateElement represents the XSD element 'ntuser_state'
// XSD element declaration (W3C XSD §3.3)
type Ntuser_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows ntuser_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Sid represents XSD element 'sid'
	// minOccurs=0, maxOccurs=1
	Sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"sid,omitempty"`
	// Username represents XSD element 'username'
	// minOccurs=0, maxOccurs=1
	Username *xmlschemaoval_definitions_5.EntityStateStringType `xml:"username,omitempty"`
	// Account_type represents XSD element 'account_type'
	// minOccurs=0, maxOccurs=1
	Account_type *EntityStateNTUserAccountTypeType `xml:"account_type,omitempty"`
	// Logged_on represents XSD element 'logged_on'
	// minOccurs=0, maxOccurs=1
	Logged_on *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"logged_on,omitempty"`
	// Enabled represents XSD element 'enabled'
	// minOccurs=0, maxOccurs=1
	Enabled *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"enabled,omitempty"`
	// Date_modified represents XSD element 'date_modified'
	// minOccurs=0, maxOccurs=1
	Date_modified *xmlschemaoval_definitions_5.EntityStateIntType `xml:"date_modified,omitempty"`
	// Days_since_modified represents XSD element 'days_since_modified'
	// minOccurs=0, maxOccurs=1
	Days_since_modified *xmlschemaoval_definitions_5.EntityStateIntType `xml:"days_since_modified,omitempty"`
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Last_write_time represents XSD element 'last_write_time'
	// minOccurs=0, maxOccurs=1
	Last_write_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"last_write_time,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *EntityStateRegistryTypeType `xml:"type,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Ntuser_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Ntuser_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Ntuser_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Ntuser_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Ntuser_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Ntuser_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Ntuser_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Ntuser_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Ntuser_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadNtuser_stateFromBytes loads an element from bytes with namespace preservation
func LoadNtuser_stateFromBytes(data []byte) (*Ntuser_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Ntuser_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadNtuser_stateFromFile loads an element from a file with namespace preservation
func LoadNtuser_stateFromFile(path string) (*Ntuser_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadNtuser_stateFromBytes(data)
}

// Sharedresourceeffectiverights_testElement represents the XSD element 'sharedresourceeffectiverights_test'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceeffectiverights_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceeffectiverights_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceeffectiverights_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceeffectiverights_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceeffectiverights_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceeffectiverights_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceeffectiverights_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceeffectiverights_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceeffectiverights_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceeffectiverights_testFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceeffectiverights_testFromBytes(data []byte) (*Sharedresourceeffectiverights_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceeffectiverights_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceeffectiverights_testFromFile loads an element from a file with namespace preservation
func LoadSharedresourceeffectiverights_testFromFile(path string) (*Sharedresourceeffectiverights_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceeffectiverights_testFromBytes(data)
}

// Fileauditedpermissions53_objectElement represents the XSD element 'fileauditedpermissions53_object'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions53_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions53_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileAuditPermissions53Behaviors `xml:"behaviors,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// Filepath represents XSD element 'filepath'
	Filepath *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions53_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions53_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions53_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions53_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions53_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions53_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions53_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions53_objectFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions53_objectFromBytes(data []byte) (*Fileauditedpermissions53_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions53_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions53_objectFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions53_objectFromFile(path string) (*Fileauditedpermissions53_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions53_objectFromBytes(data)
}

// Auditeventpolicy_objectElement represents the XSD element 'auditeventpolicy_object'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicy_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicy_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicy_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicy_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicy_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicy_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicy_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicy_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicy_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicy_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicy_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicy_objectFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicy_objectFromBytes(data []byte) (*Auditeventpolicy_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicy_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicy_objectFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicy_objectFromFile(path string) (*Auditeventpolicy_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicy_objectFromBytes(data)
}

// Group_objectElement represents the XSD element 'group_object'
// XSD element declaration (W3C XSD §3.3)
type Group_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Group represents XSD element 'group'
	Group xmlschemaoval_definitions_5.EntityObjectStringType `xml:"group"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_objectFromBytes loads an element from bytes with namespace preservation
func LoadGroup_objectFromBytes(data []byte) (*Group_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_objectFromFile loads an element from a file with namespace preservation
func LoadGroup_objectFromFile(path string) (*Group_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_objectFromBytes(data)
}

// Sharedresource_stateElement represents the XSD element 'sharedresource_state'
// XSD element declaration (W3C XSD §3.3)
type Sharedresource_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresource_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Netname represents XSD element 'netname'
	// minOccurs=0, maxOccurs=1
	Netname *xmlschemaoval_definitions_5.EntityStateStringType `xml:"netname,omitempty"`
	// Shared_type represents XSD element 'shared_type'
	// minOccurs=0, maxOccurs=1
	Shared_type *EntityStateSharedResourceTypeType `xml:"shared_type,omitempty"`
	// Max_uses represents XSD element 'max_uses'
	// minOccurs=0, maxOccurs=1
	Max_uses *xmlschemaoval_definitions_5.EntityStateIntType `xml:"max_uses,omitempty"`
	// Current_uses represents XSD element 'current_uses'
	// minOccurs=0, maxOccurs=1
	Current_uses *xmlschemaoval_definitions_5.EntityStateIntType `xml:"current_uses,omitempty"`
	// Local_path represents XSD element 'local_path'
	// minOccurs=0, maxOccurs=1
	Local_path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"local_path,omitempty"`
	// Access_read_permission represents XSD element 'access_read_permission'
	// minOccurs=0, maxOccurs=1
	Access_read_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_read_permission,omitempty"`
	// Access_write_permission represents XSD element 'access_write_permission'
	// minOccurs=0, maxOccurs=1
	Access_write_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_write_permission,omitempty"`
	// Access_create_permission represents XSD element 'access_create_permission'
	// minOccurs=0, maxOccurs=1
	Access_create_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_create_permission,omitempty"`
	// Access_exec_permission represents XSD element 'access_exec_permission'
	// minOccurs=0, maxOccurs=1
	Access_exec_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_exec_permission,omitempty"`
	// Access_delete_permission represents XSD element 'access_delete_permission'
	// minOccurs=0, maxOccurs=1
	Access_delete_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_delete_permission,omitempty"`
	// Access_atrib_permission represents XSD element 'access_atrib_permission'
	// minOccurs=0, maxOccurs=1
	Access_atrib_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_atrib_permission,omitempty"`
	// Access_perm_permission represents XSD element 'access_perm_permission'
	// minOccurs=0, maxOccurs=1
	Access_perm_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_perm_permission,omitempty"`
	// Access_all_permission represents XSD element 'access_all_permission'
	// minOccurs=0, maxOccurs=1
	Access_all_permission *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_all_permission,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresource_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresource_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresource_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresource_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresource_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresource_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresource_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresource_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresource_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresource_stateFromBytes loads an element from bytes with namespace preservation
func LoadSharedresource_stateFromBytes(data []byte) (*Sharedresource_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresource_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresource_stateFromFile loads an element from a file with namespace preservation
func LoadSharedresource_stateFromFile(path string) (*Sharedresource_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresource_stateFromBytes(data)
}

// User_sid_testElement represents the XSD element 'user_sid_test'
// XSD element declaration (W3C XSD §3.3)
type User_sid_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid_testFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid_testFromBytes(data []byte) (*User_sid_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid_testFromFile loads an element from a file with namespace preservation
func LoadUser_sid_testFromFile(path string) (*User_sid_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid_testFromBytes(data)
}

// User_sid_stateElement represents the XSD element 'user_sid_state'
// XSD element declaration (W3C XSD §3.3)
type User_sid_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// User represents XSD element 'user'
	// minOccurs=0, maxOccurs=1
	User *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user,omitempty"`
	// Enabled represents XSD element 'enabled'
	// minOccurs=0, maxOccurs=1
	Enabled *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"enabled,omitempty"`
	// Group represents XSD element 'group'
	// minOccurs=0, maxOccurs=1
	Group *xmlschemaoval_definitions_5.EntityStateStringType `xml:"group,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid_stateFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid_stateFromBytes(data []byte) (*User_sid_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid_stateFromFile loads an element from a file with namespace preservation
func LoadUser_sid_stateFromFile(path string) (*User_sid_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid_stateFromBytes(data)
}

// Activedirectory_stateElement represents the XSD element 'activedirectory_state'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Naming_context represents XSD element 'naming_context'
	// minOccurs=0, maxOccurs=1
	Naming_context *EntityStateNamingContextType `xml:"naming_context,omitempty"`
	// Relative_dn represents XSD element 'relative_dn'
	// minOccurs=0, maxOccurs=1
	Relative_dn *xmlschemaoval_definitions_5.EntityStateStringType `xml:"relative_dn,omitempty"`
	// Attribute represents XSD element 'attribute'
	// minOccurs=0, maxOccurs=1
	Attribute *xmlschemaoval_definitions_5.EntityStateStringType `xml:"attribute,omitempty"`
	// Object_class represents XSD element 'object_class'
	// minOccurs=0, maxOccurs=1
	Object_class *xmlschemaoval_definitions_5.EntityStateStringType `xml:"object_class,omitempty"`
	// Adstype represents XSD element 'adstype'
	// minOccurs=0, maxOccurs=1
	Adstype *EntityStateAdstypeType `xml:"adstype,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory_stateFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory_stateFromBytes(data []byte) (*Activedirectory_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory_stateFromFile loads an element from a file with namespace preservation
func LoadActivedirectory_stateFromFile(path string) (*Activedirectory_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory_stateFromBytes(data)
}

// Activedirectory57_testElement represents the XSD element 'activedirectory57_test'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory57_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory57_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory57_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory57_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory57_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory57_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory57_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory57_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory57_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory57_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory57_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory57_testFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory57_testFromBytes(data []byte) (*Activedirectory57_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory57_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory57_testFromFile loads an element from a file with namespace preservation
func LoadActivedirectory57_testFromFile(path string) (*Activedirectory57_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory57_testFromBytes(data)
}

// Fileauditedpermissions_testElement represents the XSD element 'fileauditedpermissions_test'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions_testFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions_testFromBytes(data []byte) (*Fileauditedpermissions_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions_testFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions_testFromFile(path string) (*Fileauditedpermissions_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions_testFromBytes(data)
}

// License_stateElement represents the XSD element 'license_state'
// XSD element declaration (W3C XSD §3.3)
type License_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows license_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *EntityStateRegistryTypeType `xml:"type,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *License_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias License_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *License_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias License_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *License_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *License_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *License_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *License_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *License_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLicense_stateFromBytes loads an element from bytes with namespace preservation
func LoadLicense_stateFromBytes(data []byte) (*License_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element License_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLicense_stateFromFile loads an element from a file with namespace preservation
func LoadLicense_stateFromFile(path string) (*License_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLicense_stateFromBytes(data)
}

// Registry_stateElement represents the XSD element 'registry_state'
// XSD element declaration (W3C XSD §3.3)
type Registry_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows registry_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Hive represents XSD element 'hive'
	// minOccurs=0, maxOccurs=1
	Hive *EntityStateRegistryHiveType `xml:"hive,omitempty"`
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Last_write_time represents XSD element 'last_write_time'
	// minOccurs=0, maxOccurs=1
	Last_write_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"last_write_time,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *EntityStateRegistryTypeType `xml:"type,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"value,omitempty"`
	// Expanded_value represents XSD element 'expanded_value'
	// minOccurs=0, maxOccurs=1
	Expanded_value *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"expanded_value,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Registry_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Registry_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Registry_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Registry_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Registry_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Registry_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Registry_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Registry_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Registry_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegistry_stateFromBytes loads an element from bytes with namespace preservation
func LoadRegistry_stateFromBytes(data []byte) (*Registry_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Registry_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegistry_stateFromFile loads an element from a file with namespace preservation
func LoadRegistry_stateFromFile(path string) (*Registry_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegistry_stateFromBytes(data)
}

// Wmi_stateElement represents the XSD element 'wmi_state'
// XSD element declaration (W3C XSD §3.3)
type Wmi_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Namespace represents XSD element 'namespace'
	// minOccurs=0, maxOccurs=1
	Namespace *xmlschemaoval_definitions_5.EntityStateStringType `xml:"namespace,omitempty"`
	// Wql represents XSD element 'wql'
	// minOccurs=0, maxOccurs=1
	Wql *xmlschemaoval_definitions_5.EntityStateStringType `xml:"wql,omitempty"`
	// Result represents XSD element 'result'
	// minOccurs=0, maxOccurs=1
	Result *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"result,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi_stateFromBytes loads an element from bytes with namespace preservation
func LoadWmi_stateFromBytes(data []byte) (*Wmi_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi_stateFromFile loads an element from a file with namespace preservation
func LoadWmi_stateFromFile(path string) (*Wmi_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi_stateFromBytes(data)
}

// Fileeffectiverights_testElement represents the XSD element 'fileeffectiverights_test'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights_testFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights_testFromBytes(data []byte) (*Fileeffectiverights_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights_testFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights_testFromFile(path string) (*Fileeffectiverights_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights_testFromBytes(data)
}

// Group_stateElement represents the XSD element 'group_state'
// XSD element declaration (W3C XSD §3.3)
type Group_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Group represents XSD element 'group'
	// minOccurs=0, maxOccurs=1
	Group *xmlschemaoval_definitions_5.EntityStateStringType `xml:"group,omitempty"`
	// User represents XSD element 'user'
	// minOccurs=0, maxOccurs=1
	User *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user,omitempty"`
	// Subgroup represents XSD element 'subgroup'
	// minOccurs=0, maxOccurs=1
	Subgroup *xmlschemaoval_definitions_5.EntityStateStringType `xml:"subgroup,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_stateFromBytes loads an element from bytes with namespace preservation
func LoadGroup_stateFromBytes(data []byte) (*Group_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_stateFromFile loads an element from a file with namespace preservation
func LoadGroup_stateFromFile(path string) (*Group_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_stateFromBytes(data)
}

// Passwordpolicy_objectElement represents the XSD element 'passwordpolicy_object'
// XSD element declaration (W3C XSD §3.3)
type Passwordpolicy_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows passwordpolicy_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Passwordpolicy_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Passwordpolicy_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Passwordpolicy_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Passwordpolicy_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Passwordpolicy_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Passwordpolicy_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Passwordpolicy_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Passwordpolicy_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Passwordpolicy_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPasswordpolicy_objectFromBytes loads an element from bytes with namespace preservation
func LoadPasswordpolicy_objectFromBytes(data []byte) (*Passwordpolicy_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Passwordpolicy_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPasswordpolicy_objectFromFile loads an element from a file with namespace preservation
func LoadPasswordpolicy_objectFromFile(path string) (*Passwordpolicy_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPasswordpolicy_objectFromBytes(data)
}

// Regkeyeffectiverights_objectElement represents the XSD element 'regkeyeffectiverights_object'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RegkeyEffectiveRightsBehaviors `xml:"behaviors,omitempty"`
	// Hive represents XSD element 'hive'
	Hive EntityObjectRegistryHiveType `xml:"hive"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Trustee_name represents XSD element 'trustee_name'
	Trustee_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_name"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights_objectFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights_objectFromBytes(data []byte) (*Regkeyeffectiverights_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights_objectFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights_objectFromFile(path string) (*Regkeyeffectiverights_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights_objectFromBytes(data)
}

// Metabase_stateElement represents the XSD element 'metabase_state'
// XSD element declaration (W3C XSD §3.3)
type Metabase_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows metabase_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Id represents XSD element 'id'
	// minOccurs=0, maxOccurs=1
	Id *xmlschemaoval_definitions_5.EntityStateIntType `xml:"id,omitempty"`
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// User_type represents XSD element 'user_type'
	// minOccurs=0, maxOccurs=1
	User_type *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user_type,omitempty"`
	// Data_type represents XSD element 'data_type'
	// minOccurs=0, maxOccurs=1
	Data_type *xmlschemaoval_definitions_5.EntityStateStringType `xml:"data_type,omitempty"`
	// Data represents XSD element 'data'
	// minOccurs=0, maxOccurs=1
	Data *xmlschemaoval_definitions_5.EntityStateAnySimpleType `xml:"data,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Metabase_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Metabase_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Metabase_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Metabase_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Metabase_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Metabase_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Metabase_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Metabase_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Metabase_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadMetabase_stateFromBytes loads an element from bytes with namespace preservation
func LoadMetabase_stateFromBytes(data []byte) (*Metabase_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Metabase_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadMetabase_stateFromFile loads an element from a file with namespace preservation
func LoadMetabase_stateFromFile(path string) (*Metabase_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadMetabase_stateFromBytes(data)
}

// Peheader_objectElement represents the XSD element 'peheader_object'
// XSD element declaration (W3C XSD §3.3)
type Peheader_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows peheader_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileBehaviors `xml:"behaviors,omitempty"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// Filepath represents XSD element 'filepath'
	Filepath *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Peheader_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Peheader_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Peheader_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Peheader_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Peheader_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Peheader_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Peheader_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Peheader_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Peheader_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPeheader_objectFromBytes loads an element from bytes with namespace preservation
func LoadPeheader_objectFromBytes(data []byte) (*Peheader_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Peheader_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPeheader_objectFromFile loads an element from a file with namespace preservation
func LoadPeheader_objectFromFile(path string) (*Peheader_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPeheader_objectFromBytes(data)
}

// Sharedresourceauditedpermissions_stateElement represents the XSD element 'sharedresourceauditedpermissions_state'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceauditedpermissions_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceauditedpermissions_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Netname represents XSD element 'netname'
	// minOccurs=0, maxOccurs=1
	Netname *xmlschemaoval_definitions_5.EntityStateStringType `xml:"netname,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *EntityStateAuditType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *EntityStateAuditType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *EntityStateAuditType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *EntityStateAuditType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *EntityStateAuditType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *EntityStateAuditType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *EntityStateAuditType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *EntityStateAuditType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *EntityStateAuditType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *EntityStateAuditType `xml:"generic_all,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceauditedpermissions_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceauditedpermissions_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceauditedpermissions_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceauditedpermissions_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceauditedpermissions_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceauditedpermissions_stateFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceauditedpermissions_stateFromBytes(data []byte) (*Sharedresourceauditedpermissions_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceauditedpermissions_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceauditedpermissions_stateFromFile loads an element from a file with namespace preservation
func LoadSharedresourceauditedpermissions_stateFromFile(path string) (*Sharedresourceauditedpermissions_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceauditedpermissions_stateFromBytes(data)
}

// User_stateElement represents the XSD element 'user_state'
// XSD element declaration (W3C XSD §3.3)
type User_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// User represents XSD element 'user'
	// minOccurs=0, maxOccurs=1
	User *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user,omitempty"`
	// Enabled represents XSD element 'enabled'
	// minOccurs=0, maxOccurs=1
	Enabled *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"enabled,omitempty"`
	// Group represents XSD element 'group'
	// minOccurs=0, maxOccurs=1
	Group *xmlschemaoval_definitions_5.EntityStateStringType `xml:"group,omitempty"`
	// Last_logon represents XSD element 'last_logon'
	// minOccurs=0, maxOccurs=1
	Last_logon *xmlschemaoval_definitions_5.EntityStateIntType `xml:"last_logon,omitempty"`
	// Full_name represents XSD element 'full_name'
	// minOccurs=0, maxOccurs=1
	Full_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"full_name,omitempty"`
	// Comment represents XSD element 'comment'
	// minOccurs=0, maxOccurs=1
	Comment *xmlschemaoval_definitions_5.EntityStateStringType `xml:"comment,omitempty"`
	// Password_age_days represents XSD element 'password_age_days'
	// minOccurs=0, maxOccurs=1
	Password_age_days *xmlschemaoval_definitions_5.EntityStateIntType `xml:"password_age_days,omitempty"`
	// Lockout represents XSD element 'lockout'
	// minOccurs=0, maxOccurs=1
	Lockout *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"lockout,omitempty"`
	// Passwd_notreqd represents XSD element 'passwd_notreqd'
	// minOccurs=0, maxOccurs=1
	Passwd_notreqd *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"passwd_notreqd,omitempty"`
	// Dont_expire_passwd represents XSD element 'dont_expire_passwd'
	// minOccurs=0, maxOccurs=1
	Dont_expire_passwd *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"dont_expire_passwd,omitempty"`
	// Encrypted_text_password_allowed represents XSD element 'encrypted_text_password_allowed'
	// minOccurs=0, maxOccurs=1
	Encrypted_text_password_allowed *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"encrypted_text_password_allowed,omitempty"`
	// Not_delegated represents XSD element 'not_delegated'
	// minOccurs=0, maxOccurs=1
	Not_delegated *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"not_delegated,omitempty"`
	// Use_des_key_only represents XSD element 'use_des_key_only'
	// minOccurs=0, maxOccurs=1
	Use_des_key_only *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"use_des_key_only,omitempty"`
	// Dont_require_preauth represents XSD element 'dont_require_preauth'
	// minOccurs=0, maxOccurs=1
	Dont_require_preauth *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"dont_require_preauth,omitempty"`
	// Password_expired represents XSD element 'password_expired'
	// minOccurs=0, maxOccurs=1
	Password_expired *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"password_expired,omitempty"`
	// Smartcard_required represents XSD element 'smartcard_required'
	// minOccurs=0, maxOccurs=1
	Smartcard_required *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"smartcard_required,omitempty"`
	// Trusted_for_delegation represents XSD element 'trusted_for_delegation'
	// minOccurs=0, maxOccurs=1
	Trusted_for_delegation *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"trusted_for_delegation,omitempty"`
	// Trusted_to_authenticate_for_delegation represents XSD element 'trusted_to_authenticate_for_delegation'
	// minOccurs=0, maxOccurs=1
	Trusted_to_authenticate_for_delegation *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"trusted_to_authenticate_for_delegation,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_stateFromBytes loads an element from bytes with namespace preservation
func LoadUser_stateFromBytes(data []byte) (*User_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_stateFromFile loads an element from a file with namespace preservation
func LoadUser_stateFromFile(path string) (*User_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_stateFromBytes(data)
}

// Wmi57_stateElement represents the XSD element 'wmi57_state'
// XSD element declaration (W3C XSD §3.3)
type Wmi57_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi57_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Namespace represents XSD element 'namespace'
	// minOccurs=0, maxOccurs=1
	Namespace *xmlschemaoval_definitions_5.EntityStateStringType `xml:"namespace,omitempty"`
	// Wql represents XSD element 'wql'
	// minOccurs=0, maxOccurs=1
	Wql *xmlschemaoval_definitions_5.EntityStateStringType `xml:"wql,omitempty"`
	// Result represents XSD element 'result'
	// minOccurs=0, maxOccurs=1
	Result *xmlschemaoval_definitions_5.EntityStateRecordType `xml:"result,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi57_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi57_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi57_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi57_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi57_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi57_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi57_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi57_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi57_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi57_stateFromBytes loads an element from bytes with namespace preservation
func LoadWmi57_stateFromBytes(data []byte) (*Wmi57_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi57_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi57_stateFromFile loads an element from a file with namespace preservation
func LoadWmi57_stateFromFile(path string) (*Wmi57_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi57_stateFromBytes(data)
}

// Accesstoken_stateElement represents the XSD element 'accesstoken_state'
// XSD element declaration (W3C XSD §3.3)
type Accesstoken_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows accesstoken_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Security_principle represents XSD element 'security_principle'
	// minOccurs=0, maxOccurs=1
	Security_principle *xmlschemaoval_definitions_5.EntityStateStringType `xml:"security_principle,omitempty"`
	// Seassignprimarytokenprivilege represents XSD element 'seassignprimarytokenprivilege'
	// minOccurs=0, maxOccurs=1
	Seassignprimarytokenprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seassignprimarytokenprivilege,omitempty"`
	// Seauditprivilege represents XSD element 'seauditprivilege'
	// minOccurs=0, maxOccurs=1
	Seauditprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seauditprivilege,omitempty"`
	// Sebackupprivilege represents XSD element 'sebackupprivilege'
	// minOccurs=0, maxOccurs=1
	Sebackupprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sebackupprivilege,omitempty"`
	// Sechangenotifyprivilege represents XSD element 'sechangenotifyprivilege'
	// minOccurs=0, maxOccurs=1
	Sechangenotifyprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sechangenotifyprivilege,omitempty"`
	// Secreateglobalprivilege represents XSD element 'secreateglobalprivilege'
	// minOccurs=0, maxOccurs=1
	Secreateglobalprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secreateglobalprivilege,omitempty"`
	// Secreatepagefileprivilege represents XSD element 'secreatepagefileprivilege'
	// minOccurs=0, maxOccurs=1
	Secreatepagefileprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secreatepagefileprivilege,omitempty"`
	// Secreatepermanentprivilege represents XSD element 'secreatepermanentprivilege'
	// minOccurs=0, maxOccurs=1
	Secreatepermanentprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secreatepermanentprivilege,omitempty"`
	// Secreatesymboliclinkprivilege represents XSD element 'secreatesymboliclinkprivilege'
	// minOccurs=0, maxOccurs=1
	Secreatesymboliclinkprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secreatesymboliclinkprivilege,omitempty"`
	// Secreatetokenprivilege represents XSD element 'secreatetokenprivilege'
	// minOccurs=0, maxOccurs=1
	Secreatetokenprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secreatetokenprivilege,omitempty"`
	// Sedebugprivilege represents XSD element 'sedebugprivilege'
	// minOccurs=0, maxOccurs=1
	Sedebugprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedebugprivilege,omitempty"`
	// Seenabledelegationprivilege represents XSD element 'seenabledelegationprivilege'
	// minOccurs=0, maxOccurs=1
	Seenabledelegationprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seenabledelegationprivilege,omitempty"`
	// Seimpersonateprivilege represents XSD element 'seimpersonateprivilege'
	// minOccurs=0, maxOccurs=1
	Seimpersonateprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seimpersonateprivilege,omitempty"`
	// Seincreasebasepriorityprivilege represents XSD element 'seincreasebasepriorityprivilege'
	// minOccurs=0, maxOccurs=1
	Seincreasebasepriorityprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seincreasebasepriorityprivilege,omitempty"`
	// Seincreasequotaprivilege represents XSD element 'seincreasequotaprivilege'
	// minOccurs=0, maxOccurs=1
	Seincreasequotaprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seincreasequotaprivilege,omitempty"`
	// Seincreaseworkingsetprivilege represents XSD element 'seincreaseworkingsetprivilege'
	// minOccurs=0, maxOccurs=1
	Seincreaseworkingsetprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seincreaseworkingsetprivilege,omitempty"`
	// Seloaddriverprivilege represents XSD element 'seloaddriverprivilege'
	// minOccurs=0, maxOccurs=1
	Seloaddriverprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seloaddriverprivilege,omitempty"`
	// Selockmemoryprivilege represents XSD element 'selockmemoryprivilege'
	// minOccurs=0, maxOccurs=1
	Selockmemoryprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"selockmemoryprivilege,omitempty"`
	// Semachineaccountprivilege represents XSD element 'semachineaccountprivilege'
	// minOccurs=0, maxOccurs=1
	Semachineaccountprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"semachineaccountprivilege,omitempty"`
	// Semanagevolumeprivilege represents XSD element 'semanagevolumeprivilege'
	// minOccurs=0, maxOccurs=1
	Semanagevolumeprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"semanagevolumeprivilege,omitempty"`
	// Seprofilesingleprocessprivilege represents XSD element 'seprofilesingleprocessprivilege'
	// minOccurs=0, maxOccurs=1
	Seprofilesingleprocessprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seprofilesingleprocessprivilege,omitempty"`
	// Serelabelprivilege represents XSD element 'serelabelprivilege'
	// minOccurs=0, maxOccurs=1
	Serelabelprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"serelabelprivilege,omitempty"`
	// Seremoteshutdownprivilege represents XSD element 'seremoteshutdownprivilege'
	// minOccurs=0, maxOccurs=1
	Seremoteshutdownprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seremoteshutdownprivilege,omitempty"`
	// Serestoreprivilege represents XSD element 'serestoreprivilege'
	// minOccurs=0, maxOccurs=1
	Serestoreprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"serestoreprivilege,omitempty"`
	// Sesecurityprivilege represents XSD element 'sesecurityprivilege'
	// minOccurs=0, maxOccurs=1
	Sesecurityprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sesecurityprivilege,omitempty"`
	// Seshutdownprivilege represents XSD element 'seshutdownprivilege'
	// minOccurs=0, maxOccurs=1
	Seshutdownprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seshutdownprivilege,omitempty"`
	// Sesyncagentprivilege represents XSD element 'sesyncagentprivilege'
	// minOccurs=0, maxOccurs=1
	Sesyncagentprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sesyncagentprivilege,omitempty"`
	// Sesystemenvironmentprivilege represents XSD element 'sesystemenvironmentprivilege'
	// minOccurs=0, maxOccurs=1
	Sesystemenvironmentprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sesystemenvironmentprivilege,omitempty"`
	// Sesystemprofileprivilege represents XSD element 'sesystemprofileprivilege'
	// minOccurs=0, maxOccurs=1
	Sesystemprofileprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sesystemprofileprivilege,omitempty"`
	// Sesystemtimeprivilege represents XSD element 'sesystemtimeprivilege'
	// minOccurs=0, maxOccurs=1
	Sesystemtimeprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sesystemtimeprivilege,omitempty"`
	// Setakeownershipprivilege represents XSD element 'setakeownershipprivilege'
	// minOccurs=0, maxOccurs=1
	Setakeownershipprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"setakeownershipprivilege,omitempty"`
	// Setcbprivilege represents XSD element 'setcbprivilege'
	// minOccurs=0, maxOccurs=1
	Setcbprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"setcbprivilege,omitempty"`
	// Setimezoneprivilege represents XSD element 'setimezoneprivilege'
	// minOccurs=0, maxOccurs=1
	Setimezoneprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"setimezoneprivilege,omitempty"`
	// Seundockprivilege represents XSD element 'seundockprivilege'
	// minOccurs=0, maxOccurs=1
	Seundockprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seundockprivilege,omitempty"`
	// Seunsolicitedinputprivilege represents XSD element 'seunsolicitedinputprivilege'
	// minOccurs=0, maxOccurs=1
	Seunsolicitedinputprivilege *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seunsolicitedinputprivilege,omitempty"`
	// Sebatchlogonright represents XSD element 'sebatchlogonright'
	// minOccurs=0, maxOccurs=1
	Sebatchlogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sebatchlogonright,omitempty"`
	// Seinteractivelogonright represents XSD element 'seinteractivelogonright'
	// minOccurs=0, maxOccurs=1
	Seinteractivelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seinteractivelogonright,omitempty"`
	// Senetworklogonright represents XSD element 'senetworklogonright'
	// minOccurs=0, maxOccurs=1
	Senetworklogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"senetworklogonright,omitempty"`
	// Seremoteinteractivelogonright represents XSD element 'seremoteinteractivelogonright'
	// minOccurs=0, maxOccurs=1
	Seremoteinteractivelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seremoteinteractivelogonright,omitempty"`
	// Seservicelogonright represents XSD element 'seservicelogonright'
	// minOccurs=0, maxOccurs=1
	Seservicelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"seservicelogonright,omitempty"`
	// SedenybatchLogonright represents XSD element 'sedenybatchLogonright'
	// minOccurs=0, maxOccurs=1
	SedenybatchLogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedenybatchLogonright,omitempty"`
	// Sedenyinteractivelogonright represents XSD element 'sedenyinteractivelogonright'
	// minOccurs=0, maxOccurs=1
	Sedenyinteractivelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedenyinteractivelogonright,omitempty"`
	// Sedenynetworklogonright represents XSD element 'sedenynetworklogonright'
	// minOccurs=0, maxOccurs=1
	Sedenynetworklogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedenynetworklogonright,omitempty"`
	// SedenyremoteInteractivelogonright represents XSD element 'sedenyremoteInteractivelogonright'
	// minOccurs=0, maxOccurs=1
	SedenyremoteInteractivelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedenyremoteInteractivelogonright,omitempty"`
	// Sedenyservicelogonright represents XSD element 'sedenyservicelogonright'
	// minOccurs=0, maxOccurs=1
	Sedenyservicelogonright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"sedenyservicelogonright,omitempty"`
	// Setrustedcredmanaccessnameright represents XSD element 'setrustedcredmanaccessnameright'
	// minOccurs=0, maxOccurs=1
	Setrustedcredmanaccessnameright *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"setrustedcredmanaccessnameright,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Accesstoken_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Accesstoken_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Accesstoken_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Accesstoken_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Accesstoken_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Accesstoken_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Accesstoken_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Accesstoken_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Accesstoken_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAccesstoken_stateFromBytes loads an element from bytes with namespace preservation
func LoadAccesstoken_stateFromBytes(data []byte) (*Accesstoken_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Accesstoken_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAccesstoken_stateFromFile loads an element from a file with namespace preservation
func LoadAccesstoken_stateFromFile(path string) (*Accesstoken_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAccesstoken_stateFromBytes(data)
}

// Cmdlet_objectElement represents the XSD element 'cmdlet_object'
// XSD element declaration (W3C XSD §3.3)
type Cmdlet_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows cmdlet_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Module_name represents XSD element 'module_name'
	Module_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"module_name"`
	// Module_id represents XSD element 'module_id'
	Module_id EntityObjectGUIDType `xml:"module_id"`
	// Module_version represents XSD element 'module_version'
	Module_version xmlschemaoval_definitions_5.EntityObjectVersionType `xml:"module_version"`
	// Verb represents XSD element 'verb'
	Verb EntityObjectCmdletVerbType `xml:"verb"`
	// Noun represents XSD element 'noun'
	Noun xmlschemaoval_definitions_5.EntityObjectStringType `xml:"noun"`
	// Parameters represents XSD element 'parameters'
	Parameters xmlschemaoval_definitions_5.EntityObjectRecordType `xml:"parameters"`
	// Select represents XSD element 'select'
	Select xmlschemaoval_definitions_5.EntityObjectRecordType `xml:"select"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Cmdlet_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Cmdlet_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Cmdlet_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Cmdlet_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Cmdlet_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Cmdlet_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Cmdlet_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Cmdlet_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Cmdlet_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadCmdlet_objectFromBytes loads an element from bytes with namespace preservation
func LoadCmdlet_objectFromBytes(data []byte) (*Cmdlet_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Cmdlet_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadCmdlet_objectFromFile loads an element from a file with namespace preservation
func LoadCmdlet_objectFromFile(path string) (*Cmdlet_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadCmdlet_objectFromBytes(data)
}

// Group_sid_testElement represents the XSD element 'group_sid_test'
// XSD element declaration (W3C XSD §3.3)
type Group_sid_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_sid_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_sid_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_sid_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_sid_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_sid_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_sid_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_sid_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_sid_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_sid_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_sid_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_sid_testFromBytes loads an element from bytes with namespace preservation
func LoadGroup_sid_testFromBytes(data []byte) (*Group_sid_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_sid_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_sid_testFromFile loads an element from a file with namespace preservation
func LoadGroup_sid_testFromFile(path string) (*Group_sid_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_sid_testFromBytes(data)
}

// Process58_objectElement represents the XSD element 'process58_object'
// XSD element declaration (W3C XSD §3.3)
type Process58_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process58_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Command_line represents XSD element 'command_line'
	Command_line xmlschemaoval_definitions_5.EntityObjectStringType `xml:"command_line"`
	// Pid represents XSD element 'pid'
	Pid xmlschemaoval_definitions_5.EntityObjectIntType `xml:"pid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process58_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process58_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process58_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process58_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process58_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process58_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process58_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process58_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process58_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess58_objectFromBytes loads an element from bytes with namespace preservation
func LoadProcess58_objectFromBytes(data []byte) (*Process58_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process58_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess58_objectFromFile loads an element from a file with namespace preservation
func LoadProcess58_objectFromFile(path string) (*Process58_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess58_objectFromBytes(data)
}

// Service_objectElement represents the XSD element 'service_object'
// XSD element declaration (W3C XSD §3.3)
type Service_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows service_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Service_name represents XSD element 'service_name'
	Service_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"service_name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Service_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Service_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Service_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Service_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Service_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Service_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Service_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Service_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Service_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadService_objectFromBytes loads an element from bytes with namespace preservation
func LoadService_objectFromBytes(data []byte) (*Service_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Service_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadService_objectFromFile loads an element from a file with namespace preservation
func LoadService_objectFromFile(path string) (*Service_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadService_objectFromBytes(data)
}

// Uac_objectElement represents the XSD element 'uac_object'
// XSD element declaration (W3C XSD §3.3)
type Uac_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows uac_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Uac_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Uac_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Uac_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Uac_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Uac_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Uac_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Uac_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Uac_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Uac_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUac_objectFromBytes loads an element from bytes with namespace preservation
func LoadUac_objectFromBytes(data []byte) (*Uac_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Uac_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUac_objectFromFile loads an element from a file with namespace preservation
func LoadUac_objectFromFile(path string) (*Uac_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUac_objectFromBytes(data)
}

// User_testElement represents the XSD element 'user_test'
// XSD element declaration (W3C XSD §3.3)
type User_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_testFromBytes loads an element from bytes with namespace preservation
func LoadUser_testFromBytes(data []byte) (*User_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_testFromFile loads an element from a file with namespace preservation
func LoadUser_testFromFile(path string) (*User_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_testFromBytes(data)
}

// User_objectElement represents the XSD element 'user_object'
// XSD element declaration (W3C XSD §3.3)
type User_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// User represents XSD element 'user'
	User xmlschemaoval_definitions_5.EntityObjectStringType `xml:"user"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_objectFromBytes loads an element from bytes with namespace preservation
func LoadUser_objectFromBytes(data []byte) (*User_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_objectFromFile loads an element from a file with namespace preservation
func LoadUser_objectFromFile(path string) (*User_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_objectFromBytes(data)
}

// File_objectElement represents the XSD element 'file_object'
// XSD element declaration (W3C XSD §3.3)
type File_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows file_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileBehaviors `xml:"behaviors,omitempty"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// Filepath represents XSD element 'filepath'
	Filepath *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *File_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias File_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *File_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias File_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *File_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *File_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *File_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *File_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *File_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFile_objectFromBytes loads an element from bytes with namespace preservation
func LoadFile_objectFromBytes(data []byte) (*File_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element File_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFile_objectFromFile loads an element from a file with namespace preservation
func LoadFile_objectFromFile(path string) (*File_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFile_objectFromBytes(data)
}

// Lockoutpolicy_testElement represents the XSD element 'lockoutpolicy_test'
// XSD element declaration (W3C XSD §3.3)
type Lockoutpolicy_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows lockoutpolicy_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Lockoutpolicy_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Lockoutpolicy_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Lockoutpolicy_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Lockoutpolicy_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Lockoutpolicy_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Lockoutpolicy_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Lockoutpolicy_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Lockoutpolicy_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Lockoutpolicy_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLockoutpolicy_testFromBytes loads an element from bytes with namespace preservation
func LoadLockoutpolicy_testFromBytes(data []byte) (*Lockoutpolicy_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Lockoutpolicy_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLockoutpolicy_testFromFile loads an element from a file with namespace preservation
func LoadLockoutpolicy_testFromFile(path string) (*Lockoutpolicy_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLockoutpolicy_testFromBytes(data)
}

// Service_testElement represents the XSD element 'service_test'
// XSD element declaration (W3C XSD §3.3)
type Service_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows service_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Service_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Service_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Service_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Service_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Service_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Service_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Service_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Service_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Service_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadService_testFromBytes loads an element from bytes with namespace preservation
func LoadService_testFromBytes(data []byte) (*Service_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Service_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadService_testFromFile loads an element from a file with namespace preservation
func LoadService_testFromFile(path string) (*Service_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadService_testFromBytes(data)
}

// Userright_stateElement represents the XSD element 'userright_state'
// XSD element declaration (W3C XSD §3.3)
type Userright_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows userright_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Userright represents XSD element 'userright'
	// minOccurs=0, maxOccurs=1
	Userright *EntityStateUserRightType `xml:"userright,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Userright_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Userright_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Userright_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Userright_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Userright_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Userright_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Userright_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Userright_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Userright_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUserright_stateFromBytes loads an element from bytes with namespace preservation
func LoadUserright_stateFromBytes(data []byte) (*Userright_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Userright_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUserright_stateFromFile loads an element from a file with namespace preservation
func LoadUserright_stateFromFile(path string) (*Userright_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUserright_stateFromBytes(data)
}

// Fileauditedpermissions53_testElement represents the XSD element 'fileauditedpermissions53_test'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions53_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions53_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions53_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions53_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions53_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions53_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions53_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions53_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions53_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions53_testFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions53_testFromBytes(data []byte) (*Fileauditedpermissions53_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions53_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions53_testFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions53_testFromFile(path string) (*Fileauditedpermissions53_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions53_testFromBytes(data)
}

// Port_stateElement represents the XSD element 'port_state'
// XSD element declaration (W3C XSD §3.3)
type Port_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows port_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Local_address represents XSD element 'local_address'
	// minOccurs=0, maxOccurs=1
	Local_address *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"local_address,omitempty"`
	// Local_port represents XSD element 'local_port'
	// minOccurs=0, maxOccurs=1
	Local_port *xmlschemaoval_definitions_5.EntityStateIntType `xml:"local_port,omitempty"`
	// Protocol represents XSD element 'protocol'
	// minOccurs=0, maxOccurs=1
	Protocol *EntityStateProtocolType `xml:"protocol,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// Foreign_address represents XSD element 'foreign_address'
	// minOccurs=0, maxOccurs=1
	Foreign_address *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"foreign_address,omitempty"`
	// Foreign_port represents XSD element 'foreign_port'
	// minOccurs=0, maxOccurs=1
	Foreign_port *xmlschemaoval_definitions_5.EntityStateStringType `xml:"foreign_port,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Port_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Port_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Port_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Port_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Port_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Port_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Port_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Port_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Port_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPort_stateFromBytes loads an element from bytes with namespace preservation
func LoadPort_stateFromBytes(data []byte) (*Port_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Port_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPort_stateFromFile loads an element from a file with namespace preservation
func LoadPort_stateFromFile(path string) (*Port_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPort_stateFromBytes(data)
}

// Activedirectory_objectElement represents the XSD element 'activedirectory_object'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Naming_context represents XSD element 'naming_context'
	Naming_context EntityObjectNamingContextType `xml:"naming_context"`
	// Relative_dn represents XSD element 'relative_dn'
	Relative_dn xmlschemaoval_definitions_5.EntityObjectStringType `xml:"relative_dn"`
	// Attribute represents XSD element 'attribute'
	Attribute xmlschemaoval_definitions_5.EntityObjectStringType `xml:"attribute"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory_objectFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory_objectFromBytes(data []byte) (*Activedirectory_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory_objectFromFile loads an element from a file with namespace preservation
func LoadActivedirectory_objectFromFile(path string) (*Activedirectory_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory_objectFromBytes(data)
}

// Fileauditedpermissions_objectElement represents the XSD element 'fileauditedpermissions_object'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileAuditPermissionsBehaviors `xml:"behaviors,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// Trustee_name represents XSD element 'trustee_name'
	Trustee_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_name"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions_objectFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions_objectFromBytes(data []byte) (*Fileauditedpermissions_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions_objectFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions_objectFromFile(path string) (*Fileauditedpermissions_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions_objectFromBytes(data)
}

// User_sid55_testElement represents the XSD element 'user_sid55_test'
// XSD element declaration (W3C XSD §3.3)
type User_sid55_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid55_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid55_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid55_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid55_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid55_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid55_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid55_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid55_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid55_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid55_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid55_testFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid55_testFromBytes(data []byte) (*User_sid55_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid55_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid55_testFromFile loads an element from a file with namespace preservation
func LoadUser_sid55_testFromFile(path string) (*User_sid55_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid55_testFromBytes(data)
}

// Auditeventpolicy_stateElement represents the XSD element 'auditeventpolicy_state'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicy_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicy_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Account_logon represents XSD element 'account_logon'
	// minOccurs=0, maxOccurs=1
	Account_logon *EntityStateAuditType `xml:"account_logon,omitempty"`
	// Account_management represents XSD element 'account_management'
	// minOccurs=0, maxOccurs=1
	Account_management *EntityStateAuditType `xml:"account_management,omitempty"`
	// Detailed_tracking represents XSD element 'detailed_tracking'
	// minOccurs=0, maxOccurs=1
	Detailed_tracking *EntityStateAuditType `xml:"detailed_tracking,omitempty"`
	// Directory_service_access represents XSD element 'directory_service_access'
	// minOccurs=0, maxOccurs=1
	Directory_service_access *EntityStateAuditType `xml:"directory_service_access,omitempty"`
	// Logon represents XSD element 'logon'
	// minOccurs=0, maxOccurs=1
	Logon *EntityStateAuditType `xml:"logon,omitempty"`
	// Object_access represents XSD element 'object_access'
	// minOccurs=0, maxOccurs=1
	Object_access *EntityStateAuditType `xml:"object_access,omitempty"`
	// Policy_change represents XSD element 'policy_change'
	// minOccurs=0, maxOccurs=1
	Policy_change *EntityStateAuditType `xml:"policy_change,omitempty"`
	// Privilege_use represents XSD element 'privilege_use'
	// minOccurs=0, maxOccurs=1
	Privilege_use *EntityStateAuditType `xml:"privilege_use,omitempty"`
	// System represents XSD element 'system'
	// minOccurs=0, maxOccurs=1
	System *EntityStateAuditType `xml:"system,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicy_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicy_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicy_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicy_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicy_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicy_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicy_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicy_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicy_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicy_stateFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicy_stateFromBytes(data []byte) (*Auditeventpolicy_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicy_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicy_stateFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicy_stateFromFile(path string) (*Auditeventpolicy_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicy_stateFromBytes(data)
}

// Dnscache_objectElement represents the XSD element 'dnscache_object'
// XSD element declaration (W3C XSD §3.3)
type Dnscache_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows dnscache_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Domain_name represents XSD element 'domain_name'
	Domain_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"domain_name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dnscache_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dnscache_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dnscache_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dnscache_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dnscache_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dnscache_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dnscache_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dnscache_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dnscache_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDnscache_objectFromBytes loads an element from bytes with namespace preservation
func LoadDnscache_objectFromBytes(data []byte) (*Dnscache_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dnscache_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDnscache_objectFromFile loads an element from a file with namespace preservation
func LoadDnscache_objectFromFile(path string) (*Dnscache_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDnscache_objectFromBytes(data)
}

// Fileauditedpermissions_stateElement represents the XSD element 'fileauditedpermissions_state'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *EntityStateAuditType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *EntityStateAuditType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *EntityStateAuditType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *EntityStateAuditType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *EntityStateAuditType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *EntityStateAuditType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *EntityStateAuditType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *EntityStateAuditType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *EntityStateAuditType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *EntityStateAuditType `xml:"generic_all,omitempty"`
	// File_read_data represents XSD element 'file_read_data'
	// minOccurs=0, maxOccurs=1
	File_read_data *EntityStateAuditType `xml:"file_read_data,omitempty"`
	// File_write_data represents XSD element 'file_write_data'
	// minOccurs=0, maxOccurs=1
	File_write_data *EntityStateAuditType `xml:"file_write_data,omitempty"`
	// File_append_data represents XSD element 'file_append_data'
	// minOccurs=0, maxOccurs=1
	File_append_data *EntityStateAuditType `xml:"file_append_data,omitempty"`
	// File_read_ea represents XSD element 'file_read_ea'
	// minOccurs=0, maxOccurs=1
	File_read_ea *EntityStateAuditType `xml:"file_read_ea,omitempty"`
	// File_write_ea represents XSD element 'file_write_ea'
	// minOccurs=0, maxOccurs=1
	File_write_ea *EntityStateAuditType `xml:"file_write_ea,omitempty"`
	// File_execute represents XSD element 'file_execute'
	// minOccurs=0, maxOccurs=1
	File_execute *EntityStateAuditType `xml:"file_execute,omitempty"`
	// File_delete_child represents XSD element 'file_delete_child'
	// minOccurs=0, maxOccurs=1
	File_delete_child *EntityStateAuditType `xml:"file_delete_child,omitempty"`
	// File_read_attributes represents XSD element 'file_read_attributes'
	// minOccurs=0, maxOccurs=1
	File_read_attributes *EntityStateAuditType `xml:"file_read_attributes,omitempty"`
	// File_write_attributes represents XSD element 'file_write_attributes'
	// minOccurs=0, maxOccurs=1
	File_write_attributes *EntityStateAuditType `xml:"file_write_attributes,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions_stateFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions_stateFromBytes(data []byte) (*Fileauditedpermissions_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions_stateFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions_stateFromFile(path string) (*Fileauditedpermissions_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions_stateFromBytes(data)
}

// Group_testElement represents the XSD element 'group_test'
// XSD element declaration (W3C XSD §3.3)
type Group_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_testFromBytes loads an element from bytes with namespace preservation
func LoadGroup_testFromBytes(data []byte) (*Group_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_testFromFile loads an element from a file with namespace preservation
func LoadGroup_testFromFile(path string) (*Group_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_testFromBytes(data)
}

// Peheader_stateElement represents the XSD element 'peheader_state'
// XSD element declaration (W3C XSD §3.3)
type Peheader_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows peheader_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Header_signature represents XSD element 'header_signature'
	// minOccurs=0, maxOccurs=1
	Header_signature *xmlschemaoval_definitions_5.EntityStateStringType `xml:"header_signature,omitempty"`
	// Target_machine_type represents XSD element 'target_machine_type'
	// minOccurs=0, maxOccurs=1
	Target_machine_type *EntityStatePeTargetMachineType `xml:"target_machine_type,omitempty"`
	// Number_of_sections represents XSD element 'number_of_sections'
	// minOccurs=0, maxOccurs=1
	Number_of_sections *xmlschemaoval_definitions_5.EntityStateIntType `xml:"number_of_sections,omitempty"`
	// Time_date_stamp represents XSD element 'time_date_stamp'
	// minOccurs=0, maxOccurs=1
	Time_date_stamp *xmlschemaoval_definitions_5.EntityStateIntType `xml:"time_date_stamp,omitempty"`
	// Pointer_to_symbol_table represents XSD element 'pointer_to_symbol_table'
	// minOccurs=0, maxOccurs=1
	Pointer_to_symbol_table *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pointer_to_symbol_table,omitempty"`
	// Number_of_symbols represents XSD element 'number_of_symbols'
	// minOccurs=0, maxOccurs=1
	Number_of_symbols *xmlschemaoval_definitions_5.EntityStateIntType `xml:"number_of_symbols,omitempty"`
	// Size_of_optional_header represents XSD element 'size_of_optional_header'
	// minOccurs=0, maxOccurs=1
	Size_of_optional_header *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_optional_header,omitempty"`
	// Image_file_relocs_stripped represents XSD element 'image_file_relocs_stripped'
	// minOccurs=0, maxOccurs=1
	Image_file_relocs_stripped *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_relocs_stripped,omitempty"`
	// Image_file_executable_image represents XSD element 'image_file_executable_image'
	// minOccurs=0, maxOccurs=1
	Image_file_executable_image *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_executable_image,omitempty"`
	// Image_file_line_nums_stripped represents XSD element 'image_file_line_nums_stripped'
	// minOccurs=0, maxOccurs=1
	Image_file_line_nums_stripped *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_line_nums_stripped,omitempty"`
	// Image_file_local_syms_stripped represents XSD element 'image_file_local_syms_stripped'
	// minOccurs=0, maxOccurs=1
	Image_file_local_syms_stripped *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_local_syms_stripped,omitempty"`
	// Image_file_aggresive_ws_trim represents XSD element 'image_file_aggresive_ws_trim'
	// minOccurs=0, maxOccurs=1
	Image_file_aggresive_ws_trim *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_aggresive_ws_trim,omitempty"`
	// Image_file_large_address_aware represents XSD element 'image_file_large_address_aware'
	// minOccurs=0, maxOccurs=1
	Image_file_large_address_aware *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_large_address_aware,omitempty"`
	// Image_file_16bit_machine represents XSD element 'image_file_16bit_machine'
	// minOccurs=0, maxOccurs=1
	Image_file_16bit_machine *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_16bit_machine,omitempty"`
	// Image_file_bytes_reversed_lo represents XSD element 'image_file_bytes_reversed_lo'
	// minOccurs=0, maxOccurs=1
	Image_file_bytes_reversed_lo *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_bytes_reversed_lo,omitempty"`
	// Image_file_32bit_machine represents XSD element 'image_file_32bit_machine'
	// minOccurs=0, maxOccurs=1
	Image_file_32bit_machine *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_32bit_machine,omitempty"`
	// Image_file_debug_stripped represents XSD element 'image_file_debug_stripped'
	// minOccurs=0, maxOccurs=1
	Image_file_debug_stripped *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_debug_stripped,omitempty"`
	// Image_file_removable_run_from_swap represents XSD element 'image_file_removable_run_from_swap'
	// minOccurs=0, maxOccurs=1
	Image_file_removable_run_from_swap *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_removable_run_from_swap,omitempty"`
	// Image_file_system represents XSD element 'image_file_system'
	// minOccurs=0, maxOccurs=1
	Image_file_system *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_system,omitempty"`
	// Image_file_dll represents XSD element 'image_file_dll'
	// minOccurs=0, maxOccurs=1
	Image_file_dll *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_dll,omitempty"`
	// Image_file_up_system_only represents XSD element 'image_file_up_system_only'
	// minOccurs=0, maxOccurs=1
	Image_file_up_system_only *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_up_system_only,omitempty"`
	// Image_file_bytes_reveresed_hi represents XSD element 'image_file_bytes_reveresed_hi'
	// minOccurs=0, maxOccurs=1
	Image_file_bytes_reveresed_hi *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"image_file_bytes_reveresed_hi,omitempty"`
	// Magic_number represents XSD element 'magic_number'
	// minOccurs=0, maxOccurs=1
	Magic_number *xmlschemaoval_definitions_5.EntityStateIntType `xml:"magic_number,omitempty"`
	// Major_linker_version represents XSD element 'major_linker_version'
	// minOccurs=0, maxOccurs=1
	Major_linker_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"major_linker_version,omitempty"`
	// Minor_linker_version represents XSD element 'minor_linker_version'
	// minOccurs=0, maxOccurs=1
	Minor_linker_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"minor_linker_version,omitempty"`
	// Size_of_code represents XSD element 'size_of_code'
	// minOccurs=0, maxOccurs=1
	Size_of_code *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_code,omitempty"`
	// Size_of_initialized_data represents XSD element 'size_of_initialized_data'
	// minOccurs=0, maxOccurs=1
	Size_of_initialized_data *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_initialized_data,omitempty"`
	// Size_of_uninitialized_data represents XSD element 'size_of_uninitialized_data'
	// minOccurs=0, maxOccurs=1
	Size_of_uninitialized_data *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_uninitialized_data,omitempty"`
	// Address_of_entry_point represents XSD element 'address_of_entry_point'
	// minOccurs=0, maxOccurs=1
	Address_of_entry_point *xmlschemaoval_definitions_5.EntityStateIntType `xml:"address_of_entry_point,omitempty"`
	// Base_of_code represents XSD element 'base_of_code'
	// minOccurs=0, maxOccurs=1
	Base_of_code *xmlschemaoval_definitions_5.EntityStateIntType `xml:"base_of_code,omitempty"`
	// Base_of_data represents XSD element 'base_of_data'
	// minOccurs=0, maxOccurs=1
	Base_of_data *xmlschemaoval_definitions_5.EntityStateIntType `xml:"base_of_data,omitempty"`
	// Image_base_address represents XSD element 'image_base_address'
	// minOccurs=0, maxOccurs=1
	Image_base_address *xmlschemaoval_definitions_5.EntityStateIntType `xml:"image_base_address,omitempty"`
	// Section_alignment represents XSD element 'section_alignment'
	// minOccurs=0, maxOccurs=1
	Section_alignment *xmlschemaoval_definitions_5.EntityStateIntType `xml:"section_alignment,omitempty"`
	// File_alignment represents XSD element 'file_alignment'
	// minOccurs=0, maxOccurs=1
	File_alignment *xmlschemaoval_definitions_5.EntityStateIntType `xml:"file_alignment,omitempty"`
	// Major_operating_system_version represents XSD element 'major_operating_system_version'
	// minOccurs=0, maxOccurs=1
	Major_operating_system_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"major_operating_system_version,omitempty"`
	// Minor_operating_system_version represents XSD element 'minor_operating_system_version'
	// minOccurs=0, maxOccurs=1
	Minor_operating_system_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"minor_operating_system_version,omitempty"`
	// Major_image_version represents XSD element 'major_image_version'
	// minOccurs=0, maxOccurs=1
	Major_image_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"major_image_version,omitempty"`
	// Minor_image_version represents XSD element 'minor_image_version'
	// minOccurs=0, maxOccurs=1
	Minor_image_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"minor_image_version,omitempty"`
	// Major_subsystem_version represents XSD element 'major_subsystem_version'
	// minOccurs=0, maxOccurs=1
	Major_subsystem_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"major_subsystem_version,omitempty"`
	// Minor_susbsystem_version represents XSD element 'minor_susbsystem_version'
	// minOccurs=0, maxOccurs=1
	Minor_susbsystem_version *xmlschemaoval_definitions_5.EntityStateIntType `xml:"minor_susbsystem_version,omitempty"`
	// Size_of_image represents XSD element 'size_of_image'
	// minOccurs=0, maxOccurs=1
	Size_of_image *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_image,omitempty"`
	// Size_of_headers represents XSD element 'size_of_headers'
	// minOccurs=0, maxOccurs=1
	Size_of_headers *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_headers,omitempty"`
	// Checksum represents XSD element 'checksum'
	// minOccurs=0, maxOccurs=1
	Checksum *xmlschemaoval_definitions_5.EntityStateIntType `xml:"checksum,omitempty"`
	// Subsystem represents XSD element 'subsystem'
	// minOccurs=0, maxOccurs=1
	Subsystem *EntityStatePeSubsystemType `xml:"subsystem,omitempty"`
	// Dll_characteristics represents XSD element 'dll_characteristics'
	// minOccurs=0, maxOccurs=1
	Dll_characteristics *xmlschemaoval_definitions_5.EntityStateIntType `xml:"dll_characteristics,omitempty"`
	// Size_of_stack_reserve represents XSD element 'size_of_stack_reserve'
	// minOccurs=0, maxOccurs=1
	Size_of_stack_reserve *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_stack_reserve,omitempty"`
	// Size_of_stack_commit represents XSD element 'size_of_stack_commit'
	// minOccurs=0, maxOccurs=1
	Size_of_stack_commit *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_stack_commit,omitempty"`
	// Size_of_heap_reserve represents XSD element 'size_of_heap_reserve'
	// minOccurs=0, maxOccurs=1
	Size_of_heap_reserve *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_heap_reserve,omitempty"`
	// Size_of_heap_commit represents XSD element 'size_of_heap_commit'
	// minOccurs=0, maxOccurs=1
	Size_of_heap_commit *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size_of_heap_commit,omitempty"`
	// Loader_flags represents XSD element 'loader_flags'
	// minOccurs=0, maxOccurs=1
	Loader_flags *xmlschemaoval_definitions_5.EntityStateIntType `xml:"loader_flags,omitempty"`
	// Number_of_rva_and_sizes represents XSD element 'number_of_rva_and_sizes'
	// minOccurs=0, maxOccurs=1
	Number_of_rva_and_sizes *xmlschemaoval_definitions_5.EntityStateIntType `xml:"number_of_rva_and_sizes,omitempty"`
	// Real_number_of_directory_entries represents XSD element 'real_number_of_directory_entries'
	// minOccurs=0, maxOccurs=1
	Real_number_of_directory_entries *xmlschemaoval_definitions_5.EntityStateIntType `xml:"real_number_of_directory_entries,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Peheader_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Peheader_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Peheader_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Peheader_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Peheader_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Peheader_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Peheader_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Peheader_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Peheader_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPeheader_stateFromBytes loads an element from bytes with namespace preservation
func LoadPeheader_stateFromBytes(data []byte) (*Peheader_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Peheader_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPeheader_stateFromFile loads an element from a file with namespace preservation
func LoadPeheader_stateFromFile(path string) (*Peheader_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPeheader_stateFromBytes(data)
}

// Regkeyeffectiverights53_objectElement represents the XSD element 'regkeyeffectiverights53_object'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights53_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights53_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RegkeyEffectiveRights53Behaviors `xml:"behaviors,omitempty"`
	// Hive represents XSD element 'hive'
	Hive EntityObjectRegistryHiveType `xml:"hive"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights53_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights53_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights53_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights53_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights53_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights53_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights53_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights53_objectFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights53_objectFromBytes(data []byte) (*Regkeyeffectiverights53_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights53_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights53_objectFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights53_objectFromFile(path string) (*Regkeyeffectiverights53_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights53_objectFromBytes(data)
}

// Junction_stateElement represents the XSD element 'junction_state'
// XSD element declaration (W3C XSD §3.3)
type Junction_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows junction_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Canonical_path represents XSD element 'canonical_path'
	// minOccurs=0, maxOccurs=1
	Canonical_path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"canonical_path,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Junction_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Junction_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Junction_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Junction_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Junction_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Junction_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Junction_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Junction_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Junction_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadJunction_stateFromBytes loads an element from bytes with namespace preservation
func LoadJunction_stateFromBytes(data []byte) (*Junction_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Junction_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadJunction_stateFromFile loads an element from a file with namespace preservation
func LoadJunction_stateFromFile(path string) (*Junction_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadJunction_stateFromBytes(data)
}

// Port_testElement represents the XSD element 'port_test'
// XSD element declaration (W3C XSD §3.3)
type Port_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows port_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Port_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Port_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Port_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Port_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Port_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Port_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Port_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Port_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Port_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPort_testFromBytes loads an element from bytes with namespace preservation
func LoadPort_testFromBytes(data []byte) (*Port_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Port_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPort_testFromFile loads an element from a file with namespace preservation
func LoadPort_testFromFile(path string) (*Port_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPort_testFromBytes(data)
}

// Registry_testElement represents the XSD element 'registry_test'
// XSD element declaration (W3C XSD §3.3)
type Registry_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows registry_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Registry_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Registry_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Registry_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Registry_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Registry_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Registry_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Registry_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Registry_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Registry_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegistry_testFromBytes loads an element from bytes with namespace preservation
func LoadRegistry_testFromBytes(data []byte) (*Registry_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Registry_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegistry_testFromFile loads an element from a file with namespace preservation
func LoadRegistry_testFromFile(path string) (*Registry_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegistry_testFromBytes(data)
}

// Regkeyeffectiverights53_testElement represents the XSD element 'regkeyeffectiverights53_test'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights53_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights53_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights53_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights53_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights53_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights53_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights53_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights53_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights53_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights53_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights53_testFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights53_testFromBytes(data []byte) (*Regkeyeffectiverights53_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights53_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights53_testFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights53_testFromFile(path string) (*Regkeyeffectiverights53_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights53_testFromBytes(data)
}

// Systemmetric_testElement represents the XSD element 'systemmetric_test'
// XSD element declaration (W3C XSD §3.3)
type Systemmetric_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows systemmetric_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemmetric_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemmetric_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemmetric_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemmetric_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemmetric_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemmetric_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemmetric_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemmetric_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemmetric_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemmetric_testFromBytes loads an element from bytes with namespace preservation
func LoadSystemmetric_testFromBytes(data []byte) (*Systemmetric_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemmetric_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemmetric_testFromFile loads an element from a file with namespace preservation
func LoadSystemmetric_testFromFile(path string) (*Systemmetric_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemmetric_testFromBytes(data)
}

// Fileeffectiverights_objectElement represents the XSD element 'fileeffectiverights_object'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileEffectiveRightsBehaviors `xml:"behaviors,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// Trustee_name represents XSD element 'trustee_name'
	Trustee_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_name"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights_objectFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights_objectFromBytes(data []byte) (*Fileeffectiverights_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights_objectFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights_objectFromFile(path string) (*Fileeffectiverights_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights_objectFromBytes(data)
}

// Wuaupdatesearcher_stateElement represents the XSD element 'wuaupdatesearcher_state'
// XSD element declaration (W3C XSD §3.3)
type Wuaupdatesearcher_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wuaupdatesearcher_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Search_criteria represents XSD element 'search_criteria'
	// minOccurs=0, maxOccurs=1
	Search_criteria *xmlschemaoval_definitions_5.EntityStateStringType `xml:"search_criteria,omitempty"`
	// Update_id represents XSD element 'update_id'
	// minOccurs=0, maxOccurs=1
	Update_id *xmlschemaoval_definitions_5.EntityStateStringType `xml:"update_id,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wuaupdatesearcher_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wuaupdatesearcher_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wuaupdatesearcher_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wuaupdatesearcher_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wuaupdatesearcher_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wuaupdatesearcher_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wuaupdatesearcher_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wuaupdatesearcher_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWuaupdatesearcher_stateFromBytes loads an element from bytes with namespace preservation
func LoadWuaupdatesearcher_stateFromBytes(data []byte) (*Wuaupdatesearcher_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wuaupdatesearcher_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWuaupdatesearcher_stateFromFile loads an element from a file with namespace preservation
func LoadWuaupdatesearcher_stateFromFile(path string) (*Wuaupdatesearcher_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWuaupdatesearcher_stateFromBytes(data)
}

// Serviceeffectiverights_objectElement represents the XSD element 'serviceeffectiverights_object'
// XSD element declaration (W3C XSD §3.3)
type Serviceeffectiverights_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows serviceeffectiverights_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *ServiceEffectiveRightsBehaviors `xml:"behaviors,omitempty"`
	// Service_name represents XSD element 'service_name'
	Service_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"service_name"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Serviceeffectiverights_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Serviceeffectiverights_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Serviceeffectiverights_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Serviceeffectiverights_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Serviceeffectiverights_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Serviceeffectiverights_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Serviceeffectiverights_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadServiceeffectiverights_objectFromBytes loads an element from bytes with namespace preservation
func LoadServiceeffectiverights_objectFromBytes(data []byte) (*Serviceeffectiverights_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Serviceeffectiverights_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadServiceeffectiverights_objectFromFile loads an element from a file with namespace preservation
func LoadServiceeffectiverights_objectFromFile(path string) (*Serviceeffectiverights_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadServiceeffectiverights_objectFromBytes(data)
}

// Sharedresourceauditedpermissions_testElement represents the XSD element 'sharedresourceauditedpermissions_test'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceauditedpermissions_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceauditedpermissions_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceauditedpermissions_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceauditedpermissions_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceauditedpermissions_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceauditedpermissions_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceauditedpermissions_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceauditedpermissions_testFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceauditedpermissions_testFromBytes(data []byte) (*Sharedresourceauditedpermissions_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceauditedpermissions_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceauditedpermissions_testFromFile loads an element from a file with namespace preservation
func LoadSharedresourceauditedpermissions_testFromFile(path string) (*Sharedresourceauditedpermissions_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceauditedpermissions_testFromBytes(data)
}

// Sharedresourceeffectiverights_objectElement represents the XSD element 'sharedresourceeffectiverights_object'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceeffectiverights_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceeffectiverights_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *SharedResourceEffectiveRightsBehaviors `xml:"behaviors,omitempty"`
	// Netname represents XSD element 'netname'
	Netname xmlschemaoval_definitions_5.EntityObjectStringType `xml:"netname"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceeffectiverights_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceeffectiverights_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceeffectiverights_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceeffectiverights_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceeffectiverights_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceeffectiverights_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceeffectiverights_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceeffectiverights_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceeffectiverights_objectFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceeffectiverights_objectFromBytes(data []byte) (*Sharedresourceeffectiverights_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceeffectiverights_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceeffectiverights_objectFromFile loads an element from a file with namespace preservation
func LoadSharedresourceeffectiverights_objectFromFile(path string) (*Sharedresourceeffectiverights_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceeffectiverights_objectFromBytes(data)
}

// Dnscache_testElement represents the XSD element 'dnscache_test'
// XSD element declaration (W3C XSD §3.3)
type Dnscache_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows dnscache_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dnscache_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dnscache_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dnscache_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dnscache_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dnscache_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dnscache_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dnscache_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dnscache_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dnscache_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDnscache_testFromBytes loads an element from bytes with namespace preservation
func LoadDnscache_testFromBytes(data []byte) (*Dnscache_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dnscache_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDnscache_testFromFile loads an element from a file with namespace preservation
func LoadDnscache_testFromFile(path string) (*Dnscache_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDnscache_testFromBytes(data)
}

// Junction_objectElement represents the XSD element 'junction_object'
// XSD element declaration (W3C XSD §3.3)
type Junction_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows junction_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileBehaviors `xml:"behaviors,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Junction_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Junction_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Junction_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Junction_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Junction_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Junction_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Junction_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Junction_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Junction_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadJunction_objectFromBytes loads an element from bytes with namespace preservation
func LoadJunction_objectFromBytes(data []byte) (*Junction_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Junction_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadJunction_objectFromFile loads an element from a file with namespace preservation
func LoadJunction_objectFromFile(path string) (*Junction_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadJunction_objectFromBytes(data)
}

// License_testElement represents the XSD element 'license_test'
// XSD element declaration (W3C XSD §3.3)
type License_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows license_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *License_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias License_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *License_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias License_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *License_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *License_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *License_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *License_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *License_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLicense_testFromBytes loads an element from bytes with namespace preservation
func LoadLicense_testFromBytes(data []byte) (*License_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element License_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLicense_testFromFile loads an element from a file with namespace preservation
func LoadLicense_testFromFile(path string) (*License_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLicense_testFromBytes(data)
}

// Process_testElement represents the XSD element 'process_test'
// XSD element declaration (W3C XSD §3.3)
type Process_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess_testFromBytes loads an element from bytes with namespace preservation
func LoadProcess_testFromBytes(data []byte) (*Process_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess_testFromFile loads an element from a file with namespace preservation
func LoadProcess_testFromFile(path string) (*Process_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess_testFromBytes(data)
}

// Process_stateElement represents the XSD element 'process_state'
// XSD element declaration (W3C XSD §3.3)
type Process_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Command_line represents XSD element 'command_line'
	// minOccurs=0, maxOccurs=1
	Command_line *xmlschemaoval_definitions_5.EntityStateStringType `xml:"command_line,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// Ppid represents XSD element 'ppid'
	// minOccurs=0, maxOccurs=1
	Ppid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"ppid,omitempty"`
	// Priority represents XSD element 'priority'
	// minOccurs=0, maxOccurs=1
	Priority *PriorityElementType `xml:"priority,omitempty"`
	// Image_path represents XSD element 'image_path'
	// minOccurs=0, maxOccurs=1
	Image_path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"image_path,omitempty"`
	// Current_dir represents XSD element 'current_dir'
	// minOccurs=0, maxOccurs=1
	Current_dir *xmlschemaoval_definitions_5.EntityStateStringType `xml:"current_dir,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess_stateFromBytes loads an element from bytes with namespace preservation
func LoadProcess_stateFromBytes(data []byte) (*Process_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess_stateFromFile loads an element from a file with namespace preservation
func LoadProcess_stateFromFile(path string) (*Process_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess_stateFromBytes(data)
}

// License_objectElement represents the XSD element 'license_object'
// XSD element declaration (W3C XSD §3.3)
type License_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows license_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *License_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias License_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *License_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias License_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *License_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *License_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *License_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *License_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *License_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadLicense_objectFromBytes loads an element from bytes with namespace preservation
func LoadLicense_objectFromBytes(data []byte) (*License_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element License_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadLicense_objectFromFile loads an element from a file with namespace preservation
func LoadLicense_objectFromFile(path string) (*License_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadLicense_objectFromBytes(data)
}

// Dnscache_stateElement represents the XSD element 'dnscache_state'
// XSD element declaration (W3C XSD §3.3)
type Dnscache_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows dnscache_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Domain_name represents XSD element 'domain_name'
	// minOccurs=0, maxOccurs=1
	Domain_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"domain_name,omitempty"`
	// Ttl represents XSD element 'ttl'
	// minOccurs=0, maxOccurs=1
	Ttl *xmlschemaoval_definitions_5.EntityStateIntType `xml:"ttl,omitempty"`
	// Ip_address represents XSD element 'ip_address'
	// minOccurs=0, maxOccurs=1
	Ip_address *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"ip_address,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Dnscache_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Dnscache_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Dnscache_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Dnscache_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Dnscache_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Dnscache_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Dnscache_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Dnscache_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Dnscache_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadDnscache_stateFromBytes loads an element from bytes with namespace preservation
func LoadDnscache_stateFromBytes(data []byte) (*Dnscache_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Dnscache_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadDnscache_stateFromFile loads an element from a file with namespace preservation
func LoadDnscache_stateFromFile(path string) (*Dnscache_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadDnscache_stateFromBytes(data)
}

// Auditeventpolicysubcategories_stateElement represents the XSD element 'auditeventpolicysubcategories_state'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicysubcategories_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicysubcategories_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Credential_validation represents XSD element 'credential_validation'
	// minOccurs=0, maxOccurs=1
	Credential_validation *EntityStateAuditType `xml:"credential_validation,omitempty"`
	// Kerberos_authentication_service represents XSD element 'kerberos_authentication_service'
	// minOccurs=0, maxOccurs=1
	Kerberos_authentication_service *EntityStateAuditType `xml:"kerberos_authentication_service,omitempty"`
	// Kerberos_service_ticket_operations represents XSD element 'kerberos_service_ticket_operations'
	// minOccurs=0, maxOccurs=1
	Kerberos_service_ticket_operations *EntityStateAuditType `xml:"kerberos_service_ticket_operations,omitempty"`
	// Kerberos_ticket_events represents XSD element 'kerberos_ticket_events'
	// minOccurs=0, maxOccurs=1
	Kerberos_ticket_events *EntityStateAuditType `xml:"kerberos_ticket_events,omitempty"`
	// Other_account_logon_events represents XSD element 'other_account_logon_events'
	// minOccurs=0, maxOccurs=1
	Other_account_logon_events *EntityStateAuditType `xml:"other_account_logon_events,omitempty"`
	// Application_group_management represents XSD element 'application_group_management'
	// minOccurs=0, maxOccurs=1
	Application_group_management *EntityStateAuditType `xml:"application_group_management,omitempty"`
	// Computer_account_management represents XSD element 'computer_account_management'
	// minOccurs=0, maxOccurs=1
	Computer_account_management *EntityStateAuditType `xml:"computer_account_management,omitempty"`
	// Distribution_group_management represents XSD element 'distribution_group_management'
	// minOccurs=0, maxOccurs=1
	Distribution_group_management *EntityStateAuditType `xml:"distribution_group_management,omitempty"`
	// Other_account_management_events represents XSD element 'other_account_management_events'
	// minOccurs=0, maxOccurs=1
	Other_account_management_events *EntityStateAuditType `xml:"other_account_management_events,omitempty"`
	// Security_group_management represents XSD element 'security_group_management'
	// minOccurs=0, maxOccurs=1
	Security_group_management *EntityStateAuditType `xml:"security_group_management,omitempty"`
	// User_account_management represents XSD element 'user_account_management'
	// minOccurs=0, maxOccurs=1
	User_account_management *EntityStateAuditType `xml:"user_account_management,omitempty"`
	// Dpapi_activity represents XSD element 'dpapi_activity'
	// minOccurs=0, maxOccurs=1
	Dpapi_activity *EntityStateAuditType `xml:"dpapi_activity,omitempty"`
	// Process_creation represents XSD element 'process_creation'
	// minOccurs=0, maxOccurs=1
	Process_creation *EntityStateAuditType `xml:"process_creation,omitempty"`
	// Process_termination represents XSD element 'process_termination'
	// minOccurs=0, maxOccurs=1
	Process_termination *EntityStateAuditType `xml:"process_termination,omitempty"`
	// Rpc_events represents XSD element 'rpc_events'
	// minOccurs=0, maxOccurs=1
	Rpc_events *EntityStateAuditType `xml:"rpc_events,omitempty"`
	// Directory_service_access represents XSD element 'directory_service_access'
	// minOccurs=0, maxOccurs=1
	Directory_service_access *EntityStateAuditType `xml:"directory_service_access,omitempty"`
	// Directory_service_changes represents XSD element 'directory_service_changes'
	// minOccurs=0, maxOccurs=1
	Directory_service_changes *EntityStateAuditType `xml:"directory_service_changes,omitempty"`
	// Directory_service_replication represents XSD element 'directory_service_replication'
	// minOccurs=0, maxOccurs=1
	Directory_service_replication *EntityStateAuditType `xml:"directory_service_replication,omitempty"`
	// Detailed_directory_service_replication represents XSD element 'detailed_directory_service_replication'
	// minOccurs=0, maxOccurs=1
	Detailed_directory_service_replication *EntityStateAuditType `xml:"detailed_directory_service_replication,omitempty"`
	// Account_lockout represents XSD element 'account_lockout'
	// minOccurs=0, maxOccurs=1
	Account_lockout *EntityStateAuditType `xml:"account_lockout,omitempty"`
	// Ipsec_extended_mode represents XSD element 'ipsec_extended_mode'
	// minOccurs=0, maxOccurs=1
	Ipsec_extended_mode *EntityStateAuditType `xml:"ipsec_extended_mode,omitempty"`
	// Ipsec_main_mode represents XSD element 'ipsec_main_mode'
	// minOccurs=0, maxOccurs=1
	Ipsec_main_mode *EntityStateAuditType `xml:"ipsec_main_mode,omitempty"`
	// Ipsec_quick_mode represents XSD element 'ipsec_quick_mode'
	// minOccurs=0, maxOccurs=1
	Ipsec_quick_mode *EntityStateAuditType `xml:"ipsec_quick_mode,omitempty"`
	// Logoff represents XSD element 'logoff'
	// minOccurs=0, maxOccurs=1
	Logoff *EntityStateAuditType `xml:"logoff,omitempty"`
	// Logon represents XSD element 'logon'
	// minOccurs=0, maxOccurs=1
	Logon *EntityStateAuditType `xml:"logon,omitempty"`
	// Network_policy_server represents XSD element 'network_policy_server'
	// minOccurs=0, maxOccurs=1
	Network_policy_server *EntityStateAuditType `xml:"network_policy_server,omitempty"`
	// Other_logon_logoff_events represents XSD element 'other_logon_logoff_events'
	// minOccurs=0, maxOccurs=1
	Other_logon_logoff_events *EntityStateAuditType `xml:"other_logon_logoff_events,omitempty"`
	// Special_logon represents XSD element 'special_logon'
	// minOccurs=0, maxOccurs=1
	Special_logon *EntityStateAuditType `xml:"special_logon,omitempty"`
	// Logon_claims represents XSD element 'logon_claims'
	// minOccurs=0, maxOccurs=1
	Logon_claims *EntityStateAuditType `xml:"logon_claims,omitempty"`
	// Application_generated represents XSD element 'application_generated'
	// minOccurs=0, maxOccurs=1
	Application_generated *EntityStateAuditType `xml:"application_generated,omitempty"`
	// Certification_services represents XSD element 'certification_services'
	// minOccurs=0, maxOccurs=1
	Certification_services *EntityStateAuditType `xml:"certification_services,omitempty"`
	// Detailed_file_share represents XSD element 'detailed_file_share'
	// minOccurs=0, maxOccurs=1
	Detailed_file_share *EntityStateAuditType `xml:"detailed_file_share,omitempty"`
	// File_share represents XSD element 'file_share'
	// minOccurs=0, maxOccurs=1
	File_share *EntityStateAuditType `xml:"file_share,omitempty"`
	// File_system represents XSD element 'file_system'
	// minOccurs=0, maxOccurs=1
	File_system *EntityStateAuditType `xml:"file_system,omitempty"`
	// Filtering_platform_connection represents XSD element 'filtering_platform_connection'
	// minOccurs=0, maxOccurs=1
	Filtering_platform_connection *EntityStateAuditType `xml:"filtering_platform_connection,omitempty"`
	// Filtering_platform_packet_drop represents XSD element 'filtering_platform_packet_drop'
	// minOccurs=0, maxOccurs=1
	Filtering_platform_packet_drop *EntityStateAuditType `xml:"filtering_platform_packet_drop,omitempty"`
	// Handle_manipulation represents XSD element 'handle_manipulation'
	// minOccurs=0, maxOccurs=1
	Handle_manipulation *EntityStateAuditType `xml:"handle_manipulation,omitempty"`
	// Kernel_object represents XSD element 'kernel_object'
	// minOccurs=0, maxOccurs=1
	Kernel_object *EntityStateAuditType `xml:"kernel_object,omitempty"`
	// Other_object_access_events represents XSD element 'other_object_access_events'
	// minOccurs=0, maxOccurs=1
	Other_object_access_events *EntityStateAuditType `xml:"other_object_access_events,omitempty"`
	// Registry represents XSD element 'registry'
	// minOccurs=0, maxOccurs=1
	Registry *EntityStateAuditType `xml:"registry,omitempty"`
	// Sam represents XSD element 'sam'
	// minOccurs=0, maxOccurs=1
	Sam *EntityStateAuditType `xml:"sam,omitempty"`
	// Removable_storage represents XSD element 'removable_storage'
	// minOccurs=0, maxOccurs=1
	Removable_storage *EntityStateAuditType `xml:"removable_storage,omitempty"`
	// Central_access_policy_staging represents XSD element 'central_access_policy_staging'
	// minOccurs=0, maxOccurs=1
	Central_access_policy_staging *EntityStateAuditType `xml:"central_access_policy_staging,omitempty"`
	// Audit_policy_change represents XSD element 'audit_policy_change'
	// minOccurs=0, maxOccurs=1
	Audit_policy_change *EntityStateAuditType `xml:"audit_policy_change,omitempty"`
	// Authentication_policy_change represents XSD element 'authentication_policy_change'
	// minOccurs=0, maxOccurs=1
	Authentication_policy_change *EntityStateAuditType `xml:"authentication_policy_change,omitempty"`
	// Authorization_policy_change represents XSD element 'authorization_policy_change'
	// minOccurs=0, maxOccurs=1
	Authorization_policy_change *EntityStateAuditType `xml:"authorization_policy_change,omitempty"`
	// Filtering_platform_policy_change represents XSD element 'filtering_platform_policy_change'
	// minOccurs=0, maxOccurs=1
	Filtering_platform_policy_change *EntityStateAuditType `xml:"filtering_platform_policy_change,omitempty"`
	// Mpssvc_rule_level_policy_change represents XSD element 'mpssvc_rule_level_policy_change'
	// minOccurs=0, maxOccurs=1
	Mpssvc_rule_level_policy_change *EntityStateAuditType `xml:"mpssvc_rule_level_policy_change,omitempty"`
	// Other_policy_change_events represents XSD element 'other_policy_change_events'
	// minOccurs=0, maxOccurs=1
	Other_policy_change_events *EntityStateAuditType `xml:"other_policy_change_events,omitempty"`
	// Non_sensitive_privilege_use represents XSD element 'non_sensitive_privilege_use'
	// minOccurs=0, maxOccurs=1
	Non_sensitive_privilege_use *EntityStateAuditType `xml:"non_sensitive_privilege_use,omitempty"`
	// Other_privilege_use_events represents XSD element 'other_privilege_use_events'
	// minOccurs=0, maxOccurs=1
	Other_privilege_use_events *EntityStateAuditType `xml:"other_privilege_use_events,omitempty"`
	// Sensitive_privilege_use represents XSD element 'sensitive_privilege_use'
	// minOccurs=0, maxOccurs=1
	Sensitive_privilege_use *EntityStateAuditType `xml:"sensitive_privilege_use,omitempty"`
	// Ipsec_driver represents XSD element 'ipsec_driver'
	// minOccurs=0, maxOccurs=1
	Ipsec_driver *EntityStateAuditType `xml:"ipsec_driver,omitempty"`
	// Other_system_events represents XSD element 'other_system_events'
	// minOccurs=0, maxOccurs=1
	Other_system_events *EntityStateAuditType `xml:"other_system_events,omitempty"`
	// Security_state_change represents XSD element 'security_state_change'
	// minOccurs=0, maxOccurs=1
	Security_state_change *EntityStateAuditType `xml:"security_state_change,omitempty"`
	// Security_system_extension represents XSD element 'security_system_extension'
	// minOccurs=0, maxOccurs=1
	Security_system_extension *EntityStateAuditType `xml:"security_system_extension,omitempty"`
	// System_integrity represents XSD element 'system_integrity'
	// minOccurs=0, maxOccurs=1
	System_integrity *EntityStateAuditType `xml:"system_integrity,omitempty"`
	// Group_membership represents XSD element 'group_membership'
	// minOccurs=0, maxOccurs=1
	Group_membership *EntityStateAuditType `xml:"group_membership,omitempty"`
	// Pnp_activity represents XSD element 'pnp_activity'
	// minOccurs=0, maxOccurs=1
	Pnp_activity *EntityStateAuditType `xml:"pnp_activity,omitempty"`
	// User_device_claims represents XSD element 'user_device_claims'
	// minOccurs=0, maxOccurs=1
	User_device_claims *EntityStateAuditType `xml:"user_device_claims,omitempty"`
	// Audit_detailedtracking_tokenrightadjusted represents XSD element 'audit_detailedtracking_tokenrightadjusted'
	// minOccurs=0, maxOccurs=1
	Audit_detailedtracking_tokenrightadjusted *EntityStateAuditType `xml:"audit_detailedtracking_tokenrightadjusted,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicysubcategories_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicysubcategories_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicysubcategories_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicysubcategories_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicysubcategories_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicysubcategories_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicysubcategories_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicysubcategories_stateFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicysubcategories_stateFromBytes(data []byte) (*Auditeventpolicysubcategories_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicysubcategories_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicysubcategories_stateFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicysubcategories_stateFromFile(path string) (*Auditeventpolicysubcategories_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicysubcategories_stateFromBytes(data)
}

// Printereffectiverights_testElement represents the XSD element 'printereffectiverights_test'
// XSD element declaration (W3C XSD §3.3)
type Printereffectiverights_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows printereffectiverights_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Printereffectiverights_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Printereffectiverights_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Printereffectiverights_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Printereffectiverights_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Printereffectiverights_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Printereffectiverights_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Printereffectiverights_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Printereffectiverights_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Printereffectiverights_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPrintereffectiverights_testFromBytes loads an element from bytes with namespace preservation
func LoadPrintereffectiverights_testFromBytes(data []byte) (*Printereffectiverights_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Printereffectiverights_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPrintereffectiverights_testFromFile loads an element from a file with namespace preservation
func LoadPrintereffectiverights_testFromFile(path string) (*Printereffectiverights_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPrintereffectiverights_testFromBytes(data)
}

// Userright_testElement represents the XSD element 'userright_test'
// XSD element declaration (W3C XSD §3.3)
type Userright_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows userright_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Userright_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Userright_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Userright_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Userright_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Userright_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Userright_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Userright_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Userright_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Userright_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUserright_testFromBytes loads an element from bytes with namespace preservation
func LoadUserright_testFromBytes(data []byte) (*Userright_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Userright_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUserright_testFromFile loads an element from a file with namespace preservation
func LoadUserright_testFromFile(path string) (*Userright_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUserright_testFromBytes(data)
}

// Wmi_testElement represents the XSD element 'wmi_test'
// XSD element declaration (W3C XSD §3.3)
type Wmi_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi_testFromBytes loads an element from bytes with namespace preservation
func LoadWmi_testFromBytes(data []byte) (*Wmi_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi_testFromFile loads an element from a file with namespace preservation
func LoadWmi_testFromFile(path string) (*Wmi_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi_testFromBytes(data)
}

// Wmi57_objectElement represents the XSD element 'wmi57_object'
// XSD element declaration (W3C XSD §3.3)
type Wmi57_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi57_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Namespace represents XSD element 'namespace'
	Namespace xmlschemaoval_definitions_5.EntityObjectStringType `xml:"namespace"`
	// Wql represents XSD element 'wql'
	Wql xmlschemaoval_definitions_5.EntityObjectStringType `xml:"wql"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi57_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi57_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi57_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi57_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi57_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi57_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi57_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi57_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi57_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi57_objectFromBytes loads an element from bytes with namespace preservation
func LoadWmi57_objectFromBytes(data []byte) (*Wmi57_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi57_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi57_objectFromFile loads an element from a file with namespace preservation
func LoadWmi57_objectFromFile(path string) (*Wmi57_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi57_objectFromBytes(data)
}

// Metabase_testElement represents the XSD element 'metabase_test'
// XSD element declaration (W3C XSD §3.3)
type Metabase_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows metabase_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Metabase_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Metabase_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Metabase_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Metabase_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Metabase_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Metabase_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Metabase_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Metabase_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Metabase_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadMetabase_testFromBytes loads an element from bytes with namespace preservation
func LoadMetabase_testFromBytes(data []byte) (*Metabase_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Metabase_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadMetabase_testFromFile loads an element from a file with namespace preservation
func LoadMetabase_testFromFile(path string) (*Metabase_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadMetabase_testFromBytes(data)
}

// Ntuser_testElement represents the XSD element 'ntuser_test'
// XSD element declaration (W3C XSD §3.3)
type Ntuser_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows ntuser_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Ntuser_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Ntuser_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Ntuser_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Ntuser_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Ntuser_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Ntuser_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Ntuser_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Ntuser_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Ntuser_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadNtuser_testFromBytes loads an element from bytes with namespace preservation
func LoadNtuser_testFromBytes(data []byte) (*Ntuser_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Ntuser_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadNtuser_testFromFile loads an element from a file with namespace preservation
func LoadNtuser_testFromFile(path string) (*Ntuser_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadNtuser_testFromBytes(data)
}

// Process58_testElement represents the XSD element 'process58_test'
// XSD element declaration (W3C XSD §3.3)
type Process58_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process58_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process58_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process58_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process58_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process58_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process58_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process58_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process58_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process58_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process58_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess58_testFromBytes loads an element from bytes with namespace preservation
func LoadProcess58_testFromBytes(data []byte) (*Process58_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process58_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess58_testFromFile loads an element from a file with namespace preservation
func LoadProcess58_testFromFile(path string) (*Process58_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess58_testFromBytes(data)
}

// Regkeyauditedpermissions_testElement represents the XSD element 'regkeyauditedpermissions_test'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions_testFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions_testFromBytes(data []byte) (*Regkeyauditedpermissions_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions_testFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions_testFromFile(path string) (*Regkeyauditedpermissions_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions_testFromBytes(data)
}

// Sharedresource_objectElement represents the XSD element 'sharedresource_object'
// XSD element declaration (W3C XSD §3.3)
type Sharedresource_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresource_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Netname represents XSD element 'netname'
	Netname xmlschemaoval_definitions_5.EntityObjectStringType `xml:"netname"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresource_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresource_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresource_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresource_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresource_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresource_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresource_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresource_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresource_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresource_objectFromBytes loads an element from bytes with namespace preservation
func LoadSharedresource_objectFromBytes(data []byte) (*Sharedresource_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresource_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresource_objectFromFile loads an element from a file with namespace preservation
func LoadSharedresource_objectFromFile(path string) (*Sharedresource_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresource_objectFromBytes(data)
}

// Uac_stateElement represents the XSD element 'uac_state'
// XSD element declaration (W3C XSD §3.3)
type Uac_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows uac_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Admin_approval_mode represents XSD element 'admin_approval_mode'
	// minOccurs=0, maxOccurs=1
	Admin_approval_mode *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"admin_approval_mode,omitempty"`
	// Elevation_prompt_admin represents XSD element 'elevation_prompt_admin'
	// minOccurs=0, maxOccurs=1
	Elevation_prompt_admin *xmlschemaoval_definitions_5.EntityStateStringType `xml:"elevation_prompt_admin,omitempty"`
	// Elevation_prompt_standard represents XSD element 'elevation_prompt_standard'
	// minOccurs=0, maxOccurs=1
	Elevation_prompt_standard *xmlschemaoval_definitions_5.EntityStateStringType `xml:"elevation_prompt_standard,omitempty"`
	// Detect_installations represents XSD element 'detect_installations'
	// minOccurs=0, maxOccurs=1
	Detect_installations *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"detect_installations,omitempty"`
	// Elevate_signed_executables represents XSD element 'elevate_signed_executables'
	// minOccurs=0, maxOccurs=1
	Elevate_signed_executables *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"elevate_signed_executables,omitempty"`
	// Elevate_uiaccess represents XSD element 'elevate_uiaccess'
	// minOccurs=0, maxOccurs=1
	Elevate_uiaccess *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"elevate_uiaccess,omitempty"`
	// Run_admins_aam represents XSD element 'run_admins_aam'
	// minOccurs=0, maxOccurs=1
	Run_admins_aam *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"run_admins_aam,omitempty"`
	// Secure_desktop represents XSD element 'secure_desktop'
	// minOccurs=0, maxOccurs=1
	Secure_desktop *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"secure_desktop,omitempty"`
	// Virtualize_write_failures represents XSD element 'virtualize_write_failures'
	// minOccurs=0, maxOccurs=1
	Virtualize_write_failures *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"virtualize_write_failures,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Uac_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Uac_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Uac_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Uac_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Uac_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Uac_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Uac_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Uac_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Uac_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUac_stateFromBytes loads an element from bytes with namespace preservation
func LoadUac_stateFromBytes(data []byte) (*Uac_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Uac_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUac_stateFromFile loads an element from a file with namespace preservation
func LoadUac_stateFromFile(path string) (*Uac_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUac_stateFromBytes(data)
}

// Regkeyauditedpermissions_objectElement represents the XSD element 'regkeyauditedpermissions_object'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RegkeyAuditPermissionsBehaviors `xml:"behaviors,omitempty"`
	// Hive represents XSD element 'hive'
	Hive EntityObjectRegistryHiveType `xml:"hive"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Trustee_name represents XSD element 'trustee_name'
	Trustee_name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_name"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions_objectFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions_objectFromBytes(data []byte) (*Regkeyauditedpermissions_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions_objectFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions_objectFromFile(path string) (*Regkeyauditedpermissions_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions_objectFromBytes(data)
}

// Regkeyeffectiverights_testElement represents the XSD element 'regkeyeffectiverights_test'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights_testFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights_testFromBytes(data []byte) (*Regkeyeffectiverights_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights_testFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights_testFromFile(path string) (*Regkeyeffectiverights_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights_testFromBytes(data)
}

// Sid_stateElement represents the XSD element 'sid_state'
// XSD element declaration (W3C XSD §3.3)
type Sid_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Trustee_domain represents XSD element 'trustee_domain'
	// minOccurs=0, maxOccurs=1
	Trustee_domain *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_domain,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_stateFromBytes loads an element from bytes with namespace preservation
func LoadSid_stateFromBytes(data []byte) (*Sid_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_stateFromFile loads an element from a file with namespace preservation
func LoadSid_stateFromFile(path string) (*Sid_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_stateFromBytes(data)
}

// User_sid_objectElement represents the XSD element 'user_sid_object'
// XSD element declaration (W3C XSD §3.3)
type User_sid_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// User represents XSD element 'user'
	User *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"user,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid_objectFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid_objectFromBytes(data []byte) (*User_sid_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid_objectFromFile loads an element from a file with namespace preservation
func LoadUser_sid_objectFromFile(path string) (*User_sid_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid_objectFromBytes(data)
}

// File_testElement represents the XSD element 'file_test'
// XSD element declaration (W3C XSD §3.3)
type File_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows file_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *File_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias File_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *File_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias File_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *File_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *File_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *File_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *File_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *File_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFile_testFromBytes loads an element from bytes with namespace preservation
func LoadFile_testFromBytes(data []byte) (*File_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element File_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFile_testFromFile loads an element from a file with namespace preservation
func LoadFile_testFromFile(path string) (*File_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFile_testFromBytes(data)
}

// Accesstoken_testElement represents the XSD element 'accesstoken_test'
// XSD element declaration (W3C XSD §3.3)
type Accesstoken_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows accesstoken_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Accesstoken_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Accesstoken_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Accesstoken_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Accesstoken_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Accesstoken_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Accesstoken_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Accesstoken_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Accesstoken_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Accesstoken_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAccesstoken_testFromBytes loads an element from bytes with namespace preservation
func LoadAccesstoken_testFromBytes(data []byte) (*Accesstoken_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Accesstoken_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAccesstoken_testFromFile loads an element from a file with namespace preservation
func LoadAccesstoken_testFromFile(path string) (*Accesstoken_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAccesstoken_testFromBytes(data)
}

// Interface_objectElement represents the XSD element 'interface_object'
// XSD element declaration (W3C XSD §3.3)
type Interface_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows interface_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Interface_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Interface_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Interface_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Interface_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Interface_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Interface_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Interface_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Interface_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Interface_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInterface_objectFromBytes loads an element from bytes with namespace preservation
func LoadInterface_objectFromBytes(data []byte) (*Interface_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Interface_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInterface_objectFromFile loads an element from a file with namespace preservation
func LoadInterface_objectFromFile(path string) (*Interface_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInterface_objectFromBytes(data)
}

// Sid_sid_testElement represents the XSD element 'sid_sid_test'
// XSD element declaration (W3C XSD §3.3)
type Sid_sid_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_sid_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_sid_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_sid_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_sid_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_sid_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_sid_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_sid_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_sid_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_sid_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_sid_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_sid_testFromBytes loads an element from bytes with namespace preservation
func LoadSid_sid_testFromBytes(data []byte) (*Sid_sid_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_sid_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_sid_testFromFile loads an element from a file with namespace preservation
func LoadSid_sid_testFromFile(path string) (*Sid_sid_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_sid_testFromBytes(data)
}

// Volume_stateElement represents the XSD element 'volume_state'
// XSD element declaration (W3C XSD §3.3)
type Volume_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows volume_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Rootpath represents XSD element 'rootpath'
	// minOccurs=0, maxOccurs=1
	Rootpath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"rootpath,omitempty"`
	// File_system represents XSD element 'file_system'
	// minOccurs=0, maxOccurs=1
	File_system *xmlschemaoval_definitions_5.EntityStateStringType `xml:"file_system,omitempty"`
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Drive_type represents XSD element 'drive_type'
	// minOccurs=0, maxOccurs=1
	Drive_type *EntityStateDriveTypeType `xml:"drive_type,omitempty"`
	// Volume_max_component_length represents XSD element 'volume_max_component_length'
	// minOccurs=0, maxOccurs=1
	Volume_max_component_length *xmlschemaoval_definitions_5.EntityStateIntType `xml:"volume_max_component_length,omitempty"`
	// Serial_number represents XSD element 'serial_number'
	// minOccurs=0, maxOccurs=1
	Serial_number *xmlschemaoval_definitions_5.EntityStateIntType `xml:"serial_number,omitempty"`
	// File_case_sensitive_search represents XSD element 'file_case_sensitive_search'
	// minOccurs=0, maxOccurs=1
	File_case_sensitive_search *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_case_sensitive_search,omitempty"`
	// File_case_preserved_names represents XSD element 'file_case_preserved_names'
	// minOccurs=0, maxOccurs=1
	File_case_preserved_names *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_case_preserved_names,omitempty"`
	// File_unicode_on_disk represents XSD element 'file_unicode_on_disk'
	// minOccurs=0, maxOccurs=1
	File_unicode_on_disk *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_unicode_on_disk,omitempty"`
	// File_persistent_acls represents XSD element 'file_persistent_acls'
	// minOccurs=0, maxOccurs=1
	File_persistent_acls *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_persistent_acls,omitempty"`
	// File_file_compression represents XSD element 'file_file_compression'
	// minOccurs=0, maxOccurs=1
	File_file_compression *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_file_compression,omitempty"`
	// File_volume_quotas represents XSD element 'file_volume_quotas'
	// minOccurs=0, maxOccurs=1
	File_volume_quotas *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_volume_quotas,omitempty"`
	// File_supports_sparse_files represents XSD element 'file_supports_sparse_files'
	// minOccurs=0, maxOccurs=1
	File_supports_sparse_files *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_sparse_files,omitempty"`
	// File_supports_reparse_points represents XSD element 'file_supports_reparse_points'
	// minOccurs=0, maxOccurs=1
	File_supports_reparse_points *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_reparse_points,omitempty"`
	// File_supports_remote_storage represents XSD element 'file_supports_remote_storage'
	// minOccurs=0, maxOccurs=1
	File_supports_remote_storage *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_remote_storage,omitempty"`
	// File_volume_is_compressed represents XSD element 'file_volume_is_compressed'
	// minOccurs=0, maxOccurs=1
	File_volume_is_compressed *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_volume_is_compressed,omitempty"`
	// File_supports_object_ids represents XSD element 'file_supports_object_ids'
	// minOccurs=0, maxOccurs=1
	File_supports_object_ids *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_object_ids,omitempty"`
	// File_supports_encryption represents XSD element 'file_supports_encryption'
	// minOccurs=0, maxOccurs=1
	File_supports_encryption *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_encryption,omitempty"`
	// File_named_streams represents XSD element 'file_named_streams'
	// minOccurs=0, maxOccurs=1
	File_named_streams *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_named_streams,omitempty"`
	// File_read_only_volume represents XSD element 'file_read_only_volume'
	// minOccurs=0, maxOccurs=1
	File_read_only_volume *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_only_volume,omitempty"`
	// File_sequential_write_once represents XSD element 'file_sequential_write_once'
	// minOccurs=0, maxOccurs=1
	File_sequential_write_once *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_sequential_write_once,omitempty"`
	// File_supports_transactions represents XSD element 'file_supports_transactions'
	// minOccurs=0, maxOccurs=1
	File_supports_transactions *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_transactions,omitempty"`
	// File_supports_hard_links represents XSD element 'file_supports_hard_links'
	// minOccurs=0, maxOccurs=1
	File_supports_hard_links *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_hard_links,omitempty"`
	// File_supports_extended_attributes represents XSD element 'file_supports_extended_attributes'
	// minOccurs=0, maxOccurs=1
	File_supports_extended_attributes *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_extended_attributes,omitempty"`
	// File_supports_open_by_file_id represents XSD element 'file_supports_open_by_file_id'
	// minOccurs=0, maxOccurs=1
	File_supports_open_by_file_id *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_open_by_file_id,omitempty"`
	// File_supports_usn_journal represents XSD element 'file_supports_usn_journal'
	// minOccurs=0, maxOccurs=1
	File_supports_usn_journal *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_supports_usn_journal,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Volume_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Volume_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Volume_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Volume_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Volume_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Volume_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Volume_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Volume_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Volume_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadVolume_stateFromBytes loads an element from bytes with namespace preservation
func LoadVolume_stateFromBytes(data []byte) (*Volume_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Volume_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadVolume_stateFromFile loads an element from a file with namespace preservation
func LoadVolume_stateFromFile(path string) (*Volume_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadVolume_stateFromBytes(data)
}

// Fileeffectiverights53_objectElement represents the XSD element 'fileeffectiverights53_object'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights53_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights53_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *FileEffectiveRights53Behaviors `xml:"behaviors,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// Filepath represents XSD element 'filepath'
	Filepath *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	Path xmlschemaoval_definitions_5.EntityObjectStringType `xml:"path"`
	// Filename represents XSD element 'filename'
	Filename xmlschemaoval_definitions_5.EntityObjectStringType `xml:"filename"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights53_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights53_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights53_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights53_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights53_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights53_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights53_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights53_objectFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights53_objectFromBytes(data []byte) (*Fileeffectiverights53_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights53_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights53_objectFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights53_objectFromFile(path string) (*Fileeffectiverights53_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights53_objectFromBytes(data)
}

// Fileeffectiverights_stateElement represents the XSD element 'fileeffectiverights_state'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// File_read_data represents XSD element 'file_read_data'
	// minOccurs=0, maxOccurs=1
	File_read_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_data,omitempty"`
	// File_write_data represents XSD element 'file_write_data'
	// minOccurs=0, maxOccurs=1
	File_write_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_data,omitempty"`
	// File_append_data represents XSD element 'file_append_data'
	// minOccurs=0, maxOccurs=1
	File_append_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_append_data,omitempty"`
	// File_read_ea represents XSD element 'file_read_ea'
	// minOccurs=0, maxOccurs=1
	File_read_ea *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_ea,omitempty"`
	// File_write_ea represents XSD element 'file_write_ea'
	// minOccurs=0, maxOccurs=1
	File_write_ea *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_ea,omitempty"`
	// File_execute represents XSD element 'file_execute'
	// minOccurs=0, maxOccurs=1
	File_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_execute,omitempty"`
	// File_delete_child represents XSD element 'file_delete_child'
	// minOccurs=0, maxOccurs=1
	File_delete_child *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_delete_child,omitempty"`
	// File_read_attributes represents XSD element 'file_read_attributes'
	// minOccurs=0, maxOccurs=1
	File_read_attributes *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_attributes,omitempty"`
	// File_write_attributes represents XSD element 'file_write_attributes'
	// minOccurs=0, maxOccurs=1
	File_write_attributes *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_attributes,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights_stateFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights_stateFromBytes(data []byte) (*Fileeffectiverights_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights_stateFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights_stateFromFile(path string) (*Fileeffectiverights_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights_stateFromBytes(data)
}

// Systemmetric_stateElement represents the XSD element 'systemmetric_state'
// XSD element declaration (W3C XSD §3.3)
type Systemmetric_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows systemmetric_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Index represents XSD element 'index'
	// minOccurs=0, maxOccurs=1
	Index *EntityStateSystemMetricIndexType `xml:"index,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateIntType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemmetric_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemmetric_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemmetric_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemmetric_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemmetric_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemmetric_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemmetric_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemmetric_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemmetric_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemmetric_stateFromBytes loads an element from bytes with namespace preservation
func LoadSystemmetric_stateFromBytes(data []byte) (*Systemmetric_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemmetric_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemmetric_stateFromFile loads an element from a file with namespace preservation
func LoadSystemmetric_stateFromFile(path string) (*Systemmetric_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemmetric_stateFromBytes(data)
}

// Wmi_objectElement represents the XSD element 'wmi_object'
// XSD element declaration (W3C XSD §3.3)
type Wmi_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Namespace represents XSD element 'namespace'
	Namespace xmlschemaoval_definitions_5.EntityObjectStringType `xml:"namespace"`
	// Wql represents XSD element 'wql'
	Wql xmlschemaoval_definitions_5.EntityObjectStringType `xml:"wql"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi_objectFromBytes loads an element from bytes with namespace preservation
func LoadWmi_objectFromBytes(data []byte) (*Wmi_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi_objectFromFile loads an element from a file with namespace preservation
func LoadWmi_objectFromFile(path string) (*Wmi_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi_objectFromBytes(data)
}

// Passwordpolicy_testElement represents the XSD element 'passwordpolicy_test'
// XSD element declaration (W3C XSD §3.3)
type Passwordpolicy_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows passwordpolicy_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Passwordpolicy_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Passwordpolicy_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Passwordpolicy_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Passwordpolicy_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Passwordpolicy_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Passwordpolicy_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Passwordpolicy_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Passwordpolicy_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Passwordpolicy_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPasswordpolicy_testFromBytes loads an element from bytes with namespace preservation
func LoadPasswordpolicy_testFromBytes(data []byte) (*Passwordpolicy_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Passwordpolicy_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPasswordpolicy_testFromFile loads an element from a file with namespace preservation
func LoadPasswordpolicy_testFromFile(path string) (*Passwordpolicy_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPasswordpolicy_testFromBytes(data)
}

// Passwordpolicy_stateElement represents the XSD element 'passwordpolicy_state'
// XSD element declaration (W3C XSD §3.3)
type Passwordpolicy_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows passwordpolicy_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Max_passwd_age represents XSD element 'max_passwd_age'
	// minOccurs=0, maxOccurs=1
	Max_passwd_age *xmlschemaoval_definitions_5.EntityStateIntType `xml:"max_passwd_age,omitempty"`
	// Min_passwd_age represents XSD element 'min_passwd_age'
	// minOccurs=0, maxOccurs=1
	Min_passwd_age *xmlschemaoval_definitions_5.EntityStateIntType `xml:"min_passwd_age,omitempty"`
	// Min_passwd_len represents XSD element 'min_passwd_len'
	// minOccurs=0, maxOccurs=1
	Min_passwd_len *xmlschemaoval_definitions_5.EntityStateIntType `xml:"min_passwd_len,omitempty"`
	// Password_hist_len represents XSD element 'password_hist_len'
	// minOccurs=0, maxOccurs=1
	Password_hist_len *xmlschemaoval_definitions_5.EntityStateIntType `xml:"password_hist_len,omitempty"`
	// Password_complexity represents XSD element 'password_complexity'
	// minOccurs=0, maxOccurs=1
	Password_complexity *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"password_complexity,omitempty"`
	// Reversible_encryption represents XSD element 'reversible_encryption'
	// minOccurs=0, maxOccurs=1
	Reversible_encryption *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"reversible_encryption,omitempty"`
	// Anonymous_name_lookup represents XSD element 'anonymous_name_lookup'
	// minOccurs=0, maxOccurs=1
	Anonymous_name_lookup *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"anonymous_name_lookup,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Passwordpolicy_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Passwordpolicy_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Passwordpolicy_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Passwordpolicy_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Passwordpolicy_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Passwordpolicy_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Passwordpolicy_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Passwordpolicy_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Passwordpolicy_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPasswordpolicy_stateFromBytes loads an element from bytes with namespace preservation
func LoadPasswordpolicy_stateFromBytes(data []byte) (*Passwordpolicy_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Passwordpolicy_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPasswordpolicy_stateFromFile loads an element from a file with namespace preservation
func LoadPasswordpolicy_stateFromFile(path string) (*Passwordpolicy_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPasswordpolicy_stateFromBytes(data)
}

// Process_objectElement represents the XSD element 'process_object'
// XSD element declaration (W3C XSD §3.3)
type Process_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Command_line represents XSD element 'command_line'
	Command_line *xmlschemaoval_definitions_5.EntityObjectStringType `xml:"command_line,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess_objectFromBytes loads an element from bytes with namespace preservation
func LoadProcess_objectFromBytes(data []byte) (*Process_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess_objectFromFile loads an element from a file with namespace preservation
func LoadProcess_objectFromFile(path string) (*Process_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess_objectFromBytes(data)
}

// Regkeyauditedpermissions53_stateElement represents the XSD element 'regkeyauditedpermissions53_state'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions53_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions53_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Hive represents XSD element 'hive'
	// minOccurs=0, maxOccurs=1
	Hive *EntityStateRegistryHiveType `xml:"hive,omitempty"`
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *EntityStateAuditType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *EntityStateAuditType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *EntityStateAuditType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *EntityStateAuditType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *EntityStateAuditType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *EntityStateAuditType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *EntityStateAuditType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *EntityStateAuditType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *EntityStateAuditType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *EntityStateAuditType `xml:"generic_all,omitempty"`
	// Key_query_value represents XSD element 'key_query_value'
	// minOccurs=0, maxOccurs=1
	Key_query_value *EntityStateAuditType `xml:"key_query_value,omitempty"`
	// Key_set_value represents XSD element 'key_set_value'
	// minOccurs=0, maxOccurs=1
	Key_set_value *EntityStateAuditType `xml:"key_set_value,omitempty"`
	// Key_create_sub_key represents XSD element 'key_create_sub_key'
	// minOccurs=0, maxOccurs=1
	Key_create_sub_key *EntityStateAuditType `xml:"key_create_sub_key,omitempty"`
	// Key_enumerate_sub_keys represents XSD element 'key_enumerate_sub_keys'
	// minOccurs=0, maxOccurs=1
	Key_enumerate_sub_keys *EntityStateAuditType `xml:"key_enumerate_sub_keys,omitempty"`
	// Key_notify represents XSD element 'key_notify'
	// minOccurs=0, maxOccurs=1
	Key_notify *EntityStateAuditType `xml:"key_notify,omitempty"`
	// Key_create_link represents XSD element 'key_create_link'
	// minOccurs=0, maxOccurs=1
	Key_create_link *EntityStateAuditType `xml:"key_create_link,omitempty"`
	// Key_wow64_64key represents XSD element 'key_wow64_64key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_64key *EntityStateAuditType `xml:"key_wow64_64key,omitempty"`
	// Key_wow64_32key represents XSD element 'key_wow64_32key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_32key *EntityStateAuditType `xml:"key_wow64_32key,omitempty"`
	// Key_wow64_res represents XSD element 'key_wow64_res'
	// minOccurs=0, maxOccurs=1
	Key_wow64_res *EntityStateAuditType `xml:"key_wow64_res,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions53_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions53_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions53_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions53_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions53_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions53_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions53_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions53_stateFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions53_stateFromBytes(data []byte) (*Regkeyauditedpermissions53_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions53_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions53_stateFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions53_stateFromFile(path string) (*Regkeyauditedpermissions53_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions53_stateFromBytes(data)
}

// File_stateElement represents the XSD element 'file_state'
// XSD element declaration (W3C XSD §3.3)
type File_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows file_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Owner represents XSD element 'owner'
	// minOccurs=0, maxOccurs=1
	Owner *xmlschemaoval_definitions_5.EntityStateStringType `xml:"owner,omitempty"`
	// Size represents XSD element 'size'
	// minOccurs=0, maxOccurs=1
	Size *xmlschemaoval_definitions_5.EntityStateIntType `xml:"size,omitempty"`
	// A_time represents XSD element 'a_time'
	// minOccurs=0, maxOccurs=1
	A_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"a_time,omitempty"`
	// C_time represents XSD element 'c_time'
	// minOccurs=0, maxOccurs=1
	C_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"c_time,omitempty"`
	// M_time represents XSD element 'm_time'
	// minOccurs=0, maxOccurs=1
	M_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"m_time,omitempty"`
	// Ms_checksum represents XSD element 'ms_checksum'
	// minOccurs=0, maxOccurs=1
	Ms_checksum *xmlschemaoval_definitions_5.EntityStateStringType `xml:"ms_checksum,omitempty"`
	// Version represents XSD element 'version'
	// minOccurs=0, maxOccurs=1
	Version *xmlschemaoval_definitions_5.EntityStateVersionType `xml:"version,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *EntityStateFileTypeType `xml:"type,omitempty"`
	// Attribute represents XSD element 'attribute'
	// minOccurs=0, maxOccurs=1
	Attribute *EntityStateFileAttributeType `xml:"attribute,omitempty"`
	// Development_class represents XSD element 'development_class'
	// minOccurs=0, maxOccurs=1
	Development_class *xmlschemaoval_definitions_5.EntityStateStringType `xml:"development_class,omitempty"`
	// Company represents XSD element 'company'
	// minOccurs=0, maxOccurs=1
	Company *xmlschemaoval_definitions_5.EntityStateStringType `xml:"company,omitempty"`
	// Internal_name represents XSD element 'internal_name'
	// minOccurs=0, maxOccurs=1
	Internal_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"internal_name,omitempty"`
	// Language represents XSD element 'language'
	// minOccurs=0, maxOccurs=1
	Language *xmlschemaoval_definitions_5.EntityStateStringType `xml:"language,omitempty"`
	// Original_filename represents XSD element 'original_filename'
	// minOccurs=0, maxOccurs=1
	Original_filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"original_filename,omitempty"`
	// Product_name represents XSD element 'product_name'
	// minOccurs=0, maxOccurs=1
	Product_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"product_name,omitempty"`
	// Product_version represents XSD element 'product_version'
	// minOccurs=0, maxOccurs=1
	Product_version *Product_versionElementType `xml:"product_version,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *File_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias File_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *File_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias File_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *File_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *File_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *File_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *File_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *File_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFile_stateFromBytes loads an element from bytes with namespace preservation
func LoadFile_stateFromBytes(data []byte) (*File_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element File_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFile_stateFromFile loads an element from a file with namespace preservation
func LoadFile_stateFromFile(path string) (*File_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFile_stateFromBytes(data)
}

// Activedirectory57_stateElement represents the XSD element 'activedirectory57_state'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory57_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory57_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Naming_context represents XSD element 'naming_context'
	// minOccurs=0, maxOccurs=1
	Naming_context *EntityStateNamingContextType `xml:"naming_context,omitempty"`
	// Relative_dn represents XSD element 'relative_dn'
	// minOccurs=0, maxOccurs=1
	Relative_dn *xmlschemaoval_definitions_5.EntityStateStringType `xml:"relative_dn,omitempty"`
	// Attribute represents XSD element 'attribute'
	// minOccurs=0, maxOccurs=1
	Attribute *xmlschemaoval_definitions_5.EntityStateStringType `xml:"attribute,omitempty"`
	// Object_class represents XSD element 'object_class'
	// minOccurs=0, maxOccurs=1
	Object_class *xmlschemaoval_definitions_5.EntityStateStringType `xml:"object_class,omitempty"`
	// Adstype represents XSD element 'adstype'
	// minOccurs=0, maxOccurs=1
	Adstype *EntityStateAdstypeType `xml:"adstype,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateRecordType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory57_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory57_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory57_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory57_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory57_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory57_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory57_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory57_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory57_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory57_stateFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory57_stateFromBytes(data []byte) (*Activedirectory57_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory57_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory57_stateFromFile loads an element from a file with namespace preservation
func LoadActivedirectory57_stateFromFile(path string) (*Activedirectory57_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory57_stateFromBytes(data)
}

// Interface_stateElement represents the XSD element 'interface_state'
// XSD element declaration (W3C XSD §3.3)
type Interface_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows interface_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// Index represents XSD element 'index'
	// minOccurs=0, maxOccurs=1
	Index *xmlschemaoval_definitions_5.EntityStateIntType `xml:"index,omitempty"`
	// Type represents XSD element 'type'
	// minOccurs=0, maxOccurs=1
	Type *EntityStateInterfaceTypeType `xml:"type,omitempty"`
	// Hardware_addr represents XSD element 'hardware_addr'
	// minOccurs=0, maxOccurs=1
	Hardware_addr *xmlschemaoval_definitions_5.EntityStateStringType `xml:"hardware_addr,omitempty"`
	// Inet_addr represents XSD element 'inet_addr'
	// minOccurs=0, maxOccurs=1
	Inet_addr *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"inet_addr,omitempty"`
	// Broadcast_addr represents XSD element 'broadcast_addr'
	// minOccurs=0, maxOccurs=1
	Broadcast_addr *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"broadcast_addr,omitempty"`
	// Netmask represents XSD element 'netmask'
	// minOccurs=0, maxOccurs=1
	Netmask *xmlschemaoval_definitions_5.EntityStateIPAddressStringType `xml:"netmask,omitempty"`
	// Addr_type represents XSD element 'addr_type'
	// minOccurs=0, maxOccurs=1
	Addr_type *EntityStateAddrTypeType `xml:"addr_type,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Interface_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Interface_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Interface_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Interface_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Interface_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Interface_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Interface_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Interface_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Interface_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadInterface_stateFromBytes loads an element from bytes with namespace preservation
func LoadInterface_stateFromBytes(data []byte) (*Interface_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Interface_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadInterface_stateFromFile loads an element from a file with namespace preservation
func LoadInterface_stateFromFile(path string) (*Interface_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadInterface_stateFromBytes(data)
}

// Peheader_testElement represents the XSD element 'peheader_test'
// XSD element declaration (W3C XSD §3.3)
type Peheader_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows peheader_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Peheader_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Peheader_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Peheader_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Peheader_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Peheader_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Peheader_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Peheader_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Peheader_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Peheader_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPeheader_testFromBytes loads an element from bytes with namespace preservation
func LoadPeheader_testFromBytes(data []byte) (*Peheader_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Peheader_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPeheader_testFromFile loads an element from a file with namespace preservation
func LoadPeheader_testFromFile(path string) (*Peheader_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPeheader_testFromBytes(data)
}

// Systemmetric_objectElement represents the XSD element 'systemmetric_object'
// XSD element declaration (W3C XSD §3.3)
type Systemmetric_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows systemmetric_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Index represents XSD element 'index'
	Index EntityObjectSystemMetricIndexType `xml:"index"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Systemmetric_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Systemmetric_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Systemmetric_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Systemmetric_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Systemmetric_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Systemmetric_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Systemmetric_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Systemmetric_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Systemmetric_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSystemmetric_objectFromBytes loads an element from bytes with namespace preservation
func LoadSystemmetric_objectFromBytes(data []byte) (*Systemmetric_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Systemmetric_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSystemmetric_objectFromFile loads an element from a file with namespace preservation
func LoadSystemmetric_objectFromFile(path string) (*Systemmetric_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSystemmetric_objectFromBytes(data)
}

// Userright_objectElement represents the XSD element 'userright_object'
// XSD element declaration (W3C XSD §3.3)
type Userright_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows userright_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Userright represents XSD element 'userright'
	Userright EntityObjectUserRightType `xml:"userright"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Userright_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Userright_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Userright_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Userright_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Userright_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Userright_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Userright_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Userright_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Userright_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUserright_objectFromBytes loads an element from bytes with namespace preservation
func LoadUserright_objectFromBytes(data []byte) (*Userright_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Userright_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUserright_objectFromFile loads an element from a file with namespace preservation
func LoadUserright_objectFromFile(path string) (*Userright_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUserright_objectFromBytes(data)
}

// Wmi57_testElement represents the XSD element 'wmi57_test'
// XSD element declaration (W3C XSD §3.3)
type Wmi57_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows wmi57_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Wmi57_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Wmi57_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Wmi57_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Wmi57_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Wmi57_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Wmi57_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Wmi57_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Wmi57_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Wmi57_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadWmi57_testFromBytes loads an element from bytes with namespace preservation
func LoadWmi57_testFromBytes(data []byte) (*Wmi57_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Wmi57_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadWmi57_testFromFile loads an element from a file with namespace preservation
func LoadWmi57_testFromFile(path string) (*Wmi57_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadWmi57_testFromBytes(data)
}

// Activedirectory_testElement represents the XSD element 'activedirectory_test'
// XSD element declaration (W3C XSD §3.3)
type Activedirectory_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows activedirectory_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Activedirectory_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Activedirectory_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Activedirectory_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Activedirectory_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Activedirectory_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Activedirectory_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Activedirectory_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Activedirectory_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Activedirectory_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadActivedirectory_testFromBytes loads an element from bytes with namespace preservation
func LoadActivedirectory_testFromBytes(data []byte) (*Activedirectory_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Activedirectory_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadActivedirectory_testFromFile loads an element from a file with namespace preservation
func LoadActivedirectory_testFromFile(path string) (*Activedirectory_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadActivedirectory_testFromBytes(data)
}

// Fileauditedpermissions53_stateElement represents the XSD element 'fileauditedpermissions53_state'
// XSD element declaration (W3C XSD §3.3)
type Fileauditedpermissions53_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileauditedpermissions53_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *EntityStateAuditType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *EntityStateAuditType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *EntityStateAuditType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *EntityStateAuditType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *EntityStateAuditType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *EntityStateAuditType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *EntityStateAuditType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *EntityStateAuditType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *EntityStateAuditType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *EntityStateAuditType `xml:"generic_all,omitempty"`
	// File_read_data represents XSD element 'file_read_data'
	// minOccurs=0, maxOccurs=1
	File_read_data *EntityStateAuditType `xml:"file_read_data,omitempty"`
	// File_write_data represents XSD element 'file_write_data'
	// minOccurs=0, maxOccurs=1
	File_write_data *EntityStateAuditType `xml:"file_write_data,omitempty"`
	// File_append_data represents XSD element 'file_append_data'
	// minOccurs=0, maxOccurs=1
	File_append_data *EntityStateAuditType `xml:"file_append_data,omitempty"`
	// File_read_ea represents XSD element 'file_read_ea'
	// minOccurs=0, maxOccurs=1
	File_read_ea *EntityStateAuditType `xml:"file_read_ea,omitempty"`
	// File_write_ea represents XSD element 'file_write_ea'
	// minOccurs=0, maxOccurs=1
	File_write_ea *EntityStateAuditType `xml:"file_write_ea,omitempty"`
	// File_execute represents XSD element 'file_execute'
	// minOccurs=0, maxOccurs=1
	File_execute *EntityStateAuditType `xml:"file_execute,omitempty"`
	// File_delete_child represents XSD element 'file_delete_child'
	// minOccurs=0, maxOccurs=1
	File_delete_child *EntityStateAuditType `xml:"file_delete_child,omitempty"`
	// File_read_attributes represents XSD element 'file_read_attributes'
	// minOccurs=0, maxOccurs=1
	File_read_attributes *EntityStateAuditType `xml:"file_read_attributes,omitempty"`
	// File_write_attributes represents XSD element 'file_write_attributes'
	// minOccurs=0, maxOccurs=1
	File_write_attributes *EntityStateAuditType `xml:"file_write_attributes,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileauditedpermissions53_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileauditedpermissions53_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileauditedpermissions53_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileauditedpermissions53_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileauditedpermissions53_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileauditedpermissions53_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileauditedpermissions53_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileauditedpermissions53_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileauditedpermissions53_stateFromBytes loads an element from bytes with namespace preservation
func LoadFileauditedpermissions53_stateFromBytes(data []byte) (*Fileauditedpermissions53_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileauditedpermissions53_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileauditedpermissions53_stateFromFile loads an element from a file with namespace preservation
func LoadFileauditedpermissions53_stateFromFile(path string) (*Fileauditedpermissions53_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileauditedpermissions53_stateFromBytes(data)
}

// Group_sid_stateElement represents the XSD element 'group_sid_state'
// XSD element declaration (W3C XSD §3.3)
type Group_sid_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_sid_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Group_sid represents XSD element 'group_sid'
	// minOccurs=0, maxOccurs=1
	Group_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"group_sid,omitempty"`
	// User_sid represents XSD element 'user_sid'
	// minOccurs=0, maxOccurs=1
	User_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user_sid,omitempty"`
	// Subgroup_sid represents XSD element 'subgroup_sid'
	// minOccurs=0, maxOccurs=1
	Subgroup_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"subgroup_sid,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_sid_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_sid_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_sid_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_sid_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_sid_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_sid_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_sid_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_sid_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_sid_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_sid_stateFromBytes loads an element from bytes with namespace preservation
func LoadGroup_sid_stateFromBytes(data []byte) (*Group_sid_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_sid_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_sid_stateFromFile loads an element from a file with namespace preservation
func LoadGroup_sid_stateFromFile(path string) (*Group_sid_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_sid_stateFromBytes(data)
}

// Port_objectElement represents the XSD element 'port_object'
// XSD element declaration (W3C XSD §3.3)
type Port_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows port_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Local_address represents XSD element 'local_address'
	Local_address xmlschemaoval_definitions_5.EntityObjectIPAddressStringType `xml:"local_address"`
	// Local_port represents XSD element 'local_port'
	Local_port xmlschemaoval_definitions_5.EntityObjectIntType `xml:"local_port"`
	// Protocol represents XSD element 'protocol'
	Protocol EntityObjectProtocolType `xml:"protocol"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Port_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Port_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Port_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Port_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Port_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Port_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Port_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Port_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Port_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadPort_objectFromBytes loads an element from bytes with namespace preservation
func LoadPort_objectFromBytes(data []byte) (*Port_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Port_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadPort_objectFromFile loads an element from a file with namespace preservation
func LoadPort_objectFromFile(path string) (*Port_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadPort_objectFromBytes(data)
}

// Regkeyauditedpermissions53_objectElement represents the XSD element 'regkeyauditedpermissions53_object'
// XSD element declaration (W3C XSD §3.3)
type Regkeyauditedpermissions53_objectElement struct {
	XMLName                                xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyauditedpermissions53_object"`
	xmlschemaoval_definitions_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RegkeyAuditPermissions53Behaviors `xml:"behaviors,omitempty"`
	// Hive represents XSD element 'hive'
	Hive EntityObjectRegistryHiveType `xml:"hive"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyauditedpermissions53_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyauditedpermissions53_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyauditedpermissions53_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyauditedpermissions53_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyauditedpermissions53_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyauditedpermissions53_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyauditedpermissions53_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyauditedpermissions53_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyauditedpermissions53_objectFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyauditedpermissions53_objectFromBytes(data []byte) (*Regkeyauditedpermissions53_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyauditedpermissions53_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyauditedpermissions53_objectFromFile loads an element from a file with namespace preservation
func LoadRegkeyauditedpermissions53_objectFromFile(path string) (*Regkeyauditedpermissions53_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyauditedpermissions53_objectFromBytes(data)
}

// Serviceeffectiverights_testElement represents the XSD element 'serviceeffectiverights_test'
// XSD element declaration (W3C XSD §3.3)
type Serviceeffectiverights_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows serviceeffectiverights_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Serviceeffectiverights_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Serviceeffectiverights_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Serviceeffectiverights_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Serviceeffectiverights_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Serviceeffectiverights_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Serviceeffectiverights_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Serviceeffectiverights_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Serviceeffectiverights_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadServiceeffectiverights_testFromBytes loads an element from bytes with namespace preservation
func LoadServiceeffectiverights_testFromBytes(data []byte) (*Serviceeffectiverights_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Serviceeffectiverights_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadServiceeffectiverights_testFromFile loads an element from a file with namespace preservation
func LoadServiceeffectiverights_testFromFile(path string) (*Serviceeffectiverights_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadServiceeffectiverights_testFromBytes(data)
}

// Sid_sid_stateElement represents the XSD element 'sid_sid_state'
// XSD element declaration (W3C XSD §3.3)
type Sid_sid_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sid_sid_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Trustee_domain represents XSD element 'trustee_domain'
	// minOccurs=0, maxOccurs=1
	Trustee_domain *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_domain,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sid_sid_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sid_sid_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sid_sid_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sid_sid_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sid_sid_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sid_sid_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sid_sid_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sid_sid_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sid_sid_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSid_sid_stateFromBytes loads an element from bytes with namespace preservation
func LoadSid_sid_stateFromBytes(data []byte) (*Sid_sid_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sid_sid_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSid_sid_stateFromFile loads an element from a file with namespace preservation
func LoadSid_sid_stateFromFile(path string) (*Sid_sid_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSid_sid_stateFromBytes(data)
}

// User_sid55_stateElement represents the XSD element 'user_sid55_state'
// XSD element declaration (W3C XSD §3.3)
type User_sid55_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid55_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// User_sid represents XSD element 'user_sid'
	// minOccurs=0, maxOccurs=1
	User_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"user_sid,omitempty"`
	// Enabled represents XSD element 'enabled'
	// minOccurs=0, maxOccurs=1
	Enabled *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"enabled,omitempty"`
	// Group_sid represents XSD element 'group_sid'
	// minOccurs=0, maxOccurs=1
	Group_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"group_sid,omitempty"`
	// Last_logon represents XSD element 'last_logon'
	// minOccurs=0, maxOccurs=1
	Last_logon *xmlschemaoval_definitions_5.EntityStateIntType `xml:"last_logon,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid55_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid55_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid55_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid55_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid55_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid55_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid55_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid55_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid55_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid55_stateFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid55_stateFromBytes(data []byte) (*User_sid55_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid55_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid55_stateFromFile loads an element from a file with namespace preservation
func LoadUser_sid55_stateFromFile(path string) (*User_sid55_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid55_stateFromBytes(data)
}

// Auditeventpolicy_testElement represents the XSD element 'auditeventpolicy_test'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicy_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicy_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicy_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicy_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicy_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicy_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicy_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicy_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicy_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicy_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicy_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicy_testFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicy_testFromBytes(data []byte) (*Auditeventpolicy_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicy_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicy_testFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicy_testFromFile(path string) (*Auditeventpolicy_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicy_testFromBytes(data)
}

// Fileeffectiverights53_stateElement represents the XSD element 'fileeffectiverights53_state'
// XSD element declaration (W3C XSD §3.3)
type Fileeffectiverights53_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows fileeffectiverights53_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Filepath represents XSD element 'filepath'
	// minOccurs=0, maxOccurs=1
	Filepath *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filepath,omitempty"`
	// Path represents XSD element 'path'
	// minOccurs=0, maxOccurs=1
	Path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"path,omitempty"`
	// Filename represents XSD element 'filename'
	// minOccurs=0, maxOccurs=1
	Filename *xmlschemaoval_definitions_5.EntityStateStringType `xml:"filename,omitempty"`
	// Trustee_sid represents XSD element 'trustee_sid'
	// minOccurs=0, maxOccurs=1
	Trustee_sid *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_sid,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// File_read_data represents XSD element 'file_read_data'
	// minOccurs=0, maxOccurs=1
	File_read_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_data,omitempty"`
	// File_write_data represents XSD element 'file_write_data'
	// minOccurs=0, maxOccurs=1
	File_write_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_data,omitempty"`
	// File_append_data represents XSD element 'file_append_data'
	// minOccurs=0, maxOccurs=1
	File_append_data *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_append_data,omitempty"`
	// File_read_ea represents XSD element 'file_read_ea'
	// minOccurs=0, maxOccurs=1
	File_read_ea *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_ea,omitempty"`
	// File_write_ea represents XSD element 'file_write_ea'
	// minOccurs=0, maxOccurs=1
	File_write_ea *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_ea,omitempty"`
	// File_execute represents XSD element 'file_execute'
	// minOccurs=0, maxOccurs=1
	File_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_execute,omitempty"`
	// File_delete_child represents XSD element 'file_delete_child'
	// minOccurs=0, maxOccurs=1
	File_delete_child *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_delete_child,omitempty"`
	// File_read_attributes represents XSD element 'file_read_attributes'
	// minOccurs=0, maxOccurs=1
	File_read_attributes *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_read_attributes,omitempty"`
	// File_write_attributes represents XSD element 'file_write_attributes'
	// minOccurs=0, maxOccurs=1
	File_write_attributes *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"file_write_attributes,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Fileeffectiverights53_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Fileeffectiverights53_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Fileeffectiverights53_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Fileeffectiverights53_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Fileeffectiverights53_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Fileeffectiverights53_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Fileeffectiverights53_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Fileeffectiverights53_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadFileeffectiverights53_stateFromBytes loads an element from bytes with namespace preservation
func LoadFileeffectiverights53_stateFromBytes(data []byte) (*Fileeffectiverights53_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Fileeffectiverights53_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadFileeffectiverights53_stateFromFile loads an element from a file with namespace preservation
func LoadFileeffectiverights53_stateFromFile(path string) (*Fileeffectiverights53_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadFileeffectiverights53_stateFromBytes(data)
}

// Junction_testElement represents the XSD element 'junction_test'
// XSD element declaration (W3C XSD §3.3)
type Junction_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows junction_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Junction_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Junction_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Junction_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Junction_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Junction_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Junction_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Junction_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Junction_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Junction_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadJunction_testFromBytes loads an element from bytes with namespace preservation
func LoadJunction_testFromBytes(data []byte) (*Junction_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Junction_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadJunction_testFromFile loads an element from a file with namespace preservation
func LoadJunction_testFromFile(path string) (*Junction_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadJunction_testFromBytes(data)
}

// User_sid55_objectElement represents the XSD element 'user_sid55_object'
// XSD element declaration (W3C XSD §3.3)
type User_sid55_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows user_sid55_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// User_sid represents XSD element 'user_sid'
	User_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"user_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *User_sid55_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias User_sid55_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *User_sid55_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias User_sid55_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *User_sid55_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *User_sid55_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *User_sid55_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *User_sid55_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *User_sid55_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadUser_sid55_objectFromBytes loads an element from bytes with namespace preservation
func LoadUser_sid55_objectFromBytes(data []byte) (*User_sid55_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element User_sid55_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadUser_sid55_objectFromFile loads an element from a file with namespace preservation
func LoadUser_sid55_objectFromFile(path string) (*User_sid55_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadUser_sid55_objectFromBytes(data)
}

// Auditeventpolicysubcategories_objectElement represents the XSD element 'auditeventpolicysubcategories_object'
// XSD element declaration (W3C XSD §3.3)
type Auditeventpolicysubcategories_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows auditeventpolicysubcategories_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Auditeventpolicysubcategories_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Auditeventpolicysubcategories_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Auditeventpolicysubcategories_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Auditeventpolicysubcategories_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Auditeventpolicysubcategories_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Auditeventpolicysubcategories_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Auditeventpolicysubcategories_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Auditeventpolicysubcategories_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadAuditeventpolicysubcategories_objectFromBytes loads an element from bytes with namespace preservation
func LoadAuditeventpolicysubcategories_objectFromBytes(data []byte) (*Auditeventpolicysubcategories_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Auditeventpolicysubcategories_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadAuditeventpolicysubcategories_objectFromFile loads an element from a file with namespace preservation
func LoadAuditeventpolicysubcategories_objectFromFile(path string) (*Auditeventpolicysubcategories_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadAuditeventpolicysubcategories_objectFromBytes(data)
}

// Group_sid_objectElement represents the XSD element 'group_sid_object'
// XSD element declaration (W3C XSD §3.3)
type Group_sid_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows group_sid_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Group_sid represents XSD element 'group_sid'
	Group_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"group_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Group_sid_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Group_sid_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Group_sid_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Group_sid_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Group_sid_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Group_sid_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Group_sid_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Group_sid_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Group_sid_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadGroup_sid_objectFromBytes loads an element from bytes with namespace preservation
func LoadGroup_sid_objectFromBytes(data []byte) (*Group_sid_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Group_sid_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadGroup_sid_objectFromFile loads an element from a file with namespace preservation
func LoadGroup_sid_objectFromFile(path string) (*Group_sid_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadGroup_sid_objectFromBytes(data)
}

// Sharedresource_testElement represents the XSD element 'sharedresource_test'
// XSD element declaration (W3C XSD §3.3)
type Sharedresource_testElement struct {
	XMLName                              xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresource_test"`
	xmlschemaoval_definitions_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresource_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresource_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresource_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresource_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresource_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresource_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresource_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresource_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresource_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresource_testFromBytes loads an element from bytes with namespace preservation
func LoadSharedresource_testFromBytes(data []byte) (*Sharedresource_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresource_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresource_testFromFile loads an element from a file with namespace preservation
func LoadSharedresource_testFromFile(path string) (*Sharedresource_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresource_testFromBytes(data)
}

// Sharedresourceauditedpermissions_objectElement represents the XSD element 'sharedresourceauditedpermissions_object'
// XSD element declaration (W3C XSD §3.3)
type Sharedresourceauditedpermissions_objectElement struct {
	XMLName                      xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows sharedresourceauditedpermissions_object"`
	pkg_200009xmldsig.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *SharedResourceAuditedPermissionsBehaviors `xml:"behaviors,omitempty"`
	// Netname represents XSD element 'netname'
	Netname xmlschemaoval_definitions_5.EntityObjectStringType `xml:"netname"`
	// Trustee_sid represents XSD element 'trustee_sid'
	Trustee_sid xmlschemaoval_definitions_5.EntityObjectStringType `xml:"trustee_sid"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Sharedresourceauditedpermissions_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Sharedresourceauditedpermissions_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Sharedresourceauditedpermissions_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Sharedresourceauditedpermissions_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Sharedresourceauditedpermissions_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Sharedresourceauditedpermissions_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Sharedresourceauditedpermissions_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadSharedresourceauditedpermissions_objectFromBytes loads an element from bytes with namespace preservation
func LoadSharedresourceauditedpermissions_objectFromBytes(data []byte) (*Sharedresourceauditedpermissions_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Sharedresourceauditedpermissions_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadSharedresourceauditedpermissions_objectFromFile loads an element from a file with namespace preservation
func LoadSharedresourceauditedpermissions_objectFromFile(path string) (*Sharedresourceauditedpermissions_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadSharedresourceauditedpermissions_objectFromBytes(data)
}

// Metabase_objectElement represents the XSD element 'metabase_object'
// XSD element declaration (W3C XSD §3.3)
type Metabase_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows metabase_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Id represents XSD element 'id'
	Id xmlschemaoval_definitions_5.EntityObjectIntType `xml:"id"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Metabase_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Metabase_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Metabase_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Metabase_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Metabase_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Metabase_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Metabase_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Metabase_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Metabase_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadMetabase_objectFromBytes loads an element from bytes with namespace preservation
func LoadMetabase_objectFromBytes(data []byte) (*Metabase_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Metabase_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadMetabase_objectFromFile loads an element from a file with namespace preservation
func LoadMetabase_objectFromFile(path string) (*Metabase_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadMetabase_objectFromBytes(data)
}

// Process58_stateElement represents the XSD element 'process58_state'
// XSD element declaration (W3C XSD §3.3)
type Process58_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows process58_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Command_line represents XSD element 'command_line'
	// minOccurs=0, maxOccurs=1
	Command_line *xmlschemaoval_definitions_5.EntityStateStringType `xml:"command_line,omitempty"`
	// Pid represents XSD element 'pid'
	// minOccurs=0, maxOccurs=1
	Pid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"pid,omitempty"`
	// Ppid represents XSD element 'ppid'
	// minOccurs=0, maxOccurs=1
	Ppid *xmlschemaoval_definitions_5.EntityStateIntType `xml:"ppid,omitempty"`
	// Priority represents XSD element 'priority'
	// minOccurs=0, maxOccurs=1
	Priority *PriorityElementType1 `xml:"priority,omitempty"`
	// Image_path represents XSD element 'image_path'
	// minOccurs=0, maxOccurs=1
	Image_path *xmlschemaoval_definitions_5.EntityStateStringType `xml:"image_path,omitempty"`
	// Current_dir represents XSD element 'current_dir'
	// minOccurs=0, maxOccurs=1
	Current_dir *xmlschemaoval_definitions_5.EntityStateStringType `xml:"current_dir,omitempty"`
	// Creation_time represents XSD element 'creation_time'
	// minOccurs=0, maxOccurs=1
	Creation_time *xmlschemaoval_definitions_5.EntityStateIntType `xml:"creation_time,omitempty"`
	// Dep_enabled represents XSD element 'dep_enabled'
	// minOccurs=0, maxOccurs=1
	Dep_enabled *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"dep_enabled,omitempty"`
	// Primary_window_text represents XSD element 'primary_window_text'
	// minOccurs=0, maxOccurs=1
	Primary_window_text *xmlschemaoval_definitions_5.EntityStateStringType `xml:"primary_window_text,omitempty"`
	// Name represents XSD element 'name'
	// minOccurs=0, maxOccurs=1
	Name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"name,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Process58_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Process58_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Process58_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Process58_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Process58_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Process58_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Process58_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Process58_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Process58_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadProcess58_stateFromBytes loads an element from bytes with namespace preservation
func LoadProcess58_stateFromBytes(data []byte) (*Process58_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Process58_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadProcess58_stateFromFile loads an element from a file with namespace preservation
func LoadProcess58_stateFromFile(path string) (*Process58_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadProcess58_stateFromBytes(data)
}

// Registry_objectElement represents the XSD element 'registry_object'
// XSD element declaration (W3C XSD §3.3)
type Registry_objectElement struct {
	XMLName                                           xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows registry_object"`
	xmlschemaoval_system_characteristics_5.ObjectType          // XSD extension base
	// Set represents XSD element 'set'
	Set *xmlschemaoval_definitions_5.SetElement `xml:"set,omitempty"`
	// Behaviors represents XSD element 'behaviors'
	// minOccurs=0, maxOccurs=1
	Behaviors *RegistryBehaviors `xml:"behaviors,omitempty"`
	// Hive represents XSD element 'hive'
	Hive EntityObjectRegistryHiveType `xml:"hive"`
	// Key represents XSD element 'key'
	Key xmlschemaoval_definitions_5.EntityObjectStringType `xml:"key"`
	// Name represents XSD element 'name'
	Name xmlschemaoval_definitions_5.EntityObjectStringType `xml:"name"`
	// Filter represents XSD element 'filter'
	// minOccurs=0, maxOccurs=-1
	Filter []xmlschemaoval_definitions_5.FilterElement `xml:"filter,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Registry_objectElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Registry_objectElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Registry_objectElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Registry_objectElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Registry_objectElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Registry_objectElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Registry_objectElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Registry_objectElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Registry_objectElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegistry_objectFromBytes loads an element from bytes with namespace preservation
func LoadRegistry_objectFromBytes(data []byte) (*Registry_objectElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Registry_objectElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegistry_objectFromFile loads an element from a file with namespace preservation
func LoadRegistry_objectFromFile(path string) (*Registry_objectElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegistry_objectFromBytes(data)
}

// Cmdlet_testElement represents the XSD element 'cmdlet_test'
// XSD element declaration (W3C XSD §3.3)
type Cmdlet_testElement struct {
	XMLName                          xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows cmdlet_test"`
	xmlschemaoval_results_5.TestType          // XSD extension base
	// Object represents XSD element 'object'
	Object xmlschemaoval_definitions_5.ObjectRefType `xml:"object"`
	// State represents XSD element 'state'
	// minOccurs=0, maxOccurs=-1
	State []xmlschemaoval_definitions_5.StateRefType `xml:"state,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Cmdlet_testElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Cmdlet_testElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Cmdlet_testElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Cmdlet_testElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Cmdlet_testElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Cmdlet_testElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Cmdlet_testElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Cmdlet_testElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Cmdlet_testElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadCmdlet_testFromBytes loads an element from bytes with namespace preservation
func LoadCmdlet_testFromBytes(data []byte) (*Cmdlet_testElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Cmdlet_testElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadCmdlet_testFromFile loads an element from a file with namespace preservation
func LoadCmdlet_testFromFile(path string) (*Cmdlet_testElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadCmdlet_testFromBytes(data)
}

// Cmdlet_stateElement represents the XSD element 'cmdlet_state'
// XSD element declaration (W3C XSD §3.3)
type Cmdlet_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows cmdlet_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Module_name represents XSD element 'module_name'
	// minOccurs=0, maxOccurs=1
	Module_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"module_name,omitempty"`
	// Module_id represents XSD element 'module_id'
	// minOccurs=0, maxOccurs=1
	Module_id *EntityStateGUIDType `xml:"module_id,omitempty"`
	// Module_version represents XSD element 'module_version'
	// minOccurs=0, maxOccurs=1
	Module_version *xmlschemaoval_definitions_5.EntityStateVersionType `xml:"module_version,omitempty"`
	// Verb represents XSD element 'verb'
	// minOccurs=0, maxOccurs=1
	Verb *EntityStateCmdletVerbType `xml:"verb,omitempty"`
	// Noun represents XSD element 'noun'
	// minOccurs=0, maxOccurs=1
	Noun *xmlschemaoval_definitions_5.EntityStateStringType `xml:"noun,omitempty"`
	// Parameters represents XSD element 'parameters'
	// minOccurs=0, maxOccurs=1
	Parameters *xmlschemaoval_definitions_5.EntityStateRecordType `xml:"parameters,omitempty"`
	// Select represents XSD element 'select'
	// minOccurs=0, maxOccurs=1
	Select *xmlschemaoval_definitions_5.EntityStateRecordType `xml:"select,omitempty"`
	// Value represents XSD element 'value'
	// minOccurs=0, maxOccurs=1
	Value *xmlschemaoval_definitions_5.EntityStateRecordType `xml:"value,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Cmdlet_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Cmdlet_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Cmdlet_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Cmdlet_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Cmdlet_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Cmdlet_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Cmdlet_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Cmdlet_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Cmdlet_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadCmdlet_stateFromBytes loads an element from bytes with namespace preservation
func LoadCmdlet_stateFromBytes(data []byte) (*Cmdlet_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Cmdlet_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadCmdlet_stateFromFile loads an element from a file with namespace preservation
func LoadCmdlet_stateFromFile(path string) (*Cmdlet_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadCmdlet_stateFromBytes(data)
}

// Regkeyeffectiverights_stateElement represents the XSD element 'regkeyeffectiverights_state'
// XSD element declaration (W3C XSD §3.3)
type Regkeyeffectiverights_stateElement struct {
	XMLName                               xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-definitions-5#windows regkeyeffectiverights_state"`
	xmlschemaoval_definitions_5.StateType          // XSD extension base
	// Hive represents XSD element 'hive'
	// minOccurs=0, maxOccurs=1
	Hive *EntityStateRegistryHiveType `xml:"hive,omitempty"`
	// Key represents XSD element 'key'
	// minOccurs=0, maxOccurs=1
	Key *xmlschemaoval_definitions_5.EntityStateStringType `xml:"key,omitempty"`
	// Trustee_name represents XSD element 'trustee_name'
	// minOccurs=0, maxOccurs=1
	Trustee_name *xmlschemaoval_definitions_5.EntityStateStringType `xml:"trustee_name,omitempty"`
	// Standard_delete represents XSD element 'standard_delete'
	// minOccurs=0, maxOccurs=1
	Standard_delete *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_delete,omitempty"`
	// Standard_read_control represents XSD element 'standard_read_control'
	// minOccurs=0, maxOccurs=1
	Standard_read_control *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_read_control,omitempty"`
	// Standard_write_dac represents XSD element 'standard_write_dac'
	// minOccurs=0, maxOccurs=1
	Standard_write_dac *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_dac,omitempty"`
	// Standard_write_owner represents XSD element 'standard_write_owner'
	// minOccurs=0, maxOccurs=1
	Standard_write_owner *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_write_owner,omitempty"`
	// Standard_synchronize represents XSD element 'standard_synchronize'
	// minOccurs=0, maxOccurs=1
	Standard_synchronize *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"standard_synchronize,omitempty"`
	// Access_system_security represents XSD element 'access_system_security'
	// minOccurs=0, maxOccurs=1
	Access_system_security *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"access_system_security,omitempty"`
	// Generic_read represents XSD element 'generic_read'
	// minOccurs=0, maxOccurs=1
	Generic_read *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_read,omitempty"`
	// Generic_write represents XSD element 'generic_write'
	// minOccurs=0, maxOccurs=1
	Generic_write *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_write,omitempty"`
	// Generic_execute represents XSD element 'generic_execute'
	// minOccurs=0, maxOccurs=1
	Generic_execute *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_execute,omitempty"`
	// Generic_all represents XSD element 'generic_all'
	// minOccurs=0, maxOccurs=1
	Generic_all *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"generic_all,omitempty"`
	// Key_query_value represents XSD element 'key_query_value'
	// minOccurs=0, maxOccurs=1
	Key_query_value *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_query_value,omitempty"`
	// Key_set_value represents XSD element 'key_set_value'
	// minOccurs=0, maxOccurs=1
	Key_set_value *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_set_value,omitempty"`
	// Key_create_sub_key represents XSD element 'key_create_sub_key'
	// minOccurs=0, maxOccurs=1
	Key_create_sub_key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_create_sub_key,omitempty"`
	// Key_enumerate_sub_keys represents XSD element 'key_enumerate_sub_keys'
	// minOccurs=0, maxOccurs=1
	Key_enumerate_sub_keys *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_enumerate_sub_keys,omitempty"`
	// Key_notify represents XSD element 'key_notify'
	// minOccurs=0, maxOccurs=1
	Key_notify *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_notify,omitempty"`
	// Key_create_link represents XSD element 'key_create_link'
	// minOccurs=0, maxOccurs=1
	Key_create_link *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_create_link,omitempty"`
	// Key_wow64_64key represents XSD element 'key_wow64_64key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_64key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_64key,omitempty"`
	// Key_wow64_32key represents XSD element 'key_wow64_32key'
	// minOccurs=0, maxOccurs=1
	Key_wow64_32key *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_32key,omitempty"`
	// Key_wow64_res represents XSD element 'key_wow64_res'
	// minOccurs=0, maxOccurs=1
	Key_wow64_res *xmlschemaoval_definitions_5.EntityStateBoolType `xml:"key_wow64_res,omitempty"`
	// Windows_view represents XSD element 'windows_view'
	// minOccurs=0, maxOccurs=1
	Windows_view *EntityStateWindowsViewType `xml:"windows_view,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Regkeyeffectiverights_stateElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_stateElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Regkeyeffectiverights_stateElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Regkeyeffectiverights_stateElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Regkeyeffectiverights_stateElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Regkeyeffectiverights_stateElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Regkeyeffectiverights_stateElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Regkeyeffectiverights_stateElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Regkeyeffectiverights_stateElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadRegkeyeffectiverights_stateFromBytes loads an element from bytes with namespace preservation
func LoadRegkeyeffectiverights_stateFromBytes(data []byte) (*Regkeyeffectiverights_stateElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Regkeyeffectiverights_stateElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadRegkeyeffectiverights_stateFromFile loads an element from a file with namespace preservation
func LoadRegkeyeffectiverights_stateFromFile(path string) (*Regkeyeffectiverights_stateElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadRegkeyeffectiverights_stateFromBytes(data)
}
