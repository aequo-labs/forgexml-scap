// Package xmlschemaoval_definitions_5_windows - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_definitions_5_windows

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestAccesstokenBehaviors_MarshalUnmarshal tests XML round-trip for AccesstokenBehaviors
func TestAccesstokenBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &AccesstokenBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded AccesstokenBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_objectElement_MarshalUnmarshal tests XML round-trip for Accesstoken_objectElement
func TestAccesstoken_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccesstoken_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccesstoken_objectElement_ToBytes tests the ToBytes method
func TestAccesstoken_objectElement_ToBytes(t *testing.T) {
	elem := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccesstoken_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccesstoken_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccesstoken_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccesstoken_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccesstoken_objectElement_SaveAndLoad tests SaveToFile and LoadAccesstoken_objectFromFile
func TestAccesstoken_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Accesstoken_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccesstoken_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccesstoken_objectElement_LoadFromBytes tests the LoadAccesstoken_objectFromBytes function
func TestAccesstoken_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accesstoken_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></accesstoken_object>`)

	loaded, err := LoadAccesstoken_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccesstoken_objectElementType_MarshalUnmarshal tests XML round-trip for Accesstoken_objectElementType
func TestAccesstoken_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_stateElement_MarshalUnmarshal tests XML round-trip for Accesstoken_stateElement
func TestAccesstoken_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccesstoken_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccesstoken_stateElement_ToBytes tests the ToBytes method
func TestAccesstoken_stateElement_ToBytes(t *testing.T) {
	elem := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccesstoken_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccesstoken_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccesstoken_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccesstoken_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccesstoken_stateElement_SaveAndLoad tests SaveToFile and LoadAccesstoken_stateFromFile
func TestAccesstoken_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Accesstoken_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccesstoken_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccesstoken_stateElement_LoadFromBytes tests the LoadAccesstoken_stateFromBytes function
func TestAccesstoken_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accesstoken_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></accesstoken_state>`)

	loaded, err := LoadAccesstoken_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccesstoken_stateElementType_MarshalUnmarshal tests XML round-trip for Accesstoken_stateElementType
func TestAccesstoken_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_testElement_MarshalUnmarshal tests XML round-trip for Accesstoken_testElement
func TestAccesstoken_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAccesstoken_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAccesstoken_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAccesstoken_testElement_ToBytes tests the ToBytes method
func TestAccesstoken_testElement_ToBytes(t *testing.T) {
	elem := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAccesstoken_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAccesstoken_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAccesstoken_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAccesstoken_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAccesstoken_testElement_SaveAndLoad tests SaveToFile and LoadAccesstoken_testFromFile
func TestAccesstoken_testElement_SaveAndLoad(t *testing.T) {
	elem := &Accesstoken_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "accesstoken_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAccesstoken_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAccesstoken_testElement_LoadFromBytes tests the LoadAccesstoken_testFromBytes function
func TestAccesstoken_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<accesstoken_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></accesstoken_test>`)

	loaded, err := LoadAccesstoken_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAccesstoken_testElementType_MarshalUnmarshal tests XML round-trip for Accesstoken_testElementType
func TestAccesstoken_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Accesstoken_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Accesstoken_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_objectElement_MarshalUnmarshal tests XML round-trip for Activedirectory57_objectElement
func TestActivedirectory57_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory57_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory57_objectElement_ToBytes tests the ToBytes method
func TestActivedirectory57_objectElement_ToBytes(t *testing.T) {
	elem := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory57_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory57_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory57_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory57_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory57_objectElement_SaveAndLoad tests SaveToFile and LoadActivedirectory57_objectFromFile
func TestActivedirectory57_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory57_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory57_objectElement_LoadFromBytes tests the LoadActivedirectory57_objectFromBytes function
func TestActivedirectory57_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory57_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory57_object>`)

	loaded, err := LoadActivedirectory57_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory57_objectElementType_MarshalUnmarshal tests XML round-trip for Activedirectory57_objectElementType
func TestActivedirectory57_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_stateElement_MarshalUnmarshal tests XML round-trip for Activedirectory57_stateElement
func TestActivedirectory57_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory57_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory57_stateElement_ToBytes tests the ToBytes method
func TestActivedirectory57_stateElement_ToBytes(t *testing.T) {
	elem := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory57_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory57_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory57_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory57_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory57_stateElement_SaveAndLoad tests SaveToFile and LoadActivedirectory57_stateFromFile
func TestActivedirectory57_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory57_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory57_stateElement_LoadFromBytes tests the LoadActivedirectory57_stateFromBytes function
func TestActivedirectory57_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory57_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory57_state>`)

	loaded, err := LoadActivedirectory57_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory57_stateElementType_MarshalUnmarshal tests XML round-trip for Activedirectory57_stateElementType
func TestActivedirectory57_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_testElement_MarshalUnmarshal tests XML round-trip for Activedirectory57_testElement
func TestActivedirectory57_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory57_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory57_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory57_testElement_ToBytes tests the ToBytes method
func TestActivedirectory57_testElement_ToBytes(t *testing.T) {
	elem := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory57_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory57_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory57_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory57_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory57_testElement_SaveAndLoad tests SaveToFile and LoadActivedirectory57_testFromFile
func TestActivedirectory57_testElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory57_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory57_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory57_testElement_LoadFromBytes tests the LoadActivedirectory57_testFromBytes function
func TestActivedirectory57_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory57_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory57_test>`)

	loaded, err := LoadActivedirectory57_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory57_testElementType_MarshalUnmarshal tests XML round-trip for Activedirectory57_testElementType
func TestActivedirectory57_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory57_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory57_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_objectElement_MarshalUnmarshal tests XML round-trip for Activedirectory_objectElement
func TestActivedirectory_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory_objectElement_ToBytes tests the ToBytes method
func TestActivedirectory_objectElement_ToBytes(t *testing.T) {
	elem := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory_objectElement_SaveAndLoad tests SaveToFile and LoadActivedirectory_objectFromFile
func TestActivedirectory_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory_objectElement_LoadFromBytes tests the LoadActivedirectory_objectFromBytes function
func TestActivedirectory_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory_object>`)

	loaded, err := LoadActivedirectory_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory_objectElementType_MarshalUnmarshal tests XML round-trip for Activedirectory_objectElementType
func TestActivedirectory_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_stateElement_MarshalUnmarshal tests XML round-trip for Activedirectory_stateElement
func TestActivedirectory_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory_stateElement_ToBytes tests the ToBytes method
func TestActivedirectory_stateElement_ToBytes(t *testing.T) {
	elem := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory_stateElement_SaveAndLoad tests SaveToFile and LoadActivedirectory_stateFromFile
func TestActivedirectory_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory_stateElement_LoadFromBytes tests the LoadActivedirectory_stateFromBytes function
func TestActivedirectory_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory_state>`)

	loaded, err := LoadActivedirectory_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory_stateElementType_MarshalUnmarshal tests XML round-trip for Activedirectory_stateElementType
func TestActivedirectory_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_testElement_MarshalUnmarshal tests XML round-trip for Activedirectory_testElement
func TestActivedirectory_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestActivedirectory_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestActivedirectory_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestActivedirectory_testElement_ToBytes tests the ToBytes method
func TestActivedirectory_testElement_ToBytes(t *testing.T) {
	elem := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestActivedirectory_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestActivedirectory_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestActivedirectory_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestActivedirectory_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestActivedirectory_testElement_SaveAndLoad tests SaveToFile and LoadActivedirectory_testFromFile
func TestActivedirectory_testElement_SaveAndLoad(t *testing.T) {
	elem := &Activedirectory_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "activedirectory_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadActivedirectory_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestActivedirectory_testElement_LoadFromBytes tests the LoadActivedirectory_testFromBytes function
func TestActivedirectory_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<activedirectory_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></activedirectory_test>`)

	loaded, err := LoadActivedirectory_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestActivedirectory_testElementType_MarshalUnmarshal tests XML round-trip for Activedirectory_testElementType
func TestActivedirectory_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Activedirectory_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Activedirectory_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_objectElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_objectElement
func TestAuditeventpolicy_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicy_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicy_objectElement_ToBytes tests the ToBytes method
func TestAuditeventpolicy_objectElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicy_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicy_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicy_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_objectElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicy_objectFromFile
func TestAuditeventpolicy_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicy_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicy_objectElement_LoadFromBytes tests the LoadAuditeventpolicy_objectFromBytes function
func TestAuditeventpolicy_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicy_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicy_object>`)

	loaded, err := LoadAuditeventpolicy_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicy_objectElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_objectElementType
func TestAuditeventpolicy_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_stateElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_stateElement
func TestAuditeventpolicy_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicy_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicy_stateElement_ToBytes tests the ToBytes method
func TestAuditeventpolicy_stateElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicy_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicy_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicy_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_stateElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicy_stateFromFile
func TestAuditeventpolicy_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicy_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicy_stateElement_LoadFromBytes tests the LoadAuditeventpolicy_stateFromBytes function
func TestAuditeventpolicy_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicy_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicy_state>`)

	loaded, err := LoadAuditeventpolicy_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicy_stateElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_stateElementType
func TestAuditeventpolicy_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_testElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_testElement
func TestAuditeventpolicy_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicy_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicy_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicy_testElement_ToBytes tests the ToBytes method
func TestAuditeventpolicy_testElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicy_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicy_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicy_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicy_testElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicy_testFromFile
func TestAuditeventpolicy_testElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicy_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicy_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicy_testElement_LoadFromBytes tests the LoadAuditeventpolicy_testFromBytes function
func TestAuditeventpolicy_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicy_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicy_test>`)

	loaded, err := LoadAuditeventpolicy_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicy_testElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicy_testElementType
func TestAuditeventpolicy_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicy_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicy_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_objectElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_objectElement
func TestAuditeventpolicysubcategories_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicysubcategories_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicysubcategories_objectElement_ToBytes tests the ToBytes method
func TestAuditeventpolicysubcategories_objectElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicysubcategories_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicysubcategories_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicysubcategories_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_objectElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicysubcategories_objectFromFile
func TestAuditeventpolicysubcategories_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicysubcategories_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicysubcategories_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicysubcategories_objectElement_LoadFromBytes tests the LoadAuditeventpolicysubcategories_objectFromBytes function
func TestAuditeventpolicysubcategories_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicysubcategories_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicysubcategories_object>`)

	loaded, err := LoadAuditeventpolicysubcategories_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicysubcategories_objectElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_objectElementType
func TestAuditeventpolicysubcategories_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_stateElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_stateElement
func TestAuditeventpolicysubcategories_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicysubcategories_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicysubcategories_stateElement_ToBytes tests the ToBytes method
func TestAuditeventpolicysubcategories_stateElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicysubcategories_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicysubcategories_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicysubcategories_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_stateElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicysubcategories_stateFromFile
func TestAuditeventpolicysubcategories_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicysubcategories_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicysubcategories_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicysubcategories_stateElement_LoadFromBytes tests the LoadAuditeventpolicysubcategories_stateFromBytes function
func TestAuditeventpolicysubcategories_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicysubcategories_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicysubcategories_state>`)

	loaded, err := LoadAuditeventpolicysubcategories_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicysubcategories_stateElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_stateElementType
func TestAuditeventpolicysubcategories_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_testElement_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_testElement
func TestAuditeventpolicysubcategories_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestAuditeventpolicysubcategories_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestAuditeventpolicysubcategories_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestAuditeventpolicysubcategories_testElement_ToBytes tests the ToBytes method
func TestAuditeventpolicysubcategories_testElement_ToBytes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestAuditeventpolicysubcategories_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestAuditeventpolicysubcategories_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestAuditeventpolicysubcategories_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestAuditeventpolicysubcategories_testElement_SaveAndLoad tests SaveToFile and LoadAuditeventpolicysubcategories_testFromFile
func TestAuditeventpolicysubcategories_testElement_SaveAndLoad(t *testing.T) {
	elem := &Auditeventpolicysubcategories_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "auditeventpolicysubcategories_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadAuditeventpolicysubcategories_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestAuditeventpolicysubcategories_testElement_LoadFromBytes tests the LoadAuditeventpolicysubcategories_testFromBytes function
func TestAuditeventpolicysubcategories_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<auditeventpolicysubcategories_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></auditeventpolicysubcategories_test>`)

	loaded, err := LoadAuditeventpolicysubcategories_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestAuditeventpolicysubcategories_testElementType_MarshalUnmarshal tests XML round-trip for Auditeventpolicysubcategories_testElementType
func TestAuditeventpolicysubcategories_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Auditeventpolicysubcategories_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Auditeventpolicysubcategories_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_objectElement_MarshalUnmarshal tests XML round-trip for Cmdlet_objectElement
func TestCmdlet_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCmdlet_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCmdlet_objectElement_ToBytes tests the ToBytes method
func TestCmdlet_objectElement_ToBytes(t *testing.T) {
	elem := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCmdlet_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCmdlet_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCmdlet_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCmdlet_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCmdlet_objectElement_SaveAndLoad tests SaveToFile and LoadCmdlet_objectFromFile
func TestCmdlet_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Cmdlet_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCmdlet_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCmdlet_objectElement_LoadFromBytes tests the LoadCmdlet_objectFromBytes function
func TestCmdlet_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<cmdlet_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></cmdlet_object>`)

	loaded, err := LoadCmdlet_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCmdlet_objectElementType_MarshalUnmarshal tests XML round-trip for Cmdlet_objectElementType
func TestCmdlet_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_stateElement_MarshalUnmarshal tests XML round-trip for Cmdlet_stateElement
func TestCmdlet_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCmdlet_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCmdlet_stateElement_ToBytes tests the ToBytes method
func TestCmdlet_stateElement_ToBytes(t *testing.T) {
	elem := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCmdlet_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCmdlet_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCmdlet_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCmdlet_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCmdlet_stateElement_SaveAndLoad tests SaveToFile and LoadCmdlet_stateFromFile
func TestCmdlet_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Cmdlet_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCmdlet_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCmdlet_stateElement_LoadFromBytes tests the LoadCmdlet_stateFromBytes function
func TestCmdlet_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<cmdlet_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></cmdlet_state>`)

	loaded, err := LoadCmdlet_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCmdlet_stateElementType_MarshalUnmarshal tests XML round-trip for Cmdlet_stateElementType
func TestCmdlet_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_testElement_MarshalUnmarshal tests XML round-trip for Cmdlet_testElement
func TestCmdlet_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestCmdlet_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestCmdlet_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestCmdlet_testElement_ToBytes tests the ToBytes method
func TestCmdlet_testElement_ToBytes(t *testing.T) {
	elem := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestCmdlet_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestCmdlet_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestCmdlet_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestCmdlet_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestCmdlet_testElement_SaveAndLoad tests SaveToFile and LoadCmdlet_testFromFile
func TestCmdlet_testElement_SaveAndLoad(t *testing.T) {
	elem := &Cmdlet_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "cmdlet_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadCmdlet_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestCmdlet_testElement_LoadFromBytes tests the LoadCmdlet_testFromBytes function
func TestCmdlet_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<cmdlet_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></cmdlet_test>`)

	loaded, err := LoadCmdlet_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestCmdlet_testElementType_MarshalUnmarshal tests XML round-trip for Cmdlet_testElementType
func TestCmdlet_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Cmdlet_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Cmdlet_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_objectElement_MarshalUnmarshal tests XML round-trip for Dnscache_objectElement
func TestDnscache_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_objectElement_ToBytes tests the ToBytes method
func TestDnscache_objectElement_ToBytes(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_objectElement_SaveAndLoad tests SaveToFile and LoadDnscache_objectFromFile
func TestDnscache_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_objectElement_LoadFromBytes tests the LoadDnscache_objectFromBytes function
func TestDnscache_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></dnscache_object>`)

	loaded, err := LoadDnscache_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_objectElementType_MarshalUnmarshal tests XML round-trip for Dnscache_objectElementType
func TestDnscache_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_stateElement_MarshalUnmarshal tests XML round-trip for Dnscache_stateElement
func TestDnscache_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_stateElement_ToBytes tests the ToBytes method
func TestDnscache_stateElement_ToBytes(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_stateElement_SaveAndLoad tests SaveToFile and LoadDnscache_stateFromFile
func TestDnscache_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_stateElement_LoadFromBytes tests the LoadDnscache_stateFromBytes function
func TestDnscache_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></dnscache_state>`)

	loaded, err := LoadDnscache_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_stateElementType_MarshalUnmarshal tests XML round-trip for Dnscache_stateElementType
func TestDnscache_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_testElement_MarshalUnmarshal tests XML round-trip for Dnscache_testElement
func TestDnscache_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestDnscache_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestDnscache_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestDnscache_testElement_ToBytes tests the ToBytes method
func TestDnscache_testElement_ToBytes(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestDnscache_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestDnscache_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestDnscache_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestDnscache_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestDnscache_testElement_SaveAndLoad tests SaveToFile and LoadDnscache_testFromFile
func TestDnscache_testElement_SaveAndLoad(t *testing.T) {
	elem := &Dnscache_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "dnscache_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadDnscache_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestDnscache_testElement_LoadFromBytes tests the LoadDnscache_testFromBytes function
func TestDnscache_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<dnscache_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></dnscache_test>`)

	loaded, err := LoadDnscache_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestDnscache_testElementType_MarshalUnmarshal tests XML round-trip for Dnscache_testElementType
func TestDnscache_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Dnscache_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Dnscache_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectCmdletVerbType_MarshalUnmarshal tests XML round-trip for EntityObjectCmdletVerbType
func TestEntityObjectCmdletVerbType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectCmdletVerbType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectCmdletVerbType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectGUIDType_MarshalUnmarshal tests XML round-trip for EntityObjectGUIDType
func TestEntityObjectGUIDType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectGUIDType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectGUIDType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectNamingContextType_MarshalUnmarshal tests XML round-trip for EntityObjectNamingContextType
func TestEntityObjectNamingContextType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectNamingContextType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectNamingContextType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectProtocolType_MarshalUnmarshal tests XML round-trip for EntityObjectProtocolType
func TestEntityObjectProtocolType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectProtocolType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectProtocolType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectRegistryHiveType_MarshalUnmarshal tests XML round-trip for EntityObjectRegistryHiveType
func TestEntityObjectRegistryHiveType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectRegistryHiveType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectRegistryHiveType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectSystemMetricIndexType_MarshalUnmarshal tests XML round-trip for EntityObjectSystemMetricIndexType
func TestEntityObjectSystemMetricIndexType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectSystemMetricIndexType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectSystemMetricIndexType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityObjectUserRightType_MarshalUnmarshal tests XML round-trip for EntityObjectUserRightType
func TestEntityObjectUserRightType_MarshalUnmarshal(t *testing.T) {
	original := &EntityObjectUserRightType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityObjectUserRightType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAddrTypeType_MarshalUnmarshal tests XML round-trip for EntityStateAddrTypeType
func TestEntityStateAddrTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAddrTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAddrTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAdstypeType_MarshalUnmarshal tests XML round-trip for EntityStateAdstypeType
func TestEntityStateAdstypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAdstypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAdstypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateAuditType_MarshalUnmarshal tests XML round-trip for EntityStateAuditType
func TestEntityStateAuditType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateAuditType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateAuditType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateCmdletVerbType_MarshalUnmarshal tests XML round-trip for EntityStateCmdletVerbType
func TestEntityStateCmdletVerbType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateCmdletVerbType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateCmdletVerbType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateDriveTypeType_MarshalUnmarshal tests XML round-trip for EntityStateDriveTypeType
func TestEntityStateDriveTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateDriveTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateDriveTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateFileAttributeType_MarshalUnmarshal tests XML round-trip for EntityStateFileAttributeType
func TestEntityStateFileAttributeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateFileAttributeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateFileAttributeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateFileTypeType_MarshalUnmarshal tests XML round-trip for EntityStateFileTypeType
func TestEntityStateFileTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateFileTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateFileTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateGUIDType_MarshalUnmarshal tests XML round-trip for EntityStateGUIDType
func TestEntityStateGUIDType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateGUIDType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateGUIDType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateInterfaceTypeType_MarshalUnmarshal tests XML round-trip for EntityStateInterfaceTypeType
func TestEntityStateInterfaceTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateInterfaceTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateInterfaceTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateNTUserAccountTypeType_MarshalUnmarshal tests XML round-trip for EntityStateNTUserAccountTypeType
func TestEntityStateNTUserAccountTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateNTUserAccountTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateNTUserAccountTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateNamingContextType_MarshalUnmarshal tests XML round-trip for EntityStateNamingContextType
func TestEntityStateNamingContextType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateNamingContextType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateNamingContextType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePeSubsystemType_MarshalUnmarshal tests XML round-trip for EntityStatePeSubsystemType
func TestEntityStatePeSubsystemType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePeSubsystemType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePeSubsystemType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStatePeTargetMachineType_MarshalUnmarshal tests XML round-trip for EntityStatePeTargetMachineType
func TestEntityStatePeTargetMachineType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStatePeTargetMachineType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStatePeTargetMachineType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateProtocolType_MarshalUnmarshal tests XML round-trip for EntityStateProtocolType
func TestEntityStateProtocolType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateProtocolType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateProtocolType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateRegistryHiveType_MarshalUnmarshal tests XML round-trip for EntityStateRegistryHiveType
func TestEntityStateRegistryHiveType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateRegistryHiveType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateRegistryHiveType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateRegistryTypeType_MarshalUnmarshal tests XML round-trip for EntityStateRegistryTypeType
func TestEntityStateRegistryTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateRegistryTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateRegistryTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateServiceControlsAcceptedType_MarshalUnmarshal tests XML round-trip for EntityStateServiceControlsAcceptedType
func TestEntityStateServiceControlsAcceptedType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateServiceControlsAcceptedType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateServiceControlsAcceptedType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateServiceCurrentStateType_MarshalUnmarshal tests XML round-trip for EntityStateServiceCurrentStateType
func TestEntityStateServiceCurrentStateType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateServiceCurrentStateType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateServiceCurrentStateType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateServiceStartTypeType_MarshalUnmarshal tests XML round-trip for EntityStateServiceStartTypeType
func TestEntityStateServiceStartTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateServiceStartTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateServiceStartTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateServiceTypeType_MarshalUnmarshal tests XML round-trip for EntityStateServiceTypeType
func TestEntityStateServiceTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateServiceTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateServiceTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSharedResourceTypeType_MarshalUnmarshal tests XML round-trip for EntityStateSharedResourceTypeType
func TestEntityStateSharedResourceTypeType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSharedResourceTypeType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSharedResourceTypeType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateSystemMetricIndexType_MarshalUnmarshal tests XML round-trip for EntityStateSystemMetricIndexType
func TestEntityStateSystemMetricIndexType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateSystemMetricIndexType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateSystemMetricIndexType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateUserRightType_MarshalUnmarshal tests XML round-trip for EntityStateUserRightType
func TestEntityStateUserRightType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateUserRightType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateUserRightType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityStateWindowsViewType_MarshalUnmarshal tests XML round-trip for EntityStateWindowsViewType
func TestEntityStateWindowsViewType_MarshalUnmarshal(t *testing.T) {
	original := &EntityStateWindowsViewType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityStateWindowsViewType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileAuditPermissions53Behaviors_MarshalUnmarshal tests XML round-trip for FileAuditPermissions53Behaviors
func TestFileAuditPermissions53Behaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileAuditPermissions53Behaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileAuditPermissions53Behaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileAuditPermissionsBehaviors_MarshalUnmarshal tests XML round-trip for FileAuditPermissionsBehaviors
func TestFileAuditPermissionsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileAuditPermissionsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileAuditPermissionsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileBehaviors_MarshalUnmarshal tests XML round-trip for FileBehaviors
func TestFileBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileEffectiveRights53Behaviors_MarshalUnmarshal tests XML round-trip for FileEffectiveRights53Behaviors
func TestFileEffectiveRights53Behaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileEffectiveRights53Behaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileEffectiveRights53Behaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileEffectiveRightsBehaviors_MarshalUnmarshal tests XML round-trip for FileEffectiveRightsBehaviors
func TestFileEffectiveRightsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &FileEffectiveRightsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded FileEffectiveRightsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_objectElement_MarshalUnmarshal tests XML round-trip for File_objectElement
func TestFile_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_objectElement_ToBytes tests the ToBytes method
func TestFile_objectElement_ToBytes(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_objectElement_SaveAndLoad tests SaveToFile and LoadFile_objectFromFile
func TestFile_objectElement_SaveAndLoad(t *testing.T) {
	elem := &File_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_objectElement_LoadFromBytes tests the LoadFile_objectFromBytes function
func TestFile_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></file_object>`)

	loaded, err := LoadFile_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_objectElementType_MarshalUnmarshal tests XML round-trip for File_objectElementType
func TestFile_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_stateElement_MarshalUnmarshal tests XML round-trip for File_stateElement
func TestFile_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_stateElement_ToBytes tests the ToBytes method
func TestFile_stateElement_ToBytes(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_stateElement_SaveAndLoad tests SaveToFile and LoadFile_stateFromFile
func TestFile_stateElement_SaveAndLoad(t *testing.T) {
	elem := &File_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_stateElement_LoadFromBytes tests the LoadFile_stateFromBytes function
func TestFile_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></file_state>`)

	loaded, err := LoadFile_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_stateElementType_MarshalUnmarshal tests XML round-trip for File_stateElementType
func TestFile_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_testElement_MarshalUnmarshal tests XML round-trip for File_testElement
func TestFile_testElement_MarshalUnmarshal(t *testing.T) {
	original := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFile_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFile_testElement_MarshalIndentClean(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFile_testElement_ToBytes tests the ToBytes method
func TestFile_testElement_ToBytes(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFile_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFile_testElement_SetElementPrefixes(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFile_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFile_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFile_testElement_SaveAndLoad tests SaveToFile and LoadFile_testFromFile
func TestFile_testElement_SaveAndLoad(t *testing.T) {
	elem := &File_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "file_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFile_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFile_testElement_LoadFromBytes tests the LoadFile_testFromBytes function
func TestFile_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<file_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></file_test>`)

	loaded, err := LoadFile_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFile_testElementType_MarshalUnmarshal tests XML round-trip for File_testElementType
func TestFile_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &File_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded File_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_objectElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_objectElement
func TestFileauditedpermissions53_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions53_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions53_objectElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions53_objectElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions53_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions53_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions53_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_objectElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions53_objectFromFile
func TestFileauditedpermissions53_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions53_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions53_objectElement_LoadFromBytes tests the LoadFileauditedpermissions53_objectFromBytes function
func TestFileauditedpermissions53_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions53_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions53_object>`)

	loaded, err := LoadFileauditedpermissions53_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions53_objectElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_objectElementType
func TestFileauditedpermissions53_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_stateElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_stateElement
func TestFileauditedpermissions53_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions53_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions53_stateElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions53_stateElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions53_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions53_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions53_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_stateElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions53_stateFromFile
func TestFileauditedpermissions53_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions53_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions53_stateElement_LoadFromBytes tests the LoadFileauditedpermissions53_stateFromBytes function
func TestFileauditedpermissions53_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions53_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions53_state>`)

	loaded, err := LoadFileauditedpermissions53_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions53_stateElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_stateElementType
func TestFileauditedpermissions53_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_testElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_testElement
func TestFileauditedpermissions53_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions53_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions53_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions53_testElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions53_testElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions53_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions53_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions53_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions53_testElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions53_testFromFile
func TestFileauditedpermissions53_testElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions53_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions53_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions53_testElement_LoadFromBytes tests the LoadFileauditedpermissions53_testFromBytes function
func TestFileauditedpermissions53_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions53_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions53_test>`)

	loaded, err := LoadFileauditedpermissions53_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions53_testElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions53_testElementType
func TestFileauditedpermissions53_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions53_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions53_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_objectElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_objectElement
func TestFileauditedpermissions_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions_objectElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions_objectElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_objectElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions_objectFromFile
func TestFileauditedpermissions_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions_objectElement_LoadFromBytes tests the LoadFileauditedpermissions_objectFromBytes function
func TestFileauditedpermissions_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions_object>`)

	loaded, err := LoadFileauditedpermissions_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions_objectElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_objectElementType
func TestFileauditedpermissions_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_stateElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_stateElement
func TestFileauditedpermissions_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions_stateElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions_stateElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_stateElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions_stateFromFile
func TestFileauditedpermissions_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions_stateElement_LoadFromBytes tests the LoadFileauditedpermissions_stateFromBytes function
func TestFileauditedpermissions_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions_state>`)

	loaded, err := LoadFileauditedpermissions_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions_stateElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_stateElementType
func TestFileauditedpermissions_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_testElement_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_testElement
func TestFileauditedpermissions_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileauditedpermissions_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileauditedpermissions_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileauditedpermissions_testElement_ToBytes tests the ToBytes method
func TestFileauditedpermissions_testElement_ToBytes(t *testing.T) {
	elem := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileauditedpermissions_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileauditedpermissions_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileauditedpermissions_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileauditedpermissions_testElement_SaveAndLoad tests SaveToFile and LoadFileauditedpermissions_testFromFile
func TestFileauditedpermissions_testElement_SaveAndLoad(t *testing.T) {
	elem := &Fileauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileauditedpermissions_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileauditedpermissions_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileauditedpermissions_testElement_LoadFromBytes tests the LoadFileauditedpermissions_testFromBytes function
func TestFileauditedpermissions_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileauditedpermissions_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileauditedpermissions_test>`)

	loaded, err := LoadFileauditedpermissions_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileauditedpermissions_testElementType_MarshalUnmarshal tests XML round-trip for Fileauditedpermissions_testElementType
func TestFileauditedpermissions_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileauditedpermissions_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileauditedpermissions_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_objectElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_objectElement
func TestFileeffectiverights53_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights53_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights53_objectElement_ToBytes tests the ToBytes method
func TestFileeffectiverights53_objectElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights53_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights53_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights53_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_objectElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights53_objectFromFile
func TestFileeffectiverights53_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights53_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights53_objectElement_LoadFromBytes tests the LoadFileeffectiverights53_objectFromBytes function
func TestFileeffectiverights53_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights53_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights53_object>`)

	loaded, err := LoadFileeffectiverights53_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights53_objectElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_objectElementType
func TestFileeffectiverights53_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_stateElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_stateElement
func TestFileeffectiverights53_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights53_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights53_stateElement_ToBytes tests the ToBytes method
func TestFileeffectiverights53_stateElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights53_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights53_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights53_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_stateElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights53_stateFromFile
func TestFileeffectiverights53_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights53_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights53_stateElement_LoadFromBytes tests the LoadFileeffectiverights53_stateFromBytes function
func TestFileeffectiverights53_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights53_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights53_state>`)

	loaded, err := LoadFileeffectiverights53_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights53_stateElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_stateElementType
func TestFileeffectiverights53_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_testElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_testElement
func TestFileeffectiverights53_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights53_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights53_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights53_testElement_ToBytes tests the ToBytes method
func TestFileeffectiverights53_testElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights53_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights53_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights53_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights53_testElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights53_testFromFile
func TestFileeffectiverights53_testElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights53_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights53_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights53_testElement_LoadFromBytes tests the LoadFileeffectiverights53_testFromBytes function
func TestFileeffectiverights53_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights53_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights53_test>`)

	loaded, err := LoadFileeffectiverights53_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights53_testElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights53_testElementType
func TestFileeffectiverights53_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights53_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights53_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_objectElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_objectElement
func TestFileeffectiverights_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights_objectElement_ToBytes tests the ToBytes method
func TestFileeffectiverights_objectElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_objectElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights_objectFromFile
func TestFileeffectiverights_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights_objectElement_LoadFromBytes tests the LoadFileeffectiverights_objectFromBytes function
func TestFileeffectiverights_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights_object>`)

	loaded, err := LoadFileeffectiverights_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights_objectElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_objectElementType
func TestFileeffectiverights_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_stateElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_stateElement
func TestFileeffectiverights_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights_stateElement_ToBytes tests the ToBytes method
func TestFileeffectiverights_stateElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_stateElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights_stateFromFile
func TestFileeffectiverights_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights_stateElement_LoadFromBytes tests the LoadFileeffectiverights_stateFromBytes function
func TestFileeffectiverights_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights_state>`)

	loaded, err := LoadFileeffectiverights_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights_stateElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_stateElementType
func TestFileeffectiverights_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_testElement_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_testElement
func TestFileeffectiverights_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestFileeffectiverights_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestFileeffectiverights_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestFileeffectiverights_testElement_ToBytes tests the ToBytes method
func TestFileeffectiverights_testElement_ToBytes(t *testing.T) {
	elem := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestFileeffectiverights_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestFileeffectiverights_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestFileeffectiverights_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestFileeffectiverights_testElement_SaveAndLoad tests SaveToFile and LoadFileeffectiverights_testFromFile
func TestFileeffectiverights_testElement_SaveAndLoad(t *testing.T) {
	elem := &Fileeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "fileeffectiverights_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadFileeffectiverights_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestFileeffectiverights_testElement_LoadFromBytes tests the LoadFileeffectiverights_testFromBytes function
func TestFileeffectiverights_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<fileeffectiverights_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></fileeffectiverights_test>`)

	loaded, err := LoadFileeffectiverights_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestFileeffectiverights_testElementType_MarshalUnmarshal tests XML round-trip for Fileeffectiverights_testElementType
func TestFileeffectiverights_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Fileeffectiverights_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Fileeffectiverights_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_objectElement_MarshalUnmarshal tests XML round-trip for Group_objectElement
func TestGroup_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_objectElement_ToBytes tests the ToBytes method
func TestGroup_objectElement_ToBytes(t *testing.T) {
	elem := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_objectElement_SaveAndLoad tests SaveToFile and LoadGroup_objectFromFile
func TestGroup_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Group_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_objectElement_LoadFromBytes tests the LoadGroup_objectFromBytes function
func TestGroup_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_object>`)

	loaded, err := LoadGroup_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_objectElementType_MarshalUnmarshal tests XML round-trip for Group_objectElementType
func TestGroup_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_objectElement_MarshalUnmarshal tests XML round-trip for Group_sid_objectElement
func TestGroup_sid_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_sid_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_sid_objectElement_ToBytes tests the ToBytes method
func TestGroup_sid_objectElement_ToBytes(t *testing.T) {
	elem := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_sid_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_sid_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_sid_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_sid_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_sid_objectElement_SaveAndLoad tests SaveToFile and LoadGroup_sid_objectFromFile
func TestGroup_sid_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Group_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_sid_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_sid_objectElement_LoadFromBytes tests the LoadGroup_sid_objectFromBytes function
func TestGroup_sid_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_sid_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_sid_object>`)

	loaded, err := LoadGroup_sid_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_sid_objectElementType_MarshalUnmarshal tests XML round-trip for Group_sid_objectElementType
func TestGroup_sid_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_stateElement_MarshalUnmarshal tests XML round-trip for Group_sid_stateElement
func TestGroup_sid_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_sid_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_sid_stateElement_ToBytes tests the ToBytes method
func TestGroup_sid_stateElement_ToBytes(t *testing.T) {
	elem := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_sid_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_sid_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_sid_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_sid_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_sid_stateElement_SaveAndLoad tests SaveToFile and LoadGroup_sid_stateFromFile
func TestGroup_sid_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Group_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_sid_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_sid_stateElement_LoadFromBytes tests the LoadGroup_sid_stateFromBytes function
func TestGroup_sid_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_sid_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_sid_state>`)

	loaded, err := LoadGroup_sid_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_sid_stateElementType_MarshalUnmarshal tests XML round-trip for Group_sid_stateElementType
func TestGroup_sid_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_testElement_MarshalUnmarshal tests XML round-trip for Group_sid_testElement
func TestGroup_sid_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_sid_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_sid_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_sid_testElement_ToBytes tests the ToBytes method
func TestGroup_sid_testElement_ToBytes(t *testing.T) {
	elem := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_sid_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_sid_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_sid_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_sid_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_sid_testElement_SaveAndLoad tests SaveToFile and LoadGroup_sid_testFromFile
func TestGroup_sid_testElement_SaveAndLoad(t *testing.T) {
	elem := &Group_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_sid_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_sid_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_sid_testElement_LoadFromBytes tests the LoadGroup_sid_testFromBytes function
func TestGroup_sid_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_sid_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_sid_test>`)

	loaded, err := LoadGroup_sid_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_sid_testElementType_MarshalUnmarshal tests XML round-trip for Group_sid_testElementType
func TestGroup_sid_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_sid_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_sid_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_stateElement_MarshalUnmarshal tests XML round-trip for Group_stateElement
func TestGroup_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_stateElement_ToBytes tests the ToBytes method
func TestGroup_stateElement_ToBytes(t *testing.T) {
	elem := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_stateElement_SaveAndLoad tests SaveToFile and LoadGroup_stateFromFile
func TestGroup_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Group_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_stateElement_LoadFromBytes tests the LoadGroup_stateFromBytes function
func TestGroup_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_state>`)

	loaded, err := LoadGroup_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_stateElementType_MarshalUnmarshal tests XML round-trip for Group_stateElementType
func TestGroup_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_testElement_MarshalUnmarshal tests XML round-trip for Group_testElement
func TestGroup_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestGroup_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestGroup_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestGroup_testElement_ToBytes tests the ToBytes method
func TestGroup_testElement_ToBytes(t *testing.T) {
	elem := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestGroup_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestGroup_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestGroup_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestGroup_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestGroup_testElement_SaveAndLoad tests SaveToFile and LoadGroup_testFromFile
func TestGroup_testElement_SaveAndLoad(t *testing.T) {
	elem := &Group_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "group_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadGroup_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestGroup_testElement_LoadFromBytes tests the LoadGroup_testFromBytes function
func TestGroup_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<group_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></group_test>`)

	loaded, err := LoadGroup_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestGroup_testElementType_MarshalUnmarshal tests XML round-trip for Group_testElementType
func TestGroup_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Group_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Group_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalUnmarshal tests XML round-trip for Interface_objectElement
func TestInterface_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_objectElement_ToBytes tests the ToBytes method
func TestInterface_objectElement_ToBytes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_objectElement_SaveAndLoad tests SaveToFile and LoadInterface_objectFromFile
func TestInterface_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_objectElement_LoadFromBytes tests the LoadInterface_objectFromBytes function
func TestInterface_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></interface_object>`)

	loaded, err := LoadInterface_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_objectElementType_MarshalUnmarshal tests XML round-trip for Interface_objectElementType
func TestInterface_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalUnmarshal tests XML round-trip for Interface_stateElement
func TestInterface_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_stateElement_ToBytes tests the ToBytes method
func TestInterface_stateElement_ToBytes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_stateElement_SaveAndLoad tests SaveToFile and LoadInterface_stateFromFile
func TestInterface_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_stateElement_LoadFromBytes tests the LoadInterface_stateFromBytes function
func TestInterface_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></interface_state>`)

	loaded, err := LoadInterface_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_stateElementType_MarshalUnmarshal tests XML round-trip for Interface_stateElementType
func TestInterface_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalUnmarshal tests XML round-trip for Interface_testElement
func TestInterface_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterface_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestInterface_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestInterface_testElement_ToBytes tests the ToBytes method
func TestInterface_testElement_ToBytes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestInterface_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestInterface_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestInterface_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestInterface_testElement_SaveAndLoad tests SaveToFile and LoadInterface_testFromFile
func TestInterface_testElement_SaveAndLoad(t *testing.T) {
	elem := &Interface_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "interface_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadInterface_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestInterface_testElement_LoadFromBytes tests the LoadInterface_testFromBytes function
func TestInterface_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<interface_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></interface_test>`)

	loaded, err := LoadInterface_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestInterface_testElementType_MarshalUnmarshal tests XML round-trip for Interface_testElementType
func TestInterface_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Interface_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Interface_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_objectElement_MarshalUnmarshal tests XML round-trip for Junction_objectElement
func TestJunction_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestJunction_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestJunction_objectElement_ToBytes tests the ToBytes method
func TestJunction_objectElement_ToBytes(t *testing.T) {
	elem := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestJunction_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestJunction_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestJunction_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestJunction_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestJunction_objectElement_SaveAndLoad tests SaveToFile and LoadJunction_objectFromFile
func TestJunction_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Junction_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadJunction_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestJunction_objectElement_LoadFromBytes tests the LoadJunction_objectFromBytes function
func TestJunction_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<junction_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></junction_object>`)

	loaded, err := LoadJunction_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestJunction_objectElementType_MarshalUnmarshal tests XML round-trip for Junction_objectElementType
func TestJunction_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Junction_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_stateElement_MarshalUnmarshal tests XML round-trip for Junction_stateElement
func TestJunction_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestJunction_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestJunction_stateElement_ToBytes tests the ToBytes method
func TestJunction_stateElement_ToBytes(t *testing.T) {
	elem := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestJunction_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestJunction_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestJunction_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestJunction_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestJunction_stateElement_SaveAndLoad tests SaveToFile and LoadJunction_stateFromFile
func TestJunction_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Junction_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadJunction_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestJunction_stateElement_LoadFromBytes tests the LoadJunction_stateFromBytes function
func TestJunction_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<junction_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></junction_state>`)

	loaded, err := LoadJunction_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestJunction_stateElementType_MarshalUnmarshal tests XML round-trip for Junction_stateElementType
func TestJunction_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Junction_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_testElement_MarshalUnmarshal tests XML round-trip for Junction_testElement
func TestJunction_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestJunction_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestJunction_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestJunction_testElement_ToBytes tests the ToBytes method
func TestJunction_testElement_ToBytes(t *testing.T) {
	elem := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestJunction_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestJunction_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestJunction_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestJunction_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestJunction_testElement_SaveAndLoad tests SaveToFile and LoadJunction_testFromFile
func TestJunction_testElement_SaveAndLoad(t *testing.T) {
	elem := &Junction_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "junction_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadJunction_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestJunction_testElement_LoadFromBytes tests the LoadJunction_testFromBytes function
func TestJunction_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<junction_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></junction_test>`)

	loaded, err := LoadJunction_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestJunction_testElementType_MarshalUnmarshal tests XML round-trip for Junction_testElementType
func TestJunction_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Junction_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Junction_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_objectElement_MarshalUnmarshal tests XML round-trip for License_objectElement
func TestLicense_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLicense_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLicense_objectElement_ToBytes tests the ToBytes method
func TestLicense_objectElement_ToBytes(t *testing.T) {
	elem := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLicense_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLicense_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLicense_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLicense_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLicense_objectElement_SaveAndLoad tests SaveToFile and LoadLicense_objectFromFile
func TestLicense_objectElement_SaveAndLoad(t *testing.T) {
	elem := &License_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLicense_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLicense_objectElement_LoadFromBytes tests the LoadLicense_objectFromBytes function
func TestLicense_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<license_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></license_object>`)

	loaded, err := LoadLicense_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLicense_objectElementType_MarshalUnmarshal tests XML round-trip for License_objectElementType
func TestLicense_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &License_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_stateElement_MarshalUnmarshal tests XML round-trip for License_stateElement
func TestLicense_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLicense_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLicense_stateElement_ToBytes tests the ToBytes method
func TestLicense_stateElement_ToBytes(t *testing.T) {
	elem := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLicense_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLicense_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLicense_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLicense_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLicense_stateElement_SaveAndLoad tests SaveToFile and LoadLicense_stateFromFile
func TestLicense_stateElement_SaveAndLoad(t *testing.T) {
	elem := &License_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLicense_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLicense_stateElement_LoadFromBytes tests the LoadLicense_stateFromBytes function
func TestLicense_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<license_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></license_state>`)

	loaded, err := LoadLicense_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLicense_stateElementType_MarshalUnmarshal tests XML round-trip for License_stateElementType
func TestLicense_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &License_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_testElement_MarshalUnmarshal tests XML round-trip for License_testElement
func TestLicense_testElement_MarshalUnmarshal(t *testing.T) {
	original := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLicense_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLicense_testElement_MarshalIndentClean(t *testing.T) {
	elem := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLicense_testElement_ToBytes tests the ToBytes method
func TestLicense_testElement_ToBytes(t *testing.T) {
	elem := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLicense_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLicense_testElement_SetElementPrefixes(t *testing.T) {
	elem := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLicense_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLicense_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLicense_testElement_SaveAndLoad tests SaveToFile and LoadLicense_testFromFile
func TestLicense_testElement_SaveAndLoad(t *testing.T) {
	elem := &License_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "license_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLicense_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLicense_testElement_LoadFromBytes tests the LoadLicense_testFromBytes function
func TestLicense_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<license_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></license_test>`)

	loaded, err := LoadLicense_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLicense_testElementType_MarshalUnmarshal tests XML round-trip for License_testElementType
func TestLicense_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &License_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded License_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_objectElement_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_objectElement
func TestLockoutpolicy_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLockoutpolicy_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLockoutpolicy_objectElement_ToBytes tests the ToBytes method
func TestLockoutpolicy_objectElement_ToBytes(t *testing.T) {
	elem := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLockoutpolicy_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLockoutpolicy_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLockoutpolicy_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_objectElement_SaveAndLoad tests SaveToFile and LoadLockoutpolicy_objectFromFile
func TestLockoutpolicy_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Lockoutpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLockoutpolicy_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLockoutpolicy_objectElement_LoadFromBytes tests the LoadLockoutpolicy_objectFromBytes function
func TestLockoutpolicy_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<lockoutpolicy_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></lockoutpolicy_object>`)

	loaded, err := LoadLockoutpolicy_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLockoutpolicy_objectElementType_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_objectElementType
func TestLockoutpolicy_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_stateElement_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_stateElement
func TestLockoutpolicy_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLockoutpolicy_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLockoutpolicy_stateElement_ToBytes tests the ToBytes method
func TestLockoutpolicy_stateElement_ToBytes(t *testing.T) {
	elem := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLockoutpolicy_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLockoutpolicy_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLockoutpolicy_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_stateElement_SaveAndLoad tests SaveToFile and LoadLockoutpolicy_stateFromFile
func TestLockoutpolicy_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Lockoutpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLockoutpolicy_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLockoutpolicy_stateElement_LoadFromBytes tests the LoadLockoutpolicy_stateFromBytes function
func TestLockoutpolicy_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<lockoutpolicy_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></lockoutpolicy_state>`)

	loaded, err := LoadLockoutpolicy_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLockoutpolicy_stateElementType_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_stateElementType
func TestLockoutpolicy_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_testElement_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_testElement
func TestLockoutpolicy_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestLockoutpolicy_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestLockoutpolicy_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestLockoutpolicy_testElement_ToBytes tests the ToBytes method
func TestLockoutpolicy_testElement_ToBytes(t *testing.T) {
	elem := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestLockoutpolicy_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestLockoutpolicy_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestLockoutpolicy_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestLockoutpolicy_testElement_SaveAndLoad tests SaveToFile and LoadLockoutpolicy_testFromFile
func TestLockoutpolicy_testElement_SaveAndLoad(t *testing.T) {
	elem := &Lockoutpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "lockoutpolicy_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadLockoutpolicy_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestLockoutpolicy_testElement_LoadFromBytes tests the LoadLockoutpolicy_testFromBytes function
func TestLockoutpolicy_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<lockoutpolicy_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></lockoutpolicy_test>`)

	loaded, err := LoadLockoutpolicy_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestLockoutpolicy_testElementType_MarshalUnmarshal tests XML round-trip for Lockoutpolicy_testElementType
func TestLockoutpolicy_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Lockoutpolicy_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Lockoutpolicy_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_objectElement_MarshalUnmarshal tests XML round-trip for Metabase_objectElement
func TestMetabase_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestMetabase_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestMetabase_objectElement_ToBytes tests the ToBytes method
func TestMetabase_objectElement_ToBytes(t *testing.T) {
	elem := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestMetabase_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestMetabase_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestMetabase_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestMetabase_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestMetabase_objectElement_SaveAndLoad tests SaveToFile and LoadMetabase_objectFromFile
func TestMetabase_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Metabase_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadMetabase_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestMetabase_objectElement_LoadFromBytes tests the LoadMetabase_objectFromBytes function
func TestMetabase_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<metabase_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></metabase_object>`)

	loaded, err := LoadMetabase_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestMetabase_objectElementType_MarshalUnmarshal tests XML round-trip for Metabase_objectElementType
func TestMetabase_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_stateElement_MarshalUnmarshal tests XML round-trip for Metabase_stateElement
func TestMetabase_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestMetabase_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestMetabase_stateElement_ToBytes tests the ToBytes method
func TestMetabase_stateElement_ToBytes(t *testing.T) {
	elem := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestMetabase_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestMetabase_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestMetabase_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestMetabase_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestMetabase_stateElement_SaveAndLoad tests SaveToFile and LoadMetabase_stateFromFile
func TestMetabase_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Metabase_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadMetabase_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestMetabase_stateElement_LoadFromBytes tests the LoadMetabase_stateFromBytes function
func TestMetabase_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<metabase_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></metabase_state>`)

	loaded, err := LoadMetabase_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestMetabase_stateElementType_MarshalUnmarshal tests XML round-trip for Metabase_stateElementType
func TestMetabase_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_testElement_MarshalUnmarshal tests XML round-trip for Metabase_testElement
func TestMetabase_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestMetabase_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestMetabase_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestMetabase_testElement_ToBytes tests the ToBytes method
func TestMetabase_testElement_ToBytes(t *testing.T) {
	elem := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestMetabase_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestMetabase_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestMetabase_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestMetabase_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestMetabase_testElement_SaveAndLoad tests SaveToFile and LoadMetabase_testFromFile
func TestMetabase_testElement_SaveAndLoad(t *testing.T) {
	elem := &Metabase_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "metabase_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadMetabase_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestMetabase_testElement_LoadFromBytes tests the LoadMetabase_testFromBytes function
func TestMetabase_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<metabase_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></metabase_test>`)

	loaded, err := LoadMetabase_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestMetabase_testElementType_MarshalUnmarshal tests XML round-trip for Metabase_testElementType
func TestMetabase_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Metabase_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Metabase_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNTUserBehaviors_MarshalUnmarshal tests XML round-trip for NTUserBehaviors
func TestNTUserBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &NTUserBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded NTUserBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_objectElement_MarshalUnmarshal tests XML round-trip for Ntuser_objectElement
func TestNtuser_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNtuser_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNtuser_objectElement_ToBytes tests the ToBytes method
func TestNtuser_objectElement_ToBytes(t *testing.T) {
	elem := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNtuser_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNtuser_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNtuser_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNtuser_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNtuser_objectElement_SaveAndLoad tests SaveToFile and LoadNtuser_objectFromFile
func TestNtuser_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Ntuser_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNtuser_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNtuser_objectElement_LoadFromBytes tests the LoadNtuser_objectFromBytes function
func TestNtuser_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ntuser_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></ntuser_object>`)

	loaded, err := LoadNtuser_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNtuser_objectElementType_MarshalUnmarshal tests XML round-trip for Ntuser_objectElementType
func TestNtuser_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_stateElement_MarshalUnmarshal tests XML round-trip for Ntuser_stateElement
func TestNtuser_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNtuser_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNtuser_stateElement_ToBytes tests the ToBytes method
func TestNtuser_stateElement_ToBytes(t *testing.T) {
	elem := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNtuser_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNtuser_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNtuser_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNtuser_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNtuser_stateElement_SaveAndLoad tests SaveToFile and LoadNtuser_stateFromFile
func TestNtuser_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Ntuser_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNtuser_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNtuser_stateElement_LoadFromBytes tests the LoadNtuser_stateFromBytes function
func TestNtuser_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ntuser_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></ntuser_state>`)

	loaded, err := LoadNtuser_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNtuser_stateElementType_MarshalUnmarshal tests XML round-trip for Ntuser_stateElementType
func TestNtuser_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_testElement_MarshalUnmarshal tests XML round-trip for Ntuser_testElement
func TestNtuser_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestNtuser_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestNtuser_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestNtuser_testElement_ToBytes tests the ToBytes method
func TestNtuser_testElement_ToBytes(t *testing.T) {
	elem := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestNtuser_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestNtuser_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestNtuser_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestNtuser_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestNtuser_testElement_SaveAndLoad tests SaveToFile and LoadNtuser_testFromFile
func TestNtuser_testElement_SaveAndLoad(t *testing.T) {
	elem := &Ntuser_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "ntuser_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadNtuser_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestNtuser_testElement_LoadFromBytes tests the LoadNtuser_testFromBytes function
func TestNtuser_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<ntuser_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></ntuser_test>`)

	loaded, err := LoadNtuser_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestNtuser_testElementType_MarshalUnmarshal tests XML round-trip for Ntuser_testElementType
func TestNtuser_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Ntuser_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Ntuser_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_objectElement_MarshalUnmarshal tests XML round-trip for Passwordpolicy_objectElement
func TestPasswordpolicy_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPasswordpolicy_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPasswordpolicy_objectElement_ToBytes tests the ToBytes method
func TestPasswordpolicy_objectElement_ToBytes(t *testing.T) {
	elem := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPasswordpolicy_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPasswordpolicy_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPasswordpolicy_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_objectElement_SaveAndLoad tests SaveToFile and LoadPasswordpolicy_objectFromFile
func TestPasswordpolicy_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Passwordpolicy_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPasswordpolicy_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPasswordpolicy_objectElement_LoadFromBytes tests the LoadPasswordpolicy_objectFromBytes function
func TestPasswordpolicy_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<passwordpolicy_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></passwordpolicy_object>`)

	loaded, err := LoadPasswordpolicy_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPasswordpolicy_objectElementType_MarshalUnmarshal tests XML round-trip for Passwordpolicy_objectElementType
func TestPasswordpolicy_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_stateElement_MarshalUnmarshal tests XML round-trip for Passwordpolicy_stateElement
func TestPasswordpolicy_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPasswordpolicy_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPasswordpolicy_stateElement_ToBytes tests the ToBytes method
func TestPasswordpolicy_stateElement_ToBytes(t *testing.T) {
	elem := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPasswordpolicy_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPasswordpolicy_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPasswordpolicy_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_stateElement_SaveAndLoad tests SaveToFile and LoadPasswordpolicy_stateFromFile
func TestPasswordpolicy_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Passwordpolicy_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPasswordpolicy_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPasswordpolicy_stateElement_LoadFromBytes tests the LoadPasswordpolicy_stateFromBytes function
func TestPasswordpolicy_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<passwordpolicy_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></passwordpolicy_state>`)

	loaded, err := LoadPasswordpolicy_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPasswordpolicy_stateElementType_MarshalUnmarshal tests XML round-trip for Passwordpolicy_stateElementType
func TestPasswordpolicy_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_testElement_MarshalUnmarshal tests XML round-trip for Passwordpolicy_testElement
func TestPasswordpolicy_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPasswordpolicy_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPasswordpolicy_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPasswordpolicy_testElement_ToBytes tests the ToBytes method
func TestPasswordpolicy_testElement_ToBytes(t *testing.T) {
	elem := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPasswordpolicy_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPasswordpolicy_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPasswordpolicy_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPasswordpolicy_testElement_SaveAndLoad tests SaveToFile and LoadPasswordpolicy_testFromFile
func TestPasswordpolicy_testElement_SaveAndLoad(t *testing.T) {
	elem := &Passwordpolicy_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "passwordpolicy_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPasswordpolicy_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPasswordpolicy_testElement_LoadFromBytes tests the LoadPasswordpolicy_testFromBytes function
func TestPasswordpolicy_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<passwordpolicy_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></passwordpolicy_test>`)

	loaded, err := LoadPasswordpolicy_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPasswordpolicy_testElementType_MarshalUnmarshal tests XML round-trip for Passwordpolicy_testElementType
func TestPasswordpolicy_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Passwordpolicy_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Passwordpolicy_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_objectElement_MarshalUnmarshal tests XML round-trip for Peheader_objectElement
func TestPeheader_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPeheader_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPeheader_objectElement_ToBytes tests the ToBytes method
func TestPeheader_objectElement_ToBytes(t *testing.T) {
	elem := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPeheader_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPeheader_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPeheader_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPeheader_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPeheader_objectElement_SaveAndLoad tests SaveToFile and LoadPeheader_objectFromFile
func TestPeheader_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Peheader_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPeheader_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPeheader_objectElement_LoadFromBytes tests the LoadPeheader_objectFromBytes function
func TestPeheader_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<peheader_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></peheader_object>`)

	loaded, err := LoadPeheader_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPeheader_objectElementType_MarshalUnmarshal tests XML round-trip for Peheader_objectElementType
func TestPeheader_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_stateElement_MarshalUnmarshal tests XML round-trip for Peheader_stateElement
func TestPeheader_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPeheader_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPeheader_stateElement_ToBytes tests the ToBytes method
func TestPeheader_stateElement_ToBytes(t *testing.T) {
	elem := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPeheader_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPeheader_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPeheader_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPeheader_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPeheader_stateElement_SaveAndLoad tests SaveToFile and LoadPeheader_stateFromFile
func TestPeheader_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Peheader_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPeheader_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPeheader_stateElement_LoadFromBytes tests the LoadPeheader_stateFromBytes function
func TestPeheader_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<peheader_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></peheader_state>`)

	loaded, err := LoadPeheader_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPeheader_stateElementType_MarshalUnmarshal tests XML round-trip for Peheader_stateElementType
func TestPeheader_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_testElement_MarshalUnmarshal tests XML round-trip for Peheader_testElement
func TestPeheader_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPeheader_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPeheader_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPeheader_testElement_ToBytes tests the ToBytes method
func TestPeheader_testElement_ToBytes(t *testing.T) {
	elem := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPeheader_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPeheader_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPeheader_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPeheader_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPeheader_testElement_SaveAndLoad tests SaveToFile and LoadPeheader_testFromFile
func TestPeheader_testElement_SaveAndLoad(t *testing.T) {
	elem := &Peheader_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "peheader_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPeheader_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPeheader_testElement_LoadFromBytes tests the LoadPeheader_testFromBytes function
func TestPeheader_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<peheader_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></peheader_test>`)

	loaded, err := LoadPeheader_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPeheader_testElementType_MarshalUnmarshal tests XML round-trip for Peheader_testElementType
func TestPeheader_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Peheader_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Peheader_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_objectElement_MarshalUnmarshal tests XML round-trip for Port_objectElement
func TestPort_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPort_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPort_objectElement_ToBytes tests the ToBytes method
func TestPort_objectElement_ToBytes(t *testing.T) {
	elem := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPort_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPort_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPort_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPort_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPort_objectElement_SaveAndLoad tests SaveToFile and LoadPort_objectFromFile
func TestPort_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Port_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPort_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPort_objectElement_LoadFromBytes tests the LoadPort_objectFromBytes function
func TestPort_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<port_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></port_object>`)

	loaded, err := LoadPort_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPort_objectElementType_MarshalUnmarshal tests XML round-trip for Port_objectElementType
func TestPort_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Port_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_stateElement_MarshalUnmarshal tests XML round-trip for Port_stateElement
func TestPort_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPort_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPort_stateElement_ToBytes tests the ToBytes method
func TestPort_stateElement_ToBytes(t *testing.T) {
	elem := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPort_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPort_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPort_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPort_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPort_stateElement_SaveAndLoad tests SaveToFile and LoadPort_stateFromFile
func TestPort_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Port_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPort_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPort_stateElement_LoadFromBytes tests the LoadPort_stateFromBytes function
func TestPort_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<port_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></port_state>`)

	loaded, err := LoadPort_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPort_stateElementType_MarshalUnmarshal tests XML round-trip for Port_stateElementType
func TestPort_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Port_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_testElement_MarshalUnmarshal tests XML round-trip for Port_testElement
func TestPort_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPort_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPort_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPort_testElement_ToBytes tests the ToBytes method
func TestPort_testElement_ToBytes(t *testing.T) {
	elem := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPort_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPort_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPort_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPort_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPort_testElement_SaveAndLoad tests SaveToFile and LoadPort_testFromFile
func TestPort_testElement_SaveAndLoad(t *testing.T) {
	elem := &Port_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "port_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPort_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPort_testElement_LoadFromBytes tests the LoadPort_testFromBytes function
func TestPort_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<port_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></port_test>`)

	loaded, err := LoadPort_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPort_testElementType_MarshalUnmarshal tests XML round-trip for Port_testElementType
func TestPort_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Port_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Port_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrinterEffectiveRightsBehaviors_MarshalUnmarshal tests XML round-trip for PrinterEffectiveRightsBehaviors
func TestPrinterEffectiveRightsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &PrinterEffectiveRightsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PrinterEffectiveRightsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_objectElement_MarshalUnmarshal tests XML round-trip for Printereffectiverights_objectElement
func TestPrintereffectiverights_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPrintereffectiverights_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPrintereffectiverights_objectElement_ToBytes tests the ToBytes method
func TestPrintereffectiverights_objectElement_ToBytes(t *testing.T) {
	elem := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPrintereffectiverights_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPrintereffectiverights_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPrintereffectiverights_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_objectElement_SaveAndLoad tests SaveToFile and LoadPrintereffectiverights_objectFromFile
func TestPrintereffectiverights_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Printereffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPrintereffectiverights_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPrintereffectiverights_objectElement_LoadFromBytes tests the LoadPrintereffectiverights_objectFromBytes function
func TestPrintereffectiverights_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<printereffectiverights_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></printereffectiverights_object>`)

	loaded, err := LoadPrintereffectiverights_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPrintereffectiverights_objectElementType_MarshalUnmarshal tests XML round-trip for Printereffectiverights_objectElementType
func TestPrintereffectiverights_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_stateElement_MarshalUnmarshal tests XML round-trip for Printereffectiverights_stateElement
func TestPrintereffectiverights_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPrintereffectiverights_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPrintereffectiverights_stateElement_ToBytes tests the ToBytes method
func TestPrintereffectiverights_stateElement_ToBytes(t *testing.T) {
	elem := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPrintereffectiverights_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPrintereffectiverights_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPrintereffectiverights_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_stateElement_SaveAndLoad tests SaveToFile and LoadPrintereffectiverights_stateFromFile
func TestPrintereffectiverights_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Printereffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPrintereffectiverights_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPrintereffectiverights_stateElement_LoadFromBytes tests the LoadPrintereffectiverights_stateFromBytes function
func TestPrintereffectiverights_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<printereffectiverights_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></printereffectiverights_state>`)

	loaded, err := LoadPrintereffectiverights_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPrintereffectiverights_stateElementType_MarshalUnmarshal tests XML round-trip for Printereffectiverights_stateElementType
func TestPrintereffectiverights_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_testElement_MarshalUnmarshal tests XML round-trip for Printereffectiverights_testElement
func TestPrintereffectiverights_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPrintereffectiverights_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestPrintereffectiverights_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestPrintereffectiverights_testElement_ToBytes tests the ToBytes method
func TestPrintereffectiverights_testElement_ToBytes(t *testing.T) {
	elem := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestPrintereffectiverights_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestPrintereffectiverights_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestPrintereffectiverights_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestPrintereffectiverights_testElement_SaveAndLoad tests SaveToFile and LoadPrintereffectiverights_testFromFile
func TestPrintereffectiverights_testElement_SaveAndLoad(t *testing.T) {
	elem := &Printereffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "printereffectiverights_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadPrintereffectiverights_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestPrintereffectiverights_testElement_LoadFromBytes tests the LoadPrintereffectiverights_testFromBytes function
func TestPrintereffectiverights_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<printereffectiverights_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></printereffectiverights_test>`)

	loaded, err := LoadPrintereffectiverights_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestPrintereffectiverights_testElementType_MarshalUnmarshal tests XML round-trip for Printereffectiverights_testElementType
func TestPrintereffectiverights_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Printereffectiverights_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Printereffectiverights_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPriorityElementType_MarshalUnmarshal tests XML round-trip for PriorityElementType
func TestPriorityElementType_MarshalUnmarshal(t *testing.T) {
	original := &PriorityElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PriorityElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestPriorityElementType1_MarshalUnmarshal tests XML round-trip for PriorityElementType1
func TestPriorityElementType1_MarshalUnmarshal(t *testing.T) {
	original := &PriorityElementType1{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded PriorityElementType1
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_objectElement_MarshalUnmarshal tests XML round-trip for Process58_objectElement
func TestProcess58_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_objectElement_ToBytes tests the ToBytes method
func TestProcess58_objectElement_ToBytes(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_objectElement_SaveAndLoad tests SaveToFile and LoadProcess58_objectFromFile
func TestProcess58_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_objectElement_LoadFromBytes tests the LoadProcess58_objectFromBytes function
func TestProcess58_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process58_object>`)

	loaded, err := LoadProcess58_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_objectElementType_MarshalUnmarshal tests XML round-trip for Process58_objectElementType
func TestProcess58_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_stateElement_MarshalUnmarshal tests XML round-trip for Process58_stateElement
func TestProcess58_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_stateElement_ToBytes tests the ToBytes method
func TestProcess58_stateElement_ToBytes(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_stateElement_SaveAndLoad tests SaveToFile and LoadProcess58_stateFromFile
func TestProcess58_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_stateElement_LoadFromBytes tests the LoadProcess58_stateFromBytes function
func TestProcess58_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process58_state>`)

	loaded, err := LoadProcess58_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_stateElementType_MarshalUnmarshal tests XML round-trip for Process58_stateElementType
func TestProcess58_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_testElement_MarshalUnmarshal tests XML round-trip for Process58_testElement
func TestProcess58_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess58_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess58_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess58_testElement_ToBytes tests the ToBytes method
func TestProcess58_testElement_ToBytes(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess58_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess58_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess58_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess58_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess58_testElement_SaveAndLoad tests SaveToFile and LoadProcess58_testFromFile
func TestProcess58_testElement_SaveAndLoad(t *testing.T) {
	elem := &Process58_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process58_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess58_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess58_testElement_LoadFromBytes tests the LoadProcess58_testFromBytes function
func TestProcess58_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process58_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process58_test>`)

	loaded, err := LoadProcess58_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess58_testElementType_MarshalUnmarshal tests XML round-trip for Process58_testElementType
func TestProcess58_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process58_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process58_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_objectElement_MarshalUnmarshal tests XML round-trip for Process_objectElement
func TestProcess_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_objectElement_ToBytes tests the ToBytes method
func TestProcess_objectElement_ToBytes(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_objectElement_SaveAndLoad tests SaveToFile and LoadProcess_objectFromFile
func TestProcess_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Process_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_objectElement_LoadFromBytes tests the LoadProcess_objectFromBytes function
func TestProcess_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process_object>`)

	loaded, err := LoadProcess_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_objectElementType_MarshalUnmarshal tests XML round-trip for Process_objectElementType
func TestProcess_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_stateElement_MarshalUnmarshal tests XML round-trip for Process_stateElement
func TestProcess_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_stateElement_ToBytes tests the ToBytes method
func TestProcess_stateElement_ToBytes(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_stateElement_SaveAndLoad tests SaveToFile and LoadProcess_stateFromFile
func TestProcess_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Process_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_stateElement_LoadFromBytes tests the LoadProcess_stateFromBytes function
func TestProcess_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process_state>`)

	loaded, err := LoadProcess_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_stateElementType_MarshalUnmarshal tests XML round-trip for Process_stateElementType
func TestProcess_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_testElement_MarshalUnmarshal tests XML round-trip for Process_testElement
func TestProcess_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProcess_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestProcess_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestProcess_testElement_ToBytes tests the ToBytes method
func TestProcess_testElement_ToBytes(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestProcess_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestProcess_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestProcess_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestProcess_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestProcess_testElement_SaveAndLoad tests SaveToFile and LoadProcess_testFromFile
func TestProcess_testElement_SaveAndLoad(t *testing.T) {
	elem := &Process_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "process_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadProcess_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestProcess_testElement_LoadFromBytes tests the LoadProcess_testFromBytes function
func TestProcess_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<process_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></process_test>`)

	loaded, err := LoadProcess_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestProcess_testElementType_MarshalUnmarshal tests XML round-trip for Process_testElementType
func TestProcess_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Process_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Process_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestProduct_versionElementType_MarshalUnmarshal tests XML round-trip for Product_versionElementType
func TestProduct_versionElementType_MarshalUnmarshal(t *testing.T) {
	original := &Product_versionElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Product_versionElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistryBehaviors_MarshalUnmarshal tests XML round-trip for RegistryBehaviors
func TestRegistryBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RegistryBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RegistryBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_objectElement_MarshalUnmarshal tests XML round-trip for Registry_objectElement
func TestRegistry_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegistry_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegistry_objectElement_ToBytes tests the ToBytes method
func TestRegistry_objectElement_ToBytes(t *testing.T) {
	elem := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegistry_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegistry_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegistry_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegistry_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegistry_objectElement_SaveAndLoad tests SaveToFile and LoadRegistry_objectFromFile
func TestRegistry_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Registry_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegistry_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegistry_objectElement_LoadFromBytes tests the LoadRegistry_objectFromBytes function
func TestRegistry_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<registry_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></registry_object>`)

	loaded, err := LoadRegistry_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegistry_objectElementType_MarshalUnmarshal tests XML round-trip for Registry_objectElementType
func TestRegistry_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Registry_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_stateElement_MarshalUnmarshal tests XML round-trip for Registry_stateElement
func TestRegistry_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegistry_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegistry_stateElement_ToBytes tests the ToBytes method
func TestRegistry_stateElement_ToBytes(t *testing.T) {
	elem := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegistry_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegistry_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegistry_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegistry_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegistry_stateElement_SaveAndLoad tests SaveToFile and LoadRegistry_stateFromFile
func TestRegistry_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Registry_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegistry_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegistry_stateElement_LoadFromBytes tests the LoadRegistry_stateFromBytes function
func TestRegistry_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<registry_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></registry_state>`)

	loaded, err := LoadRegistry_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegistry_stateElementType_MarshalUnmarshal tests XML round-trip for Registry_stateElementType
func TestRegistry_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Registry_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_testElement_MarshalUnmarshal tests XML round-trip for Registry_testElement
func TestRegistry_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegistry_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegistry_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegistry_testElement_ToBytes tests the ToBytes method
func TestRegistry_testElement_ToBytes(t *testing.T) {
	elem := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegistry_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegistry_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegistry_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegistry_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegistry_testElement_SaveAndLoad tests SaveToFile and LoadRegistry_testFromFile
func TestRegistry_testElement_SaveAndLoad(t *testing.T) {
	elem := &Registry_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "registry_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegistry_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegistry_testElement_LoadFromBytes tests the LoadRegistry_testFromBytes function
func TestRegistry_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<registry_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></registry_test>`)

	loaded, err := LoadRegistry_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegistry_testElementType_MarshalUnmarshal tests XML round-trip for Registry_testElementType
func TestRegistry_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Registry_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Registry_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyAuditPermissions53Behaviors_MarshalUnmarshal tests XML round-trip for RegkeyAuditPermissions53Behaviors
func TestRegkeyAuditPermissions53Behaviors_MarshalUnmarshal(t *testing.T) {
	original := &RegkeyAuditPermissions53Behaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RegkeyAuditPermissions53Behaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyAuditPermissionsBehaviors_MarshalUnmarshal tests XML round-trip for RegkeyAuditPermissionsBehaviors
func TestRegkeyAuditPermissionsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RegkeyAuditPermissionsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RegkeyAuditPermissionsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyEffectiveRights53Behaviors_MarshalUnmarshal tests XML round-trip for RegkeyEffectiveRights53Behaviors
func TestRegkeyEffectiveRights53Behaviors_MarshalUnmarshal(t *testing.T) {
	original := &RegkeyEffectiveRights53Behaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RegkeyEffectiveRights53Behaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyEffectiveRightsBehaviors_MarshalUnmarshal tests XML round-trip for RegkeyEffectiveRightsBehaviors
func TestRegkeyEffectiveRightsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &RegkeyEffectiveRightsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded RegkeyEffectiveRightsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_objectElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_objectElement
func TestRegkeyauditedpermissions53_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions53_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions53_objectElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions53_objectElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions53_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions53_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions53_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_objectElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions53_objectFromFile
func TestRegkeyauditedpermissions53_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions53_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions53_objectElement_LoadFromBytes tests the LoadRegkeyauditedpermissions53_objectFromBytes function
func TestRegkeyauditedpermissions53_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions53_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions53_object>`)

	loaded, err := LoadRegkeyauditedpermissions53_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions53_objectElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_objectElementType
func TestRegkeyauditedpermissions53_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_stateElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_stateElement
func TestRegkeyauditedpermissions53_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions53_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions53_stateElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions53_stateElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions53_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions53_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions53_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_stateElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions53_stateFromFile
func TestRegkeyauditedpermissions53_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions53_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions53_stateElement_LoadFromBytes tests the LoadRegkeyauditedpermissions53_stateFromBytes function
func TestRegkeyauditedpermissions53_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions53_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions53_state>`)

	loaded, err := LoadRegkeyauditedpermissions53_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions53_stateElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_stateElementType
func TestRegkeyauditedpermissions53_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_testElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_testElement
func TestRegkeyauditedpermissions53_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions53_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions53_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions53_testElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions53_testElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions53_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions53_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions53_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions53_testElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions53_testFromFile
func TestRegkeyauditedpermissions53_testElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions53_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions53_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions53_testElement_LoadFromBytes tests the LoadRegkeyauditedpermissions53_testFromBytes function
func TestRegkeyauditedpermissions53_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions53_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions53_test>`)

	loaded, err := LoadRegkeyauditedpermissions53_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions53_testElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions53_testElementType
func TestRegkeyauditedpermissions53_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions53_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions53_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_objectElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_objectElement
func TestRegkeyauditedpermissions_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions_objectElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions_objectElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_objectElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions_objectFromFile
func TestRegkeyauditedpermissions_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions_objectElement_LoadFromBytes tests the LoadRegkeyauditedpermissions_objectFromBytes function
func TestRegkeyauditedpermissions_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions_object>`)

	loaded, err := LoadRegkeyauditedpermissions_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions_objectElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_objectElementType
func TestRegkeyauditedpermissions_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_stateElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_stateElement
func TestRegkeyauditedpermissions_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions_stateElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions_stateElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_stateElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions_stateFromFile
func TestRegkeyauditedpermissions_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions_stateElement_LoadFromBytes tests the LoadRegkeyauditedpermissions_stateFromBytes function
func TestRegkeyauditedpermissions_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions_state>`)

	loaded, err := LoadRegkeyauditedpermissions_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions_stateElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_stateElementType
func TestRegkeyauditedpermissions_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_testElement_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_testElement
func TestRegkeyauditedpermissions_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyauditedpermissions_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyauditedpermissions_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyauditedpermissions_testElement_ToBytes tests the ToBytes method
func TestRegkeyauditedpermissions_testElement_ToBytes(t *testing.T) {
	elem := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyauditedpermissions_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyauditedpermissions_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyauditedpermissions_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyauditedpermissions_testElement_SaveAndLoad tests SaveToFile and LoadRegkeyauditedpermissions_testFromFile
func TestRegkeyauditedpermissions_testElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyauditedpermissions_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyauditedpermissions_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyauditedpermissions_testElement_LoadFromBytes tests the LoadRegkeyauditedpermissions_testFromBytes function
func TestRegkeyauditedpermissions_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyauditedpermissions_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyauditedpermissions_test>`)

	loaded, err := LoadRegkeyauditedpermissions_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyauditedpermissions_testElementType_MarshalUnmarshal tests XML round-trip for Regkeyauditedpermissions_testElementType
func TestRegkeyauditedpermissions_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyauditedpermissions_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyauditedpermissions_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_objectElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_objectElement
func TestRegkeyeffectiverights53_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights53_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights53_objectElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights53_objectElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights53_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights53_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights53_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_objectElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights53_objectFromFile
func TestRegkeyeffectiverights53_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights53_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights53_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights53_objectElement_LoadFromBytes tests the LoadRegkeyeffectiverights53_objectFromBytes function
func TestRegkeyeffectiverights53_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights53_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights53_object>`)

	loaded, err := LoadRegkeyeffectiverights53_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights53_objectElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_objectElementType
func TestRegkeyeffectiverights53_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_stateElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_stateElement
func TestRegkeyeffectiverights53_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights53_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights53_stateElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights53_stateElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights53_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights53_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights53_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_stateElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights53_stateFromFile
func TestRegkeyeffectiverights53_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights53_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights53_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights53_stateElement_LoadFromBytes tests the LoadRegkeyeffectiverights53_stateFromBytes function
func TestRegkeyeffectiverights53_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights53_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights53_state>`)

	loaded, err := LoadRegkeyeffectiverights53_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights53_stateElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_stateElementType
func TestRegkeyeffectiverights53_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_testElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_testElement
func TestRegkeyeffectiverights53_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights53_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights53_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights53_testElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights53_testElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights53_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights53_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights53_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights53_testElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights53_testFromFile
func TestRegkeyeffectiverights53_testElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights53_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights53_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights53_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights53_testElement_LoadFromBytes tests the LoadRegkeyeffectiverights53_testFromBytes function
func TestRegkeyeffectiverights53_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights53_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights53_test>`)

	loaded, err := LoadRegkeyeffectiverights53_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights53_testElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights53_testElementType
func TestRegkeyeffectiverights53_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights53_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights53_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_objectElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_objectElement
func TestRegkeyeffectiverights_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights_objectElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights_objectElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_objectElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights_objectFromFile
func TestRegkeyeffectiverights_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights_objectElement_LoadFromBytes tests the LoadRegkeyeffectiverights_objectFromBytes function
func TestRegkeyeffectiverights_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights_object>`)

	loaded, err := LoadRegkeyeffectiverights_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights_objectElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_objectElementType
func TestRegkeyeffectiverights_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_stateElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_stateElement
func TestRegkeyeffectiverights_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights_stateElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights_stateElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_stateElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights_stateFromFile
func TestRegkeyeffectiverights_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights_stateElement_LoadFromBytes tests the LoadRegkeyeffectiverights_stateFromBytes function
func TestRegkeyeffectiverights_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights_state>`)

	loaded, err := LoadRegkeyeffectiverights_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights_stateElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_stateElementType
func TestRegkeyeffectiverights_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_testElement_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_testElement
func TestRegkeyeffectiverights_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestRegkeyeffectiverights_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestRegkeyeffectiverights_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestRegkeyeffectiverights_testElement_ToBytes tests the ToBytes method
func TestRegkeyeffectiverights_testElement_ToBytes(t *testing.T) {
	elem := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestRegkeyeffectiverights_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestRegkeyeffectiverights_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestRegkeyeffectiverights_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestRegkeyeffectiverights_testElement_SaveAndLoad tests SaveToFile and LoadRegkeyeffectiverights_testFromFile
func TestRegkeyeffectiverights_testElement_SaveAndLoad(t *testing.T) {
	elem := &Regkeyeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "regkeyeffectiverights_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadRegkeyeffectiverights_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestRegkeyeffectiverights_testElement_LoadFromBytes tests the LoadRegkeyeffectiverights_testFromBytes function
func TestRegkeyeffectiverights_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<regkeyeffectiverights_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></regkeyeffectiverights_test>`)

	loaded, err := LoadRegkeyeffectiverights_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestRegkeyeffectiverights_testElementType_MarshalUnmarshal tests XML round-trip for Regkeyeffectiverights_testElementType
func TestRegkeyeffectiverights_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Regkeyeffectiverights_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Regkeyeffectiverights_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceEffectiveRightsBehaviors_MarshalUnmarshal tests XML round-trip for ServiceEffectiveRightsBehaviors
func TestServiceEffectiveRightsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &ServiceEffectiveRightsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ServiceEffectiveRightsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_objectElement_MarshalUnmarshal tests XML round-trip for Service_objectElement
func TestService_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_objectElement_ToBytes tests the ToBytes method
func TestService_objectElement_ToBytes(t *testing.T) {
	elem := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_objectElement_SaveAndLoad tests SaveToFile and LoadService_objectFromFile
func TestService_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Service_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_objectElement_LoadFromBytes tests the LoadService_objectFromBytes function
func TestService_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></service_object>`)

	loaded, err := LoadService_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_objectElementType_MarshalUnmarshal tests XML round-trip for Service_objectElementType
func TestService_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_stateElement_MarshalUnmarshal tests XML round-trip for Service_stateElement
func TestService_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_stateElement_ToBytes tests the ToBytes method
func TestService_stateElement_ToBytes(t *testing.T) {
	elem := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_stateElement_SaveAndLoad tests SaveToFile and LoadService_stateFromFile
func TestService_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Service_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_stateElement_LoadFromBytes tests the LoadService_stateFromBytes function
func TestService_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></service_state>`)

	loaded, err := LoadService_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_stateElementType_MarshalUnmarshal tests XML round-trip for Service_stateElementType
func TestService_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_testElement_MarshalUnmarshal tests XML round-trip for Service_testElement
func TestService_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestService_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestService_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestService_testElement_ToBytes tests the ToBytes method
func TestService_testElement_ToBytes(t *testing.T) {
	elem := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestService_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestService_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestService_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestService_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestService_testElement_SaveAndLoad tests SaveToFile and LoadService_testFromFile
func TestService_testElement_SaveAndLoad(t *testing.T) {
	elem := &Service_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "service_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadService_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestService_testElement_LoadFromBytes tests the LoadService_testFromBytes function
func TestService_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<service_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></service_test>`)

	loaded, err := LoadService_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestService_testElementType_MarshalUnmarshal tests XML round-trip for Service_testElementType
func TestService_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Service_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Service_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_objectElement_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_objectElement
func TestServiceeffectiverights_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestServiceeffectiverights_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestServiceeffectiverights_objectElement_ToBytes tests the ToBytes method
func TestServiceeffectiverights_objectElement_ToBytes(t *testing.T) {
	elem := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestServiceeffectiverights_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestServiceeffectiverights_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestServiceeffectiverights_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_objectElement_SaveAndLoad tests SaveToFile and LoadServiceeffectiverights_objectFromFile
func TestServiceeffectiverights_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Serviceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadServiceeffectiverights_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestServiceeffectiverights_objectElement_LoadFromBytes tests the LoadServiceeffectiverights_objectFromBytes function
func TestServiceeffectiverights_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<serviceeffectiverights_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></serviceeffectiverights_object>`)

	loaded, err := LoadServiceeffectiverights_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestServiceeffectiverights_objectElementType_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_objectElementType
func TestServiceeffectiverights_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_stateElement_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_stateElement
func TestServiceeffectiverights_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestServiceeffectiverights_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestServiceeffectiverights_stateElement_ToBytes tests the ToBytes method
func TestServiceeffectiverights_stateElement_ToBytes(t *testing.T) {
	elem := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestServiceeffectiverights_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestServiceeffectiverights_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestServiceeffectiverights_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_stateElement_SaveAndLoad tests SaveToFile and LoadServiceeffectiverights_stateFromFile
func TestServiceeffectiverights_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Serviceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadServiceeffectiverights_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestServiceeffectiverights_stateElement_LoadFromBytes tests the LoadServiceeffectiverights_stateFromBytes function
func TestServiceeffectiverights_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<serviceeffectiverights_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></serviceeffectiverights_state>`)

	loaded, err := LoadServiceeffectiverights_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestServiceeffectiverights_stateElementType_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_stateElementType
func TestServiceeffectiverights_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_testElement_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_testElement
func TestServiceeffectiverights_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestServiceeffectiverights_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestServiceeffectiverights_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestServiceeffectiverights_testElement_ToBytes tests the ToBytes method
func TestServiceeffectiverights_testElement_ToBytes(t *testing.T) {
	elem := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestServiceeffectiverights_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestServiceeffectiverights_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestServiceeffectiverights_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestServiceeffectiverights_testElement_SaveAndLoad tests SaveToFile and LoadServiceeffectiverights_testFromFile
func TestServiceeffectiverights_testElement_SaveAndLoad(t *testing.T) {
	elem := &Serviceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "serviceeffectiverights_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadServiceeffectiverights_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestServiceeffectiverights_testElement_LoadFromBytes tests the LoadServiceeffectiverights_testFromBytes function
func TestServiceeffectiverights_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<serviceeffectiverights_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></serviceeffectiverights_test>`)

	loaded, err := LoadServiceeffectiverights_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestServiceeffectiverights_testElementType_MarshalUnmarshal tests XML round-trip for Serviceeffectiverights_testElementType
func TestServiceeffectiverights_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Serviceeffectiverights_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Serviceeffectiverights_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedResourceAuditedPermissionsBehaviors_MarshalUnmarshal tests XML round-trip for SharedResourceAuditedPermissionsBehaviors
func TestSharedResourceAuditedPermissionsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &SharedResourceAuditedPermissionsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SharedResourceAuditedPermissionsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedResourceEffectiveRightsBehaviors_MarshalUnmarshal tests XML round-trip for SharedResourceEffectiveRightsBehaviors
func TestSharedResourceEffectiveRightsBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &SharedResourceEffectiveRightsBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SharedResourceEffectiveRightsBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_objectElement_MarshalUnmarshal tests XML round-trip for Sharedresource_objectElement
func TestSharedresource_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresource_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresource_objectElement_ToBytes tests the ToBytes method
func TestSharedresource_objectElement_ToBytes(t *testing.T) {
	elem := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresource_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresource_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresource_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresource_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresource_objectElement_SaveAndLoad tests SaveToFile and LoadSharedresource_objectFromFile
func TestSharedresource_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresource_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresource_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresource_objectElement_LoadFromBytes tests the LoadSharedresource_objectFromBytes function
func TestSharedresource_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresource_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresource_object>`)

	loaded, err := LoadSharedresource_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresource_objectElementType_MarshalUnmarshal tests XML round-trip for Sharedresource_objectElementType
func TestSharedresource_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_stateElement_MarshalUnmarshal tests XML round-trip for Sharedresource_stateElement
func TestSharedresource_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresource_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresource_stateElement_ToBytes tests the ToBytes method
func TestSharedresource_stateElement_ToBytes(t *testing.T) {
	elem := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresource_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresource_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresource_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresource_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresource_stateElement_SaveAndLoad tests SaveToFile and LoadSharedresource_stateFromFile
func TestSharedresource_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresource_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresource_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresource_stateElement_LoadFromBytes tests the LoadSharedresource_stateFromBytes function
func TestSharedresource_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresource_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresource_state>`)

	loaded, err := LoadSharedresource_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresource_stateElementType_MarshalUnmarshal tests XML round-trip for Sharedresource_stateElementType
func TestSharedresource_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_testElement_MarshalUnmarshal tests XML round-trip for Sharedresource_testElement
func TestSharedresource_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresource_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresource_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresource_testElement_ToBytes tests the ToBytes method
func TestSharedresource_testElement_ToBytes(t *testing.T) {
	elem := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresource_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresource_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresource_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresource_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresource_testElement_SaveAndLoad tests SaveToFile and LoadSharedresource_testFromFile
func TestSharedresource_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresource_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresource_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresource_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresource_testElement_LoadFromBytes tests the LoadSharedresource_testFromBytes function
func TestSharedresource_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresource_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresource_test>`)

	loaded, err := LoadSharedresource_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresource_testElementType_MarshalUnmarshal tests XML round-trip for Sharedresource_testElementType
func TestSharedresource_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresource_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresource_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_objectElement_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_objectElement
func TestSharedresourceauditedpermissions_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceauditedpermissions_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceauditedpermissions_objectElement_ToBytes tests the ToBytes method
func TestSharedresourceauditedpermissions_objectElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceauditedpermissions_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceauditedpermissions_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceauditedpermissions_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_objectElement_SaveAndLoad tests SaveToFile and LoadSharedresourceauditedpermissions_objectFromFile
func TestSharedresourceauditedpermissions_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceauditedpermissions_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceauditedpermissions_objectElement_LoadFromBytes tests the LoadSharedresourceauditedpermissions_objectFromBytes function
func TestSharedresourceauditedpermissions_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceauditedpermissions_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceauditedpermissions_object>`)

	loaded, err := LoadSharedresourceauditedpermissions_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceauditedpermissions_objectElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_objectElementType
func TestSharedresourceauditedpermissions_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_stateElement_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_stateElement
func TestSharedresourceauditedpermissions_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceauditedpermissions_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceauditedpermissions_stateElement_ToBytes tests the ToBytes method
func TestSharedresourceauditedpermissions_stateElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceauditedpermissions_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceauditedpermissions_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceauditedpermissions_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_stateElement_SaveAndLoad tests SaveToFile and LoadSharedresourceauditedpermissions_stateFromFile
func TestSharedresourceauditedpermissions_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceauditedpermissions_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceauditedpermissions_stateElement_LoadFromBytes tests the LoadSharedresourceauditedpermissions_stateFromBytes function
func TestSharedresourceauditedpermissions_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceauditedpermissions_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceauditedpermissions_state>`)

	loaded, err := LoadSharedresourceauditedpermissions_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceauditedpermissions_stateElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_stateElementType
func TestSharedresourceauditedpermissions_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_testElement_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_testElement
func TestSharedresourceauditedpermissions_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceauditedpermissions_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceauditedpermissions_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceauditedpermissions_testElement_ToBytes tests the ToBytes method
func TestSharedresourceauditedpermissions_testElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceauditedpermissions_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceauditedpermissions_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceauditedpermissions_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceauditedpermissions_testElement_SaveAndLoad tests SaveToFile and LoadSharedresourceauditedpermissions_testFromFile
func TestSharedresourceauditedpermissions_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceauditedpermissions_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceauditedpermissions_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceauditedpermissions_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceauditedpermissions_testElement_LoadFromBytes tests the LoadSharedresourceauditedpermissions_testFromBytes function
func TestSharedresourceauditedpermissions_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceauditedpermissions_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceauditedpermissions_test>`)

	loaded, err := LoadSharedresourceauditedpermissions_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceauditedpermissions_testElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceauditedpermissions_testElementType
func TestSharedresourceauditedpermissions_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceauditedpermissions_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceauditedpermissions_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_objectElement_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_objectElement
func TestSharedresourceeffectiverights_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceeffectiverights_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceeffectiverights_objectElement_ToBytes tests the ToBytes method
func TestSharedresourceeffectiverights_objectElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceeffectiverights_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceeffectiverights_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceeffectiverights_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_objectElement_SaveAndLoad tests SaveToFile and LoadSharedresourceeffectiverights_objectFromFile
func TestSharedresourceeffectiverights_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceeffectiverights_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceeffectiverights_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceeffectiverights_objectElement_LoadFromBytes tests the LoadSharedresourceeffectiverights_objectFromBytes function
func TestSharedresourceeffectiverights_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceeffectiverights_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceeffectiverights_object>`)

	loaded, err := LoadSharedresourceeffectiverights_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceeffectiverights_objectElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_objectElementType
func TestSharedresourceeffectiverights_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_stateElement_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_stateElement
func TestSharedresourceeffectiverights_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceeffectiverights_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceeffectiverights_stateElement_ToBytes tests the ToBytes method
func TestSharedresourceeffectiverights_stateElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceeffectiverights_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceeffectiverights_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceeffectiverights_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_stateElement_SaveAndLoad tests SaveToFile and LoadSharedresourceeffectiverights_stateFromFile
func TestSharedresourceeffectiverights_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceeffectiverights_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceeffectiverights_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceeffectiverights_stateElement_LoadFromBytes tests the LoadSharedresourceeffectiverights_stateFromBytes function
func TestSharedresourceeffectiverights_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceeffectiverights_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceeffectiverights_state>`)

	loaded, err := LoadSharedresourceeffectiverights_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceeffectiverights_stateElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_stateElementType
func TestSharedresourceeffectiverights_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_testElement_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_testElement
func TestSharedresourceeffectiverights_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSharedresourceeffectiverights_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSharedresourceeffectiverights_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSharedresourceeffectiverights_testElement_ToBytes tests the ToBytes method
func TestSharedresourceeffectiverights_testElement_ToBytes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSharedresourceeffectiverights_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSharedresourceeffectiverights_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSharedresourceeffectiverights_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSharedresourceeffectiverights_testElement_SaveAndLoad tests SaveToFile and LoadSharedresourceeffectiverights_testFromFile
func TestSharedresourceeffectiverights_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sharedresourceeffectiverights_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sharedresourceeffectiverights_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSharedresourceeffectiverights_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSharedresourceeffectiverights_testElement_LoadFromBytes tests the LoadSharedresourceeffectiverights_testFromBytes function
func TestSharedresourceeffectiverights_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sharedresourceeffectiverights_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sharedresourceeffectiverights_test>`)

	loaded, err := LoadSharedresourceeffectiverights_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSharedresourceeffectiverights_testElementType_MarshalUnmarshal tests XML round-trip for Sharedresourceeffectiverights_testElementType
func TestSharedresourceeffectiverights_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sharedresourceeffectiverights_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sharedresourceeffectiverights_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSidBehaviors_MarshalUnmarshal tests XML round-trip for SidBehaviors
func TestSidBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &SidBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SidBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSidSidBehaviors_MarshalUnmarshal tests XML round-trip for SidSidBehaviors
func TestSidSidBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &SidSidBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SidSidBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_objectElement_MarshalUnmarshal tests XML round-trip for Sid_objectElement
func TestSid_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_objectElement_ToBytes tests the ToBytes method
func TestSid_objectElement_ToBytes(t *testing.T) {
	elem := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_objectElement_SaveAndLoad tests SaveToFile and LoadSid_objectFromFile
func TestSid_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_objectElement_LoadFromBytes tests the LoadSid_objectFromBytes function
func TestSid_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_object>`)

	loaded, err := LoadSid_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_objectElementType_MarshalUnmarshal tests XML round-trip for Sid_objectElementType
func TestSid_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_objectElement_MarshalUnmarshal tests XML round-trip for Sid_sid_objectElement
func TestSid_sid_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_sid_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_sid_objectElement_ToBytes tests the ToBytes method
func TestSid_sid_objectElement_ToBytes(t *testing.T) {
	elem := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_sid_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_sid_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_sid_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_sid_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_sid_objectElement_SaveAndLoad tests SaveToFile and LoadSid_sid_objectFromFile
func TestSid_sid_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_sid_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_sid_objectElement_LoadFromBytes tests the LoadSid_sid_objectFromBytes function
func TestSid_sid_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_sid_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_sid_object>`)

	loaded, err := LoadSid_sid_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_sid_objectElementType_MarshalUnmarshal tests XML round-trip for Sid_sid_objectElementType
func TestSid_sid_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_stateElement_MarshalUnmarshal tests XML round-trip for Sid_sid_stateElement
func TestSid_sid_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_sid_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_sid_stateElement_ToBytes tests the ToBytes method
func TestSid_sid_stateElement_ToBytes(t *testing.T) {
	elem := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_sid_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_sid_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_sid_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_sid_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_sid_stateElement_SaveAndLoad tests SaveToFile and LoadSid_sid_stateFromFile
func TestSid_sid_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_sid_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_sid_stateElement_LoadFromBytes tests the LoadSid_sid_stateFromBytes function
func TestSid_sid_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_sid_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_sid_state>`)

	loaded, err := LoadSid_sid_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_sid_stateElementType_MarshalUnmarshal tests XML round-trip for Sid_sid_stateElementType
func TestSid_sid_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_testElement_MarshalUnmarshal tests XML round-trip for Sid_sid_testElement
func TestSid_sid_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_sid_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_sid_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_sid_testElement_ToBytes tests the ToBytes method
func TestSid_sid_testElement_ToBytes(t *testing.T) {
	elem := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_sid_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_sid_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_sid_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_sid_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_sid_testElement_SaveAndLoad tests SaveToFile and LoadSid_sid_testFromFile
func TestSid_sid_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_sid_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_sid_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_sid_testElement_LoadFromBytes tests the LoadSid_sid_testFromBytes function
func TestSid_sid_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_sid_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_sid_test>`)

	loaded, err := LoadSid_sid_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_sid_testElementType_MarshalUnmarshal tests XML round-trip for Sid_sid_testElementType
func TestSid_sid_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_sid_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_sid_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_stateElement_MarshalUnmarshal tests XML round-trip for Sid_stateElement
func TestSid_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_stateElement_ToBytes tests the ToBytes method
func TestSid_stateElement_ToBytes(t *testing.T) {
	elem := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_stateElement_SaveAndLoad tests SaveToFile and LoadSid_stateFromFile
func TestSid_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_stateElement_LoadFromBytes tests the LoadSid_stateFromBytes function
func TestSid_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_state>`)

	loaded, err := LoadSid_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_stateElementType_MarshalUnmarshal tests XML round-trip for Sid_stateElementType
func TestSid_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_testElement_MarshalUnmarshal tests XML round-trip for Sid_testElement
func TestSid_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSid_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSid_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSid_testElement_ToBytes tests the ToBytes method
func TestSid_testElement_ToBytes(t *testing.T) {
	elem := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSid_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSid_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSid_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSid_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSid_testElement_SaveAndLoad tests SaveToFile and LoadSid_testFromFile
func TestSid_testElement_SaveAndLoad(t *testing.T) {
	elem := &Sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "sid_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSid_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSid_testElement_LoadFromBytes tests the LoadSid_testFromBytes function
func TestSid_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<sid_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></sid_test>`)

	loaded, err := LoadSid_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSid_testElementType_MarshalUnmarshal tests XML round-trip for Sid_testElementType
func TestSid_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Sid_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Sid_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_objectElement_MarshalUnmarshal tests XML round-trip for Systemmetric_objectElement
func TestSystemmetric_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemmetric_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemmetric_objectElement_ToBytes tests the ToBytes method
func TestSystemmetric_objectElement_ToBytes(t *testing.T) {
	elem := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemmetric_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemmetric_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemmetric_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemmetric_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemmetric_objectElement_SaveAndLoad tests SaveToFile and LoadSystemmetric_objectFromFile
func TestSystemmetric_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Systemmetric_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemmetric_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemmetric_objectElement_LoadFromBytes tests the LoadSystemmetric_objectFromBytes function
func TestSystemmetric_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemmetric_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></systemmetric_object>`)

	loaded, err := LoadSystemmetric_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemmetric_objectElementType_MarshalUnmarshal tests XML round-trip for Systemmetric_objectElementType
func TestSystemmetric_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_stateElement_MarshalUnmarshal tests XML round-trip for Systemmetric_stateElement
func TestSystemmetric_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemmetric_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemmetric_stateElement_ToBytes tests the ToBytes method
func TestSystemmetric_stateElement_ToBytes(t *testing.T) {
	elem := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemmetric_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemmetric_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemmetric_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemmetric_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemmetric_stateElement_SaveAndLoad tests SaveToFile and LoadSystemmetric_stateFromFile
func TestSystemmetric_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Systemmetric_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemmetric_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemmetric_stateElement_LoadFromBytes tests the LoadSystemmetric_stateFromBytes function
func TestSystemmetric_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemmetric_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></systemmetric_state>`)

	loaded, err := LoadSystemmetric_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemmetric_stateElementType_MarshalUnmarshal tests XML round-trip for Systemmetric_stateElementType
func TestSystemmetric_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_testElement_MarshalUnmarshal tests XML round-trip for Systemmetric_testElement
func TestSystemmetric_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemmetric_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestSystemmetric_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestSystemmetric_testElement_ToBytes tests the ToBytes method
func TestSystemmetric_testElement_ToBytes(t *testing.T) {
	elem := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestSystemmetric_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestSystemmetric_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestSystemmetric_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestSystemmetric_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestSystemmetric_testElement_SaveAndLoad tests SaveToFile and LoadSystemmetric_testFromFile
func TestSystemmetric_testElement_SaveAndLoad(t *testing.T) {
	elem := &Systemmetric_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "systemmetric_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadSystemmetric_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestSystemmetric_testElement_LoadFromBytes tests the LoadSystemmetric_testFromBytes function
func TestSystemmetric_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<systemmetric_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></systemmetric_test>`)

	loaded, err := LoadSystemmetric_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestSystemmetric_testElementType_MarshalUnmarshal tests XML round-trip for Systemmetric_testElementType
func TestSystemmetric_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Systemmetric_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Systemmetric_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_objectElement_MarshalUnmarshal tests XML round-trip for Uac_objectElement
func TestUac_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUac_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUac_objectElement_ToBytes tests the ToBytes method
func TestUac_objectElement_ToBytes(t *testing.T) {
	elem := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUac_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUac_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUac_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUac_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUac_objectElement_SaveAndLoad tests SaveToFile and LoadUac_objectFromFile
func TestUac_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Uac_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUac_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUac_objectElement_LoadFromBytes tests the LoadUac_objectFromBytes function
func TestUac_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uac_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></uac_object>`)

	loaded, err := LoadUac_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUac_objectElementType_MarshalUnmarshal tests XML round-trip for Uac_objectElementType
func TestUac_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uac_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_stateElement_MarshalUnmarshal tests XML round-trip for Uac_stateElement
func TestUac_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUac_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUac_stateElement_ToBytes tests the ToBytes method
func TestUac_stateElement_ToBytes(t *testing.T) {
	elem := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUac_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUac_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUac_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUac_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUac_stateElement_SaveAndLoad tests SaveToFile and LoadUac_stateFromFile
func TestUac_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Uac_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUac_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUac_stateElement_LoadFromBytes tests the LoadUac_stateFromBytes function
func TestUac_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uac_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></uac_state>`)

	loaded, err := LoadUac_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUac_stateElementType_MarshalUnmarshal tests XML round-trip for Uac_stateElementType
func TestUac_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uac_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_testElement_MarshalUnmarshal tests XML round-trip for Uac_testElement
func TestUac_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUac_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUac_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUac_testElement_ToBytes tests the ToBytes method
func TestUac_testElement_ToBytes(t *testing.T) {
	elem := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUac_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUac_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUac_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUac_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUac_testElement_SaveAndLoad tests SaveToFile and LoadUac_testFromFile
func TestUac_testElement_SaveAndLoad(t *testing.T) {
	elem := &Uac_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "uac_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUac_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUac_testElement_LoadFromBytes tests the LoadUac_testFromBytes function
func TestUac_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<uac_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></uac_test>`)

	loaded, err := LoadUac_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUac_testElementType_MarshalUnmarshal tests XML round-trip for Uac_testElementType
func TestUac_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Uac_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Uac_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_objectElement_MarshalUnmarshal tests XML round-trip for User_objectElement
func TestUser_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_objectElement_ToBytes tests the ToBytes method
func TestUser_objectElement_ToBytes(t *testing.T) {
	elem := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_objectElement_SaveAndLoad tests SaveToFile and LoadUser_objectFromFile
func TestUser_objectElement_SaveAndLoad(t *testing.T) {
	elem := &User_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_objectElement_LoadFromBytes tests the LoadUser_objectFromBytes function
func TestUser_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_object>`)

	loaded, err := LoadUser_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_objectElementType_MarshalUnmarshal tests XML round-trip for User_objectElementType
func TestUser_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_objectElement_MarshalUnmarshal tests XML round-trip for User_sid55_objectElement
func TestUser_sid55_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid55_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid55_objectElement_ToBytes tests the ToBytes method
func TestUser_sid55_objectElement_ToBytes(t *testing.T) {
	elem := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid55_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid55_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid55_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid55_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid55_objectElement_SaveAndLoad tests SaveToFile and LoadUser_sid55_objectFromFile
func TestUser_sid55_objectElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid55_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid55_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid55_objectElement_LoadFromBytes tests the LoadUser_sid55_objectFromBytes function
func TestUser_sid55_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid55_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid55_object>`)

	loaded, err := LoadUser_sid55_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid55_objectElementType_MarshalUnmarshal tests XML round-trip for User_sid55_objectElementType
func TestUser_sid55_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_stateElement_MarshalUnmarshal tests XML round-trip for User_sid55_stateElement
func TestUser_sid55_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid55_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid55_stateElement_ToBytes tests the ToBytes method
func TestUser_sid55_stateElement_ToBytes(t *testing.T) {
	elem := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid55_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid55_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid55_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid55_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid55_stateElement_SaveAndLoad tests SaveToFile and LoadUser_sid55_stateFromFile
func TestUser_sid55_stateElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid55_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid55_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid55_stateElement_LoadFromBytes tests the LoadUser_sid55_stateFromBytes function
func TestUser_sid55_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid55_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid55_state>`)

	loaded, err := LoadUser_sid55_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid55_stateElementType_MarshalUnmarshal tests XML round-trip for User_sid55_stateElementType
func TestUser_sid55_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_testElement_MarshalUnmarshal tests XML round-trip for User_sid55_testElement
func TestUser_sid55_testElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid55_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid55_testElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid55_testElement_ToBytes tests the ToBytes method
func TestUser_sid55_testElement_ToBytes(t *testing.T) {
	elem := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid55_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid55_testElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid55_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid55_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid55_testElement_SaveAndLoad tests SaveToFile and LoadUser_sid55_testFromFile
func TestUser_sid55_testElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid55_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid55_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid55_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid55_testElement_LoadFromBytes tests the LoadUser_sid55_testFromBytes function
func TestUser_sid55_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid55_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid55_test>`)

	loaded, err := LoadUser_sid55_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid55_testElementType_MarshalUnmarshal tests XML round-trip for User_sid55_testElementType
func TestUser_sid55_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid55_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid55_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_objectElement_MarshalUnmarshal tests XML round-trip for User_sid_objectElement
func TestUser_sid_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid_objectElement_ToBytes tests the ToBytes method
func TestUser_sid_objectElement_ToBytes(t *testing.T) {
	elem := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid_objectElement_SaveAndLoad tests SaveToFile and LoadUser_sid_objectFromFile
func TestUser_sid_objectElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid_objectElement_LoadFromBytes tests the LoadUser_sid_objectFromBytes function
func TestUser_sid_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid_object>`)

	loaded, err := LoadUser_sid_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid_objectElementType_MarshalUnmarshal tests XML round-trip for User_sid_objectElementType
func TestUser_sid_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_stateElement_MarshalUnmarshal tests XML round-trip for User_sid_stateElement
func TestUser_sid_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid_stateElement_ToBytes tests the ToBytes method
func TestUser_sid_stateElement_ToBytes(t *testing.T) {
	elem := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid_stateElement_SaveAndLoad tests SaveToFile and LoadUser_sid_stateFromFile
func TestUser_sid_stateElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid_stateElement_LoadFromBytes tests the LoadUser_sid_stateFromBytes function
func TestUser_sid_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid_state>`)

	loaded, err := LoadUser_sid_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid_stateElementType_MarshalUnmarshal tests XML round-trip for User_sid_stateElementType
func TestUser_sid_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_testElement_MarshalUnmarshal tests XML round-trip for User_sid_testElement
func TestUser_sid_testElement_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_sid_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_sid_testElement_MarshalIndentClean(t *testing.T) {
	elem := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_sid_testElement_ToBytes tests the ToBytes method
func TestUser_sid_testElement_ToBytes(t *testing.T) {
	elem := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_sid_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_sid_testElement_SetElementPrefixes(t *testing.T) {
	elem := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_sid_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_sid_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_sid_testElement_SaveAndLoad tests SaveToFile and LoadUser_sid_testFromFile
func TestUser_sid_testElement_SaveAndLoad(t *testing.T) {
	elem := &User_sid_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_sid_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_sid_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_sid_testElement_LoadFromBytes tests the LoadUser_sid_testFromBytes function
func TestUser_sid_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_sid_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_sid_test>`)

	loaded, err := LoadUser_sid_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_sid_testElementType_MarshalUnmarshal tests XML round-trip for User_sid_testElementType
func TestUser_sid_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_sid_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_sid_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_stateElement_MarshalUnmarshal tests XML round-trip for User_stateElement
func TestUser_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_stateElement_ToBytes tests the ToBytes method
func TestUser_stateElement_ToBytes(t *testing.T) {
	elem := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_stateElement_SaveAndLoad tests SaveToFile and LoadUser_stateFromFile
func TestUser_stateElement_SaveAndLoad(t *testing.T) {
	elem := &User_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_stateElement_LoadFromBytes tests the LoadUser_stateFromBytes function
func TestUser_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_state>`)

	loaded, err := LoadUser_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_stateElementType_MarshalUnmarshal tests XML round-trip for User_stateElementType
func TestUser_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_testElement_MarshalUnmarshal tests XML round-trip for User_testElement
func TestUser_testElement_MarshalUnmarshal(t *testing.T) {
	original := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUser_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUser_testElement_MarshalIndentClean(t *testing.T) {
	elem := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUser_testElement_ToBytes tests the ToBytes method
func TestUser_testElement_ToBytes(t *testing.T) {
	elem := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUser_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUser_testElement_SetElementPrefixes(t *testing.T) {
	elem := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUser_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUser_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUser_testElement_SaveAndLoad tests SaveToFile and LoadUser_testFromFile
func TestUser_testElement_SaveAndLoad(t *testing.T) {
	elem := &User_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "user_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUser_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUser_testElement_LoadFromBytes tests the LoadUser_testFromBytes function
func TestUser_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<user_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></user_test>`)

	loaded, err := LoadUser_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUser_testElementType_MarshalUnmarshal tests XML round-trip for User_testElementType
func TestUser_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &User_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded User_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_objectElement_MarshalUnmarshal tests XML round-trip for Userright_objectElement
func TestUserright_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUserright_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUserright_objectElement_ToBytes tests the ToBytes method
func TestUserright_objectElement_ToBytes(t *testing.T) {
	elem := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUserright_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUserright_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUserright_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUserright_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUserright_objectElement_SaveAndLoad tests SaveToFile and LoadUserright_objectFromFile
func TestUserright_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Userright_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUserright_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUserright_objectElement_LoadFromBytes tests the LoadUserright_objectFromBytes function
func TestUserright_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<userright_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></userright_object>`)

	loaded, err := LoadUserright_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUserright_objectElementType_MarshalUnmarshal tests XML round-trip for Userright_objectElementType
func TestUserright_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Userright_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_stateElement_MarshalUnmarshal tests XML round-trip for Userright_stateElement
func TestUserright_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUserright_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUserright_stateElement_ToBytes tests the ToBytes method
func TestUserright_stateElement_ToBytes(t *testing.T) {
	elem := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUserright_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUserright_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUserright_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUserright_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUserright_stateElement_SaveAndLoad tests SaveToFile and LoadUserright_stateFromFile
func TestUserright_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Userright_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUserright_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUserright_stateElement_LoadFromBytes tests the LoadUserright_stateFromBytes function
func TestUserright_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<userright_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></userright_state>`)

	loaded, err := LoadUserright_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUserright_stateElementType_MarshalUnmarshal tests XML round-trip for Userright_stateElementType
func TestUserright_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Userright_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_testElement_MarshalUnmarshal tests XML round-trip for Userright_testElement
func TestUserright_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestUserright_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestUserright_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestUserright_testElement_ToBytes tests the ToBytes method
func TestUserright_testElement_ToBytes(t *testing.T) {
	elem := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestUserright_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestUserright_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestUserright_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestUserright_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestUserright_testElement_SaveAndLoad tests SaveToFile and LoadUserright_testFromFile
func TestUserright_testElement_SaveAndLoad(t *testing.T) {
	elem := &Userright_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "userright_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadUserright_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestUserright_testElement_LoadFromBytes tests the LoadUserright_testFromBytes function
func TestUserright_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<userright_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></userright_test>`)

	loaded, err := LoadUserright_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestUserright_testElementType_MarshalUnmarshal tests XML round-trip for Userright_testElementType
func TestUserright_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Userright_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Userright_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_objectElement_MarshalUnmarshal tests XML round-trip for Volume_objectElement
func TestVolume_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVolume_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVolume_objectElement_ToBytes tests the ToBytes method
func TestVolume_objectElement_ToBytes(t *testing.T) {
	elem := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVolume_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVolume_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVolume_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVolume_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVolume_objectElement_SaveAndLoad tests SaveToFile and LoadVolume_objectFromFile
func TestVolume_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Volume_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVolume_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVolume_objectElement_LoadFromBytes tests the LoadVolume_objectFromBytes function
func TestVolume_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<volume_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></volume_object>`)

	loaded, err := LoadVolume_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVolume_objectElementType_MarshalUnmarshal tests XML round-trip for Volume_objectElementType
func TestVolume_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Volume_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_stateElement_MarshalUnmarshal tests XML round-trip for Volume_stateElement
func TestVolume_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVolume_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVolume_stateElement_ToBytes tests the ToBytes method
func TestVolume_stateElement_ToBytes(t *testing.T) {
	elem := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVolume_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVolume_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVolume_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVolume_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVolume_stateElement_SaveAndLoad tests SaveToFile and LoadVolume_stateFromFile
func TestVolume_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Volume_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVolume_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVolume_stateElement_LoadFromBytes tests the LoadVolume_stateFromBytes function
func TestVolume_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<volume_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></volume_state>`)

	loaded, err := LoadVolume_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVolume_stateElementType_MarshalUnmarshal tests XML round-trip for Volume_stateElementType
func TestVolume_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Volume_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_testElement_MarshalUnmarshal tests XML round-trip for Volume_testElement
func TestVolume_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVolume_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestVolume_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestVolume_testElement_ToBytes tests the ToBytes method
func TestVolume_testElement_ToBytes(t *testing.T) {
	elem := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestVolume_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestVolume_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestVolume_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestVolume_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestVolume_testElement_SaveAndLoad tests SaveToFile and LoadVolume_testFromFile
func TestVolume_testElement_SaveAndLoad(t *testing.T) {
	elem := &Volume_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "volume_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadVolume_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestVolume_testElement_LoadFromBytes tests the LoadVolume_testFromBytes function
func TestVolume_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<volume_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></volume_test>`)

	loaded, err := LoadVolume_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestVolume_testElementType_MarshalUnmarshal tests XML round-trip for Volume_testElementType
func TestVolume_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Volume_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Volume_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_objectElement_MarshalUnmarshal tests XML round-trip for Wmi57_objectElement
func TestWmi57_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi57_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi57_objectElement_ToBytes tests the ToBytes method
func TestWmi57_objectElement_ToBytes(t *testing.T) {
	elem := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi57_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi57_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi57_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi57_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi57_objectElement_SaveAndLoad tests SaveToFile and LoadWmi57_objectFromFile
func TestWmi57_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi57_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi57_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi57_objectElement_LoadFromBytes tests the LoadWmi57_objectFromBytes function
func TestWmi57_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi57_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi57_object>`)

	loaded, err := LoadWmi57_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi57_objectElementType_MarshalUnmarshal tests XML round-trip for Wmi57_objectElementType
func TestWmi57_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_stateElement_MarshalUnmarshal tests XML round-trip for Wmi57_stateElement
func TestWmi57_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi57_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi57_stateElement_ToBytes tests the ToBytes method
func TestWmi57_stateElement_ToBytes(t *testing.T) {
	elem := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi57_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi57_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi57_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi57_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi57_stateElement_SaveAndLoad tests SaveToFile and LoadWmi57_stateFromFile
func TestWmi57_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi57_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi57_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi57_stateElement_LoadFromBytes tests the LoadWmi57_stateFromBytes function
func TestWmi57_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi57_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi57_state>`)

	loaded, err := LoadWmi57_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi57_stateElementType_MarshalUnmarshal tests XML round-trip for Wmi57_stateElementType
func TestWmi57_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_testElement_MarshalUnmarshal tests XML round-trip for Wmi57_testElement
func TestWmi57_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi57_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi57_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi57_testElement_ToBytes tests the ToBytes method
func TestWmi57_testElement_ToBytes(t *testing.T) {
	elem := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi57_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi57_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi57_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi57_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi57_testElement_SaveAndLoad tests SaveToFile and LoadWmi57_testFromFile
func TestWmi57_testElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi57_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi57_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi57_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi57_testElement_LoadFromBytes tests the LoadWmi57_testFromBytes function
func TestWmi57_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi57_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi57_test>`)

	loaded, err := LoadWmi57_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi57_testElementType_MarshalUnmarshal tests XML round-trip for Wmi57_testElementType
func TestWmi57_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi57_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi57_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_objectElement_MarshalUnmarshal tests XML round-trip for Wmi_objectElement
func TestWmi_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi_objectElement_ToBytes tests the ToBytes method
func TestWmi_objectElement_ToBytes(t *testing.T) {
	elem := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi_objectElement_SaveAndLoad tests SaveToFile and LoadWmi_objectFromFile
func TestWmi_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi_objectElement_LoadFromBytes tests the LoadWmi_objectFromBytes function
func TestWmi_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi_object>`)

	loaded, err := LoadWmi_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi_objectElementType_MarshalUnmarshal tests XML round-trip for Wmi_objectElementType
func TestWmi_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_stateElement_MarshalUnmarshal tests XML round-trip for Wmi_stateElement
func TestWmi_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi_stateElement_ToBytes tests the ToBytes method
func TestWmi_stateElement_ToBytes(t *testing.T) {
	elem := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi_stateElement_SaveAndLoad tests SaveToFile and LoadWmi_stateFromFile
func TestWmi_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi_stateElement_LoadFromBytes tests the LoadWmi_stateFromBytes function
func TestWmi_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi_state>`)

	loaded, err := LoadWmi_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi_stateElementType_MarshalUnmarshal tests XML round-trip for Wmi_stateElementType
func TestWmi_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_testElement_MarshalUnmarshal tests XML round-trip for Wmi_testElement
func TestWmi_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWmi_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWmi_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWmi_testElement_ToBytes tests the ToBytes method
func TestWmi_testElement_ToBytes(t *testing.T) {
	elem := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWmi_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWmi_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWmi_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWmi_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWmi_testElement_SaveAndLoad tests SaveToFile and LoadWmi_testFromFile
func TestWmi_testElement_SaveAndLoad(t *testing.T) {
	elem := &Wmi_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wmi_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWmi_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWmi_testElement_LoadFromBytes tests the LoadWmi_testFromBytes function
func TestWmi_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wmi_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wmi_test>`)

	loaded, err := LoadWmi_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWmi_testElementType_MarshalUnmarshal tests XML round-trip for Wmi_testElementType
func TestWmi_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wmi_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wmi_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaUpdateSearcherBehaviors_MarshalUnmarshal tests XML round-trip for WuaUpdateSearcherBehaviors
func TestWuaUpdateSearcherBehaviors_MarshalUnmarshal(t *testing.T) {
	original := &WuaUpdateSearcherBehaviors{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded WuaUpdateSearcherBehaviors
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_objectElement_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_objectElement
func TestWuaupdatesearcher_objectElement_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_objectElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_objectElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWuaupdatesearcher_objectElement_MarshalIndentClean(t *testing.T) {
	elem := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWuaupdatesearcher_objectElement_ToBytes tests the ToBytes method
func TestWuaupdatesearcher_objectElement_ToBytes(t *testing.T) {
	elem := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWuaupdatesearcher_objectElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWuaupdatesearcher_objectElement_SetElementPrefixes(t *testing.T) {
	elem := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_objectElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWuaupdatesearcher_objectElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_objectElement_SaveAndLoad tests SaveToFile and LoadWuaupdatesearcher_objectFromFile
func TestWuaupdatesearcher_objectElement_SaveAndLoad(t *testing.T) {
	elem := &Wuaupdatesearcher_objectElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_object"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWuaupdatesearcher_objectFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWuaupdatesearcher_objectElement_LoadFromBytes tests the LoadWuaupdatesearcher_objectFromBytes function
func TestWuaupdatesearcher_objectElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wuaupdatesearcher_object xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wuaupdatesearcher_object>`)

	loaded, err := LoadWuaupdatesearcher_objectFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWuaupdatesearcher_objectElementType_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_objectElementType
func TestWuaupdatesearcher_objectElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_objectElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_objectElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_stateElement_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_stateElement
func TestWuaupdatesearcher_stateElement_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_stateElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_stateElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWuaupdatesearcher_stateElement_MarshalIndentClean(t *testing.T) {
	elem := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWuaupdatesearcher_stateElement_ToBytes tests the ToBytes method
func TestWuaupdatesearcher_stateElement_ToBytes(t *testing.T) {
	elem := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWuaupdatesearcher_stateElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWuaupdatesearcher_stateElement_SetElementPrefixes(t *testing.T) {
	elem := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_stateElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWuaupdatesearcher_stateElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_stateElement_SaveAndLoad tests SaveToFile and LoadWuaupdatesearcher_stateFromFile
func TestWuaupdatesearcher_stateElement_SaveAndLoad(t *testing.T) {
	elem := &Wuaupdatesearcher_stateElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_state"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWuaupdatesearcher_stateFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWuaupdatesearcher_stateElement_LoadFromBytes tests the LoadWuaupdatesearcher_stateFromBytes function
func TestWuaupdatesearcher_stateElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wuaupdatesearcher_state xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wuaupdatesearcher_state>`)

	loaded, err := LoadWuaupdatesearcher_stateFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWuaupdatesearcher_stateElementType_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_stateElementType
func TestWuaupdatesearcher_stateElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_stateElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_stateElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_testElement_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_testElement
func TestWuaupdatesearcher_testElement_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_testElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestWuaupdatesearcher_testElement_MarshalIndentClean tests the MarshalIndentClean method
func TestWuaupdatesearcher_testElement_MarshalIndentClean(t *testing.T) {
	elem := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestWuaupdatesearcher_testElement_ToBytes tests the ToBytes method
func TestWuaupdatesearcher_testElement_ToBytes(t *testing.T) {
	elem := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestWuaupdatesearcher_testElement_SetElementPrefixes tests the SetElementPrefixes method
func TestWuaupdatesearcher_testElement_SetElementPrefixes(t *testing.T) {
	elem := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_testElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestWuaupdatesearcher_testElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestWuaupdatesearcher_testElement_SaveAndLoad tests SaveToFile and LoadWuaupdatesearcher_testFromFile
func TestWuaupdatesearcher_testElement_SaveAndLoad(t *testing.T) {
	elem := &Wuaupdatesearcher_testElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-definitions-5#windows", Local: "wuaupdatesearcher_test"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadWuaupdatesearcher_testFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestWuaupdatesearcher_testElement_LoadFromBytes tests the LoadWuaupdatesearcher_testFromBytes function
func TestWuaupdatesearcher_testElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<wuaupdatesearcher_test xmlns="http://oval.mitre.org/XMLSchema/oval-definitions-5#windows"></wuaupdatesearcher_test>`)

	loaded, err := LoadWuaupdatesearcher_testFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestWuaupdatesearcher_testElementType_MarshalUnmarshal tests XML round-trip for Wuaupdatesearcher_testElementType
func TestWuaupdatesearcher_testElementType_MarshalUnmarshal(t *testing.T) {
	original := &Wuaupdatesearcher_testElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Wuaupdatesearcher_testElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
