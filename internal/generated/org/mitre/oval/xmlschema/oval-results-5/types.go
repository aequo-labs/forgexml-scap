// Package xmlschemaoval_results_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-results-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-results-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_results_5

import (
	"encoding/xml"
	"regexp"
	"strings"

	dictionary2_0 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/cpe/dictionary/2-0"
	xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
	xmlschemaoval_definitions_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-definitions-5"
	xmlschemaoval_system_characteristics_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-system-characteristics-5"
	pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
	XMLName xml.Name   `xml:""`
	Content string     `xml:",innerxml"`
	Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -> xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string {
	elementsWithXmlns := make(map[string]string)
	xmlStr := string(xmlData)

	// Pattern to find elements with xmlns: <element_name ...xmlns="uri"...
	// Captures both prefixed and unprefixed element names
	pattern := regexp.MustCompile(`<(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^>]*?xmlns="([^"]+)"`)
	matches := pattern.FindAllStringSubmatch(xmlStr, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			// match[1] = prefix (may be empty)
			// match[2] = element name
			// match[3] = xmlns URI
			elementName := match[2]
			xmlnsURI := match[3]
			elementsWithXmlns[elementName] = xmlnsURI
		}
	}

	return elementsWithXmlns
}

// ExtractElementPrefixes parses raw XML to build element name -> prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string {
	elementPrefixes := make(map[string]string)

	// Use regex to find all opening tags with prefixes: <prefix:element
	pattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s>]`)
	matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

	for _, match := range matches {
		if len(match) >= 3 {
			prefix := match[1]
			elementName := match[2]
			elementPrefixes[elementName] = prefix
		}
	}

	return elementPrefixes
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string {
	// For each element name -> prefix mapping
	for elementName, prefix := range elementPrefixes {
		// Replace opening tags: <elementName with <prefix:elementName
		// and remove default xmlns="..." since the prefix declares the namespace
		pattern := regexp.MustCompile(`<` + elementName + `(\s[^>]*)?>`)
		xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
			// Add prefix to element name
			result := "<" + prefix + ":" + elementName
			// Extract attributes (everything between element name and >)
			if len(match) > len("<"+elementName+">") {
				attrs := match[len("<"+elementName) : len(match)-1]
				// Remove default xmlns="..." attribute
				xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, "")
				result += attrs
			}
			result += ">"
			return result
		})

		// Replace closing tags: </elementName> with </prefix:elementName>
		xmlOutput = strings.ReplaceAll(xmlOutput, "</"+elementName+">", "</"+prefix+":"+elementName+">")
	}

	return xmlOutput
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string {
	if len(elementsWithXmlns) == 0 {
		// No xmlns tracking - remove all nested xmlns to avoid inflation
		// Keep only root element xmlns
		firstGT := strings.Index(xmlOutput, ">")
		if firstGT == -1 {
			return xmlOutput
		}
		rootTag := xmlOutput[:firstGT+1]
		rest := xmlOutput[firstGT+1:]
		// Remove all xmlns from nested elements
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		rest = xmlnsPattern.ReplaceAllString(rest, "")
		return rootTag + rest
	}

	// Strategy: Find all opening tags and remove xmlns if element type not in map
	// Pattern matches: <element_name attr="val" xmlns="uri" ...>
	tagPattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+)(\s[^>]*?)>`)
	result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
		// Extract element name
		tagMatch := tagPattern.FindStringSubmatch(match)
		if len(tagMatch) < 2 {
			return match
		}
		elementName := tagMatch[1]
		attrs := ""
		if len(tagMatch) >= 3 {
			attrs = tagMatch[2]
		}

		// CRITICAL FIX: Deduplicate xmlns attributes first
		// Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
		// This happens with nested structs having XMLName with different namespaces
		// Remove all duplicate xmlns declarations, keeping only the first one
		dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
		matches := dedupPattern.FindAllString(attrs, -1)
		if len(matches) > 1 {
			// Found duplicates - keep only first xmlns, remove rest
			firstXmlns := matches[0]
			attrs = dedupPattern.ReplaceAllString(attrs, "")
			attrs = " " + firstXmlns + attrs
		}

		// Check if this element type should have xmlns
		expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
		if shouldHaveXmlns {
			// This element should have xmlns - ensure it's present and correct
			if !strings.Contains(attrs, "xmlns=") {
				// Missing xmlns - add it
				return "<" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + ">"
			}
			// Has xmlns - verify it's correct
			if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) {
				// Wrong xmlns - replace it
				xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
			}
			return "<" + elementName + attrs + ">"
		}

		// This element should NOT have xmlns - remove any xmlns attributes
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		attrs = xmlnsPattern.ReplaceAllString(attrs, "")
		return "<" + elementName + attrs + ">"
	})

	return result
}

// DirectivesType represents the XSD type 'DirectivesType'
// XSD complex type (W3C XSD §3.4)
type DirectivesType struct {
	// Definition_true represents XSD element 'definition_true'
	Definition_true DirectiveType `xml:"definition_true"`
	// Definition_false represents XSD element 'definition_false'
	Definition_false DirectiveType `xml:"definition_false"`
	// Definition_unknown represents XSD element 'definition_unknown'
	Definition_unknown DirectiveType `xml:"definition_unknown"`
	// Definition_error represents XSD element 'definition_error'
	Definition_error DirectiveType `xml:"definition_error"`
	// Definition_not_evaluated represents XSD element 'definition_not_evaluated'
	Definition_not_evaluated DirectiveType `xml:"definition_not_evaluated"`
	// Definition_not_applicable represents XSD element 'definition_not_applicable'
	Definition_not_applicable DirectiveType `xml:"definition_not_applicable"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DirectiveType represents the XSD type 'DirectiveType'
// XSD complex type (W3C XSD §3.4)
type DirectiveType struct {
	// Reported represents XSD attribute 'reported'
	// use="required"
	Reported bool `xml:"reported,attr"`
	// Content represents XSD attribute 'content'
	// use="optional"
	Content *ContentEnumeration `xml:"content,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ResultsType represents the XSD type 'ResultsType'
// XSD complex type (W3C XSD §3.4)
type ResultsType struct {
	// System represents XSD element 'system'
	// minOccurs=1, maxOccurs=-1
	System []*SystemType `xml:"system"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DefinitionsType represents the XSD type 'DefinitionsType'
// XSD complex type (W3C XSD §3.4)
type DefinitionsType struct {
	// Definition represents XSD element 'definition'
	// minOccurs=1, maxOccurs=-1
	Definition []*DefinitionType `xml:"definition"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CriteriaType represents the XSD type 'CriteriaType'
// XSD complex type (W3C XSD §3.4)
type CriteriaType struct {
	// Criteria represents XSD element 'criteria'
	Criteria []*CriteriaType `xml:"criteria,omitempty"`
	// Criterion represents XSD element 'criterion'
	Criterion []CriterionType `xml:"criterion,omitempty"`
	// Extend_definition represents XSD element 'extend_definition'
	Extend_definition []ExtendDefinitionType `xml:"extend_definition,omitempty"`
	// Applicability_check represents XSD attribute 'applicability_check'
	// use="optional"
	Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
	// Operator represents XSD attribute 'operator'
	// use="required"
	Operator xmlschemaoval_common_5.OperatorEnumeration `xml:"operator,attr"`
	// Negate represents XSD attribute 'negate'
	// use="optional"
	Negate *bool `xml:"negate,attr,omitempty"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CriterionType represents the XSD type 'CriterionType'
// XSD complex type (W3C XSD §3.4)
type CriterionType struct {
	// Applicability_check represents XSD attribute 'applicability_check'
	// use="optional"
	Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
	// Test_ref represents XSD attribute 'test_ref'
	// use="required"
	Test_ref xmlschemaoval_common_5.TestIDPattern `xml:"test_ref,attr"`
	// Version represents XSD attribute 'version'
	// use="required"
	Version uint64 `xml:"version,attr"`
	// Variable_instance represents XSD attribute 'variable_instance'
	// use="optional"
	Variable_instance *uint64 `xml:"variable_instance,attr,omitempty"`
	// Negate represents XSD attribute 'negate'
	// use="optional"
	Negate *bool `xml:"negate,attr,omitempty"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestsType represents the XSD type 'TestsType'
// XSD complex type (W3C XSD §3.4)
type TestsType struct {
	// Test represents XSD element 'test'
	// minOccurs=1, maxOccurs=-1
	Test []TestType `xml:"test"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestedVariableType represents the XSD type 'TestedVariableType'
// XSD complex type (W3C XSD §3.4)
type TestedVariableTypeWithAttrs struct {
	Value string `xml:",chardata"` // XSD simple content
	// Variable_id represents XSD attribute 'variable_id'
	// use="required"
	Variable_id xmlschemaoval_common_5.VariableIDPattern `xml:"variable_id,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestedVariableType is an alias for TestedVariableTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type TestedVariableType = TestedVariableTypeWithAttrs

// ContentEnumeration represents the XSD type 'ContentEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="thin"
// enumeration="full"
type ContentEnumeration string

// ResultEnumeration represents the XSD type 'ResultEnumeration'
// XSD simple type (W3C XSD §4.1)
// enumeration="true"
// enumeration="false"
// enumeration="unknown"
// enumeration="error"
// enumeration="not evaluated"
// enumeration="not applicable"
type ResultEnumeration string

// DefaultDirectivesType represents the XSD type 'DefaultDirectivesType'
// XSD complex type (W3C XSD §3.4)
type DefaultDirectivesType struct {
	DirectivesType // XSD extension base
	// Include_source_definitions represents XSD attribute 'include_source_definitions'
	// use="optional"
	Include_source_definitions *bool `xml:"include_source_definitions,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ClassDirectivesType represents the XSD type 'ClassDirectivesType'
// XSD complex type (W3C XSD §3.4)
type ClassDirectivesType struct {
	DirectivesType // XSD extension base
	// Class represents XSD attribute 'class'
	// use="required"
	Class xmlschemaoval_common_5.ClassEnumeration `xml:"class,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SystemType represents the XSD type 'SystemType'
// XSD complex type (W3C XSD §3.4)
type SystemType struct {
	// Definitions represents XSD element 'definitions'
	// minOccurs=0, maxOccurs=1
	Definitions *DefinitionsType `xml:"definitions,omitempty"`
	// Tests represents XSD element 'tests'
	// minOccurs=0, maxOccurs=1
	Tests *TestsType `xml:"tests,omitempty"`
	// Oval_system_characteristics represents XSD element 'oval_system_characteristics'
	Oval_system_characteristics xmlschemaoval_system_characteristics_5.Oval_system_characteristicsElement `xml:"oval_system_characteristics"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtendDefinitionType represents the XSD type 'ExtendDefinitionType'
// XSD complex type (W3C XSD §3.4)
type ExtendDefinitionType struct {
	// Applicability_check represents XSD attribute 'applicability_check'
	// use="optional"
	Applicability_check *bool `xml:"applicability_check,attr,omitempty"`
	// Definition_ref represents XSD attribute 'definition_ref'
	// use="required"
	Definition_ref xmlschemaoval_common_5.DefinitionIDPattern `xml:"definition_ref,attr"`
	// Version represents XSD attribute 'version'
	// use="required"
	Version uint64 `xml:"version,attr"`
	// Variable_instance represents XSD attribute 'variable_instance'
	// use="optional"
	Variable_instance *uint64 `xml:"variable_instance,attr,omitempty"`
	// Negate represents XSD attribute 'negate'
	// use="optional"
	Negate *bool `xml:"negate,attr,omitempty"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// Oval_resultsElementType represents the XSD type 'Oval_resultsElementType'
// XSD complex type (W3C XSD §3.4)
type Oval_resultsElementType struct {
	// Generator represents XSD element 'generator'
	Generator dictionary2_0.GeneratorType `xml:"generator"`
	// Directives represents XSD element 'directives'
	Directives DefaultDirectivesType `xml:"directives"`
	// Class_directives represents XSD element 'class_directives'
	// minOccurs=0, maxOccurs=5
	Class_directives []ClassDirectivesType `xml:"class_directives,omitempty"`
	// Oval_definitions represents XSD element 'oval_definitions'
	// minOccurs=0, maxOccurs=1
	Oval_definitions *xmlschemaoval_definitions_5.Oval_definitionsElement `xml:"oval_definitions,omitempty"`
	// Results represents XSD element 'results'
	Results *ResultsType `xml:"results"`
	// Signature represents XSD element 'Signature'
	// minOccurs=0, maxOccurs=1
	Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DefinitionType represents the XSD type 'DefinitionType'
// XSD complex type (W3C XSD §3.4)
type DefinitionType struct {
	// Message represents XSD element 'message'
	// minOccurs=0, maxOccurs=-1
	Message []xmlschemaoval_common_5.MessageTypeWithAttrs `xml:"message,omitempty"`
	// Criteria represents XSD element 'criteria'
	// minOccurs=0, maxOccurs=1
	Criteria *CriteriaType `xml:"criteria,omitempty"`
	// Definition_id represents XSD attribute 'definition_id'
	// use="required"
	Definition_id xmlschemaoval_common_5.DefinitionIDPattern `xml:"definition_id,attr"`
	// Version represents XSD attribute 'version'
	// use="required"
	Version uint64 `xml:"version,attr"`
	// Variable_instance represents XSD attribute 'variable_instance'
	// use="optional"
	Variable_instance *uint64 `xml:"variable_instance,attr,omitempty"`
	// Class represents XSD attribute 'class'
	// use="optional"
	Class *xmlschemaoval_common_5.ClassEnumeration `xml:"class,attr,omitempty"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestType represents the XSD type 'TestType'
// XSD complex type (W3C XSD §3.4)
type TestType struct {
	// Message represents XSD element 'message'
	// minOccurs=0, maxOccurs=-1
	Message []xmlschemaoval_common_5.MessageTypeWithAttrs `xml:"message,omitempty"`
	// Tested_item represents XSD element 'tested_item'
	// minOccurs=0, maxOccurs=-1
	Tested_item []TestedItemType `xml:"tested_item,omitempty"`
	// Tested_variable represents XSD element 'tested_variable'
	// minOccurs=0, maxOccurs=-1
	Tested_variable []TestedVariableTypeWithAttrs `xml:"tested_variable,omitempty"`
	// Test_id represents XSD attribute 'test_id'
	// use="required"
	Test_id xmlschemaoval_common_5.TestIDPattern `xml:"test_id,attr"`
	// Version represents XSD attribute 'version'
	// use="required"
	Version uint64 `xml:"version,attr"`
	// Variable_instance represents XSD attribute 'variable_instance'
	// use="optional"
	Variable_instance *uint64 `xml:"variable_instance,attr,omitempty"`
	// Check_existence represents XSD attribute 'check_existence'
	// use="optional"
	Check_existence *xmlschemaoval_common_5.ExistenceEnumeration `xml:"check_existence,attr,omitempty"`
	// Check represents XSD attribute 'check'
	// use="required"
	Check xmlschemaoval_common_5.CheckEnumeration `xml:"check,attr"`
	// State_operator represents XSD attribute 'state_operator'
	// use="optional"
	State_operator *xmlschemaoval_common_5.OperatorEnumeration `xml:"state_operator,attr,omitempty"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TestedItemType represents the XSD type 'TestedItemType'
// XSD complex type (W3C XSD §3.4)
type TestedItemType struct {
	// Message represents XSD element 'message'
	// minOccurs=0, maxOccurs=-1
	Message []xmlschemaoval_common_5.MessageTypeWithAttrs `xml:"message,omitempty"`
	// Item_id represents XSD attribute 'item_id'
	// use="required"
	Item_id xmlschemaoval_common_5.ItemIDPattern `xml:"item_id,attr"`
	// Result represents XSD attribute 'result'
	// use="required"
	Result ResultEnumeration `xml:"result,attr"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
