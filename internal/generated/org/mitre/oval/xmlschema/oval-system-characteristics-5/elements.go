// Package xmlschemaoval_system_characteristics_5 generated from XSD schema
// Source namespace: http://oval.mitre.org/XMLSchema/oval-system-characteristics-5
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/oval-system-characteristics-schema.xsd
// Generated by forgexml - Do not edit manually

package xmlschemaoval_system_characteristics_5

import (
	"encoding/xml"
	"os"
	"strings"

	xmlschemaoval_common_5 "github.com/aequo-labs/forgexml-scap/internal/generated/org/mitre/oval/xmlschema/oval-common-5"
	pkg_200009xmldsig "github.com/aequo-labs/forgexml-scap/internal/generated/org/w3/2000/09/xmldsig"
)

// Oval_system_characteristicsElement represents the XSD element 'oval_system_characteristics'
// XSD element declaration (W3C XSD ยง3.3)
type Oval_system_characteristicsElement struct {
	XMLName xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-system-characteristics-5 oval_system_characteristics"`
	// Generator represents XSD element 'generator'
	Generator xmlschemaoval_common_5.GeneratorType `xml:"generator"`
	// System_info represents XSD element 'system_info'
	System_info SystemInfoType `xml:"system_info"`
	// Collected_objects represents XSD element 'collected_objects'
	// minOccurs=0, maxOccurs=1
	Collected_objects *CollectedObjectsType `xml:"collected_objects,omitempty"`
	// System_data represents XSD element 'system_data'
	// minOccurs=0, maxOccurs=1
	System_data *SystemDataType `xml:"system_data,omitempty"`
	// Signature represents XSD element 'Signature'
	// minOccurs=0, maxOccurs=1
	Signature *pkg_200009xmldsig.SignatureType `xml:"Signature,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *Oval_system_characteristicsElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias Oval_system_characteristicsElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *Oval_system_characteristicsElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias Oval_system_characteristicsElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *Oval_system_characteristicsElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *Oval_system_characteristicsElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *Oval_system_characteristicsElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *Oval_system_characteristicsElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *Oval_system_characteristicsElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadOval_system_characteristicsFromBytes loads an element from bytes with namespace preservation
func LoadOval_system_characteristicsFromBytes(data []byte) (*Oval_system_characteristicsElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element Oval_system_characteristicsElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadOval_system_characteristicsFromFile loads an element from a file with namespace preservation
func LoadOval_system_characteristicsFromFile(path string) (*Oval_system_characteristicsElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadOval_system_characteristicsFromBytes(data)
}

// ItemElement represents the XSD element 'item'
// XSD element declaration (W3C XSD ยง3.3)
// abstract="true"
type ItemElement struct {
	XMLName  xml.Name `xml:"http://oval.mitre.org/XMLSchema/oval-system-characteristics-5 item"`
	ItemType          // Embedded complex type
	// nsDeclarations stores namespace prefix->URI mappings for perfect round-trip
	nsDeclarations map[string]string `xml:"-"`
	// nsDefaultNamespace stores the default namespace for perfect round-trip
	nsDefaultNamespace string `xml:"-"`
	// elementPrefixes stores element name->prefix mappings for perfect round-trip
	elementPrefixes map[string]string `xml:"-"`
	// elementsWithXmlns tracks which element names had xmlns in original (element_name -> namespace_uri)
	// Used to replicate xmlns placement exactly during marshal for zero xmlns delta
	elementsWithXmlns map[string]string `xml:"-"`
}

// UnmarshalXML implements custom unmarshaling with namespace preservation
func (e *ItemElement) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	// Create alias type to prevent recursion
	type alias ItemElement
	aux := (*alias)(e)

	// Extract namespace declarations from start element
	e.nsDeclarations = make(map[string]string)
	e.elementPrefixes = make(map[string]string)
	var nonXmlnsAttrs []xml.Attr
	for _, attr := range start.Attr {
		if attr.Name.Space == "xmlns" {
			// xmlns:prefix="uri"
			e.nsDeclarations[attr.Name.Local] = attr.Value
			// Build reverse map for element prefix restoration
			e.elementPrefixes[attr.Value] = attr.Name.Local
		} else if attr.Name.Local == "xmlns" && attr.Name.Space == "" {
			// xmlns="uri"
			e.nsDefaultNamespace = attr.Value
		} else {
			// Keep non-xmlns attributes for DecodeElement
			nonXmlnsAttrs = append(nonXmlnsAttrs, attr)
		}
	}

	// Remove xmlns from start.Attr to prevent duplication in UnknownAttrs
	start.Attr = nonXmlnsAttrs

	// Perform standard unmarshal
	return d.DecodeElement(aux, &start)
}

// MarshalXML implements custom marshaling with namespace preservation
func (e *ItemElement) MarshalXML(encoder *xml.Encoder, start xml.StartElement) error {
	// Use the struct's XMLName to ensure correct element name
	start.Name = e.XMLName

	// Restore namespace declarations
	if len(e.nsDeclarations) > 0 {
		// Add namespace declarations to start element
		for prefix, uri := range e.nsDeclarations {
			start.Attr = append(start.Attr, xml.Attr{
				Name:  xml.Name{Space: "xmlns", Local: prefix},
				Value: uri,
			})
		}
	}
	// Restore default namespace declaration if it was present in input
	// This is necessary for perfect fidelity when elements have redundant xmlns
	if e.nsDefaultNamespace != "" {
		start.Attr = append(start.Attr, xml.Attr{
			Name:  xml.Name{Local: "xmlns"},
			Value: e.nsDefaultNamespace,
		})
	}

	// Create alias type to prevent recursion
	type alias ItemElement
	aux := (*alias)(e)

	// Encode using standard marshaler
	return encoder.EncodeElement(aux, start)
}

// MarshalIndentClean marshals with perfect namespace fidelity
// This method: 1) Fixes Go's xmlns corruption, 2) Restores element prefixes
// Preserves legitimate xmlns on nested elements with different default namespaces
func (e *ItemElement) MarshalIndentClean(prefix, indent string) ([]byte, error) {
	data, err := xml.MarshalIndent(e, prefix, indent)
	if err != nil {
		return nil, err
	}

	// Fix Go's namespace corruption:
	// Go's xml.Encoder corrupts xmlns declarations by:
	// 1. Prefixing 'xmlns:' with an underscore: 'xmlns:rc' -> '_xmlns:rc'
	// 2. Adding a bogus 'xmlns:_xmlns="xmlns"' attribute
	output := string(data)

	// Step 1: Fix Go's namespace corruption
	// First, remove the bogus xmlns:_xmlns="xmlns" attribute
	output = strings.ReplaceAll(output, ` xmlns:_xmlns="xmlns"`, "")

	// Then fix all _xmlns: prefixes to xmlns:
	output = strings.ReplaceAll(output, "_xmlns:", "xmlns:")

	// Also remove any remaining xmlns:xmlns="xmlns" that may appear
	output = strings.ReplaceAll(output, ` xmlns:xmlns="xmlns"`, "")

	// Fix corrupted XMLSchema-instance namespace
	// Go sometimes duplicates this as xmlns:_XMLSchema-instance and _XMLSchema-instance:schemaLocation
	output = strings.ReplaceAll(output, ` xmlns:_XMLSchema-instance="http://www.w3.org/2001/XMLSchema-instance"`, "")
	output = strings.ReplaceAll(output, "_XMLSchema-instance:", "xsi:")

	// Step 2: Restore element namespace prefixes using the captured prefix map
	if len(e.elementPrefixes) > 0 {
		output = restoreElementPrefixes(output, e.elementPrefixes)
	}

	// Step 3: Replicate xmlns placement from original XML for zero xmlns delta
	// This adds xmlns to elements that had it in original, removes xmlns from elements that didn't
	if len(e.elementsWithXmlns) > 0 {
		output = replicateXmlnsPlacement(output, e.elementsWithXmlns)
	}

	return []byte(output), nil
}

// ToBytes marshals the element to bytes with namespace preservation
// This is the recommended method for serializing to XML with round-trip fidelity
func (e *ItemElement) ToBytes() ([]byte, error) {
	return e.MarshalIndentClean("", "  ")
}

// SetElementPrefixes allows injecting element prefix mappings from raw XML
// This is typically called after unmarshal with ExtractElementPrefixes(rawXML)
func (e *ItemElement) SetElementPrefixes(prefixes map[string]string) {
	e.elementPrefixes = prefixes
}

// SetElementsWithXmlns allows injecting element->xmlns mappings from raw XML
// This is typically called after unmarshal with ExtractElementsWithXmlns(rawXML)
// for perfect xmlns fidelity (zero xmlns delta)
func (e *ItemElement) SetElementsWithXmlns(elementsWithXmlns map[string]string) {
	e.elementsWithXmlns = elementsWithXmlns
}

// SaveToFile saves the element to a file with namespace preservation
func (e *ItemElement) SaveToFile(path string) error {
	data, err := e.ToBytes()
	if err != nil {
		return err
	}
	return os.WriteFile(path, data, 0644)
}

// LoadItemFromBytes loads an element from bytes with namespace preservation
func LoadItemFromBytes(data []byte) (*ItemElement, error) {
	// Extract element prefixes from raw XML before unmarshaling
	elementPrefixes := ExtractElementPrefixes(data)
	// Extract which elements had xmlns for exact xmlns replication
	elementsWithXmlns := ExtractElementsWithXmlns(data)

	var element ItemElement
	if err := xml.Unmarshal(data, &element); err != nil {
		return nil, err
	}

	// Store extracted element name -> prefix mappings for restoration during marshal
	element.elementPrefixes = elementPrefixes
	// Store element -> xmlns mappings for zero xmlns delta
	element.elementsWithXmlns = elementsWithXmlns

	return &element, nil
}

// LoadItemFromFile loads an element from a file with namespace preservation
func LoadItemFromFile(path string) (*ItemElement, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	return LoadItemFromBytes(data)
}
