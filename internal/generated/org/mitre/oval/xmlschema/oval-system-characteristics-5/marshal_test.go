// Package xmlschemaoval_system_characteristics_5 - Marshal/Unmarshal Tests
// Generated by forgexml - Do not edit manually

package xmlschemaoval_system_characteristics_5

import (
	"encoding/xml"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// normalizeXML removes duplicate xmlns attributes that Go's xml encoder sometimes produces
func normalizeXML(xmlData []byte) string {
	xmlStr := string(xmlData)
	// Remove duplicate xmlns declarations (Go encoder quirk with embedded structs)
	pattern := regexp.MustCompile(`(xmlns="[^"]+")\s+xmlns="[^"]+"`)
	return pattern.ReplaceAllString(xmlStr, "$1")
}

// TestCollectedObjectsType_MarshalUnmarshal tests XML round-trip for CollectedObjectsType
func TestCollectedObjectsType_MarshalUnmarshal(t *testing.T) {
	original := &CollectedObjectsType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded CollectedObjectsType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemAnySimpleType_MarshalUnmarshal tests XML round-trip for EntityItemAnySimpleType
func TestEntityItemAnySimpleType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemAnySimpleType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemAnySimpleType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemBinaryType_MarshalUnmarshal tests XML round-trip for EntityItemBinaryType
func TestEntityItemBinaryType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemBinaryType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemBinaryType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemBoolType_MarshalUnmarshal tests XML round-trip for EntityItemBoolType
func TestEntityItemBoolType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemBoolType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemBoolType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemComplexBaseType_MarshalUnmarshal tests XML round-trip for EntityItemComplexBaseType
func TestEntityItemComplexBaseType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemComplexBaseType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemComplexBaseType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemDebianEVRStringType_MarshalUnmarshal tests XML round-trip for EntityItemDebianEVRStringType
func TestEntityItemDebianEVRStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemDebianEVRStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemDebianEVRStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemEVRStringType_MarshalUnmarshal tests XML round-trip for EntityItemEVRStringType
func TestEntityItemEVRStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemEVRStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemEVRStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemFieldType_MarshalUnmarshal tests XML round-trip for EntityItemFieldType
func TestEntityItemFieldType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemFieldType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemFieldType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemFilesetRevisionType_MarshalUnmarshal tests XML round-trip for EntityItemFilesetRevisionType
func TestEntityItemFilesetRevisionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemFilesetRevisionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemFilesetRevisionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemFloatType_MarshalUnmarshal tests XML round-trip for EntityItemFloatType
func TestEntityItemFloatType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemFloatType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemFloatType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemIOSVersionType_MarshalUnmarshal tests XML round-trip for EntityItemIOSVersionType
func TestEntityItemIOSVersionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemIOSVersionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemIOSVersionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemIPAddressStringType_MarshalUnmarshal tests XML round-trip for EntityItemIPAddressStringType
func TestEntityItemIPAddressStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemIPAddressStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemIPAddressStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemIPAddressType_MarshalUnmarshal tests XML round-trip for EntityItemIPAddressType
func TestEntityItemIPAddressType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemIPAddressType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemIPAddressType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemIntType_MarshalUnmarshal tests XML round-trip for EntityItemIntType
func TestEntityItemIntType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemIntType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemIntType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemRecordType_MarshalUnmarshal tests XML round-trip for EntityItemRecordType
func TestEntityItemRecordType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemRecordType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemRecordType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemSimpleBaseType_MarshalUnmarshal tests XML round-trip for EntityItemSimpleBaseType
func TestEntityItemSimpleBaseType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemSimpleBaseType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemSimpleBaseType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemStringType_MarshalUnmarshal tests XML round-trip for EntityItemStringType
func TestEntityItemStringType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemStringType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemStringType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestEntityItemVersionType_MarshalUnmarshal tests XML round-trip for EntityItemVersionType
func TestEntityItemVersionType_MarshalUnmarshal(t *testing.T) {
	original := &EntityItemVersionType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded EntityItemVersionType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterfaceType_MarshalUnmarshal tests XML round-trip for InterfaceType
func TestInterfaceType_MarshalUnmarshal(t *testing.T) {
	original := &InterfaceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded InterfaceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestInterfacesType_MarshalUnmarshal tests XML round-trip for InterfacesType
func TestInterfacesType_MarshalUnmarshal(t *testing.T) {
	original := &InterfacesType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded InterfacesType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestItemElement_MarshalUnmarshal tests XML round-trip for ItemElement
func TestItemElement_MarshalUnmarshal(t *testing.T) {
	original := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ItemElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestItemElement_MarshalIndentClean tests the MarshalIndentClean method
func TestItemElement_MarshalIndentClean(t *testing.T) {
	elem := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestItemElement_ToBytes tests the ToBytes method
func TestItemElement_ToBytes(t *testing.T) {
	elem := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestItemElement_SetElementPrefixes tests the SetElementPrefixes method
func TestItemElement_SetElementPrefixes(t *testing.T) {
	elem := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestItemElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestItemElement_SetElementsWithXmlns(t *testing.T) {
	elem := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestItemElement_SaveAndLoad tests SaveToFile and LoadItemFromFile
func TestItemElement_SaveAndLoad(t *testing.T) {
	elem := &ItemElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "item"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadItemFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestItemElement_LoadFromBytes tests the LoadItemFromBytes function
func TestItemElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<item xmlns="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5"></item>`)

	loaded, err := LoadItemFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestItemType_MarshalUnmarshal tests XML round-trip for ItemType
func TestItemType_MarshalUnmarshal(t *testing.T) {
	original := &ItemType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ItemType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestObjectType_MarshalUnmarshal tests XML round-trip for ObjectType
func TestObjectType_MarshalUnmarshal(t *testing.T) {
	original := &ObjectType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ObjectType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestOval_system_characteristicsElement_MarshalUnmarshal tests XML round-trip for Oval_system_characteristicsElement
func TestOval_system_characteristicsElement_MarshalUnmarshal(t *testing.T) {
	original := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Oval_system_characteristicsElement
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestOval_system_characteristicsElement_MarshalIndentClean tests the MarshalIndentClean method
func TestOval_system_characteristicsElement_MarshalIndentClean(t *testing.T) {
	elem := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	data, err := elem.MarshalIndentClean("", "  ")
	if err != nil {
		t.Fatalf("MarshalIndentClean failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("MarshalIndentClean returned empty data")
	}
}

// TestOval_system_characteristicsElement_ToBytes tests the ToBytes method
func TestOval_system_characteristicsElement_ToBytes(t *testing.T) {
	elem := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	data, err := elem.ToBytes()
	if err != nil {
		t.Fatalf("ToBytes failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("ToBytes returned empty data")
	}
}

// TestOval_system_characteristicsElement_SetElementPrefixes tests the SetElementPrefixes method
func TestOval_system_characteristicsElement_SetElementPrefixes(t *testing.T) {
	elem := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	prefixes := map[string]string{"http://example.com": "ex"}
	elem.SetElementPrefixes(prefixes)
	// Method should not panic - that's the test
}

// TestOval_system_characteristicsElement_SetElementsWithXmlns tests the SetElementsWithXmlns method
func TestOval_system_characteristicsElement_SetElementsWithXmlns(t *testing.T) {
	elem := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	elemXmlns := map[string]string{"child": "http://example.com"}
	elem.SetElementsWithXmlns(elemXmlns)
	// Method should not panic - that's the test
}

// TestOval_system_characteristicsElement_SaveAndLoad tests SaveToFile and LoadOval_system_characteristicsFromFile
func TestOval_system_characteristicsElement_SaveAndLoad(t *testing.T) {
	elem := &Oval_system_characteristicsElement{
		XMLName: xml.Name{Space: "http://oval.mitre.org/XMLSchema/oval-system-characteristics-5", Local: "oval_system_characteristics"},
	}

	// Create temp file
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.xml")

	// Save to file
	if err := elem.SaveToFile(tmpFile); err != nil {
		t.Fatalf("SaveToFile failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(tmpFile); os.IsNotExist(err) {
		t.Fatal("SaveToFile did not create file")
	}

	// Load from file
	loaded, err := LoadOval_system_characteristicsFromFile(tmpFile)
	if err != nil {
		t.Fatalf("LoadFromFile failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromFile returned nil")
	}
}

// TestOval_system_characteristicsElement_LoadFromBytes tests the LoadOval_system_characteristicsFromBytes function
func TestOval_system_characteristicsElement_LoadFromBytes(t *testing.T) {
	xmlData := []byte(`<oval_system_characteristics xmlns="http://oval.mitre.org/XMLSchema/oval-system-characteristics-5"></oval_system_characteristics>`)

	loaded, err := LoadOval_system_characteristicsFromBytes(xmlData)
	if err != nil {
		t.Fatalf("LoadFromBytes failed: %v", err)
	}
	if loaded == nil {
		t.Error("LoadFromBytes returned nil")
	}
}

// TestOval_system_characteristicsElementType_MarshalUnmarshal tests XML round-trip for Oval_system_characteristicsElementType
func TestOval_system_characteristicsElementType_MarshalUnmarshal(t *testing.T) {
	original := &Oval_system_characteristicsElementType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded Oval_system_characteristicsElementType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestReferenceType_MarshalUnmarshal tests XML round-trip for ReferenceType
func TestReferenceType_MarshalUnmarshal(t *testing.T) {
	original := &ReferenceType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded ReferenceType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemDataType_MarshalUnmarshal tests XML round-trip for SystemDataType
func TestSystemDataType_MarshalUnmarshal(t *testing.T) {
	original := &SystemDataType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SystemDataType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestSystemInfoType_MarshalUnmarshal tests XML round-trip for SystemInfoType
func TestSystemInfoType_MarshalUnmarshal(t *testing.T) {
	original := &SystemInfoType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded SystemInfoType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestVariableValueType_MarshalUnmarshal tests XML round-trip for VariableValueType
func TestVariableValueType_MarshalUnmarshal(t *testing.T) {
	original := &VariableValueType{}

	// Marshal to XML
	xmlData, err := xml.MarshalIndent(original, "", "  ")
	if err != nil {
		// Skip test if type has required element fields with XMLName that can't be marshaled empty
		if strings.Contains(err.Error(), "missing name") {
			t.Skipf("Skipping: type has required element fields that need initialization: %v", err)
		}
		t.Fatalf("Marshal failed: %v", err)
	}

	// Unmarshal back
	var decoded VariableValueType
	if err := xml.Unmarshal(xmlData, &decoded); err != nil {
		t.Fatalf("Unmarshal failed: %v", err)
	}

	// Re-marshal to compare
	xmlData2, err := xml.MarshalIndent(&decoded, "", "  ")
	if err != nil {
		t.Fatalf("Re-marshal failed: %v", err)
	}

	// Compare XML outputs (normalize to handle Go encoder quirks)
	normalized1 := normalizeXML(xmlData)
	normalized2 := normalizeXML(xmlData2)
	if normalized1 != normalized2 {
		t.Errorf("Round-trip XML mismatch:\nOriginal:\n%s\n\nRe-marshaled:\n%s", normalized1, normalized2)
	}
}

// TestExtractElementPrefixes tests the ExtractElementPrefixes helper function
func TestExtractElementPrefixes(t *testing.T) {
	// Use opening tag with space or > after element name (regex requires [\s>])
	xmlData := []byte(`<root xmlns:ex="http://example.com"><ex:child >text</ex:child></root>`)
	prefixes := ExtractElementPrefixes(xmlData)
	if prefixes == nil {
		t.Error("ExtractElementPrefixes returned nil")
	}
	if len(prefixes) == 0 {
		t.Error("ExtractElementPrefixes returned empty map, expected 'child' -> 'ex'")
	}
	if prefixes["child"] != "ex" {
		t.Errorf("ExtractElementPrefixes: expected prefixes['child']='ex', got '%s'", prefixes["child"])
	}
}

// TestExtractElementsWithXmlns tests the ExtractElementsWithXmlns helper function
func TestExtractElementsWithXmlns(t *testing.T) {
	xmlData := []byte(`<root xmlns="http://example.com"><child xmlns="http://other.com"/></root>`)
	elemXmlns := ExtractElementsWithXmlns(xmlData)
	if elemXmlns == nil {
		t.Error("ExtractElementsWithXmlns returned nil")
	}
	// Should find xmlns on both root and child elements
	if len(elemXmlns) < 1 {
		t.Errorf("ExtractElementsWithXmlns: expected at least 1 element with xmlns, got %d", len(elemXmlns))
	}
}

// TestRestoreElementPrefixes tests the restoreElementPrefixes helper function
func TestRestoreElementPrefixes(t *testing.T) {
	// Input: unprefixed XML with default xmlns
	input := `<root><child xmlns="http://example.com">text</child></root>`
	prefixes := map[string]string{"child": "ex"}
	result := restoreElementPrefixes(input, prefixes)
	// Should add prefix to child element
	if result == "" {
		t.Error("restoreElementPrefixes returned empty string")
	}
	// Result should contain prefixed element
	if !regexp.MustCompile(`<ex:child`).MatchString(result) {
		t.Errorf("restoreElementPrefixes: expected '<ex:child' in result, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement tests the replicateXmlnsPlacement helper function
func TestReplicateXmlnsPlacement(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root><child xmlns="http://example.com">text</child></root>`
	elementsWithXmlns := map[string]string{"child": "http://example.com"}
	result := replicateXmlnsPlacement(input, elementsWithXmlns)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Result should preserve xmlns on child
	if !regexp.MustCompile(`xmlns="http://example.com"`).MatchString(result) {
		t.Errorf("replicateXmlnsPlacement: expected xmlns preserved, got: %s", result)
	}
}

// TestReplicateXmlnsPlacement_EmptyMap tests xmlns removal when no tracking
func TestReplicateXmlnsPlacement_EmptyMap(t *testing.T) {
	// Input: XML with xmlns on nested element
	input := `<root xmlns="http://root.com"><child xmlns="http://example.com">text</child></root>`
	emptyMap := map[string]string{}
	result := replicateXmlnsPlacement(input, emptyMap)
	if result == "" {
		t.Error("replicateXmlnsPlacement returned empty string")
	}
	// Root xmlns should be preserved, nested xmlns should be removed
	_ = result // Result validation - function should not panic
}
