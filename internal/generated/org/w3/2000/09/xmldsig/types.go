// Package pkg_200009xmldsig generated from XSD schema
// Source namespace: http://www.w3.org/2000/09/xmldsig#
// Source XSD file: /home/mmcnew/repos/forgexml-scap/schemas/oval/5.11.2/xmldsig-core-schema.xsd
// Generated by forgexml - Do not edit manually

package pkg_200009xmldsig

import (
	"encoding/xml"
	"regexp"
	"strings"
)

// GenericElement represents unknown/extension elements not defined in XSD
type GenericElement struct {
	XMLName xml.Name   `xml:""`
	Content string     `xml:",innerxml"`
	Attrs   []xml.Attr `xml:",any,attr,omitempty"`
}

// ExtractElementsWithXmlns parses raw XML and tracks which element names had xmlns declarations
// Returns map of element_name -> xmlns_uri for exact xmlns replication during marshal
// This achieves zero xmlns delta by tracking WHERE xmlns appeared in original XML
func ExtractElementsWithXmlns(xmlData []byte) map[string]string {
	elementsWithXmlns := make(map[string]string)
	xmlStr := string(xmlData)

	// Pattern to find elements with xmlns: <element_name ...xmlns="uri"...
	// Captures both prefixed and unprefixed element names
	pattern := regexp.MustCompile(`<(?:([a-zA-Z0-9_-]+):)?([a-zA-Z0-9_-]+)\s[^>]*?xmlns="([^"]+)"`)
	matches := pattern.FindAllStringSubmatch(xmlStr, -1)

	for _, match := range matches {
		if len(match) >= 4 {
			// match[1] = prefix (may be empty)
			// match[2] = element name
			// match[3] = xmlns URI
			elementName := match[2]
			xmlnsURI := match[3]
			elementsWithXmlns[elementName] = xmlnsURI
		}
	}

	return elementsWithXmlns
}

// ExtractElementPrefixes parses raw XML to build element name -> prefix mappings
func ExtractElementPrefixes(xmlData []byte) map[string]string {
	elementPrefixes := make(map[string]string)

	// Use regex to find all opening tags with prefixes: <prefix:element
	pattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+):([a-zA-Z0-9_-]+)[\s>]`)
	matches := pattern.FindAllStringSubmatch(string(xmlData), -1)

	for _, match := range matches {
		if len(match) >= 3 {
			prefix := match[1]
			elementName := match[2]
			elementPrefixes[elementName] = prefix
		}
	}

	return elementPrefixes
}

// restoreElementPrefixes restores namespace prefixes on element names
// and removes redundant default xmlns from prefixed elements
func restoreElementPrefixes(xmlOutput string, elementPrefixes map[string]string) string {
	// For each element name -> prefix mapping
	for elementName, prefix := range elementPrefixes {
		// Replace opening tags: <elementName with <prefix:elementName
		// and remove default xmlns="..." since the prefix declares the namespace
		pattern := regexp.MustCompile(`<` + elementName + `(\s[^>]*)?>`)
		xmlOutput = pattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
			// Add prefix to element name
			result := "<" + prefix + ":" + elementName
			// Extract attributes (everything between element name and >)
			if len(match) > len("<"+elementName+">") {
				attrs := match[len("<"+elementName) : len(match)-1]
				// Remove default xmlns="..." attribute
				xmlnsPattern := regexp.MustCompile(` xmlns="[^"]*"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, "")
				result += attrs
			}
			result += ">"
			return result
		})

		// Replace closing tags: </elementName> with </prefix:elementName>
		xmlOutput = strings.ReplaceAll(xmlOutput, "</"+elementName+">", "</"+prefix+":"+elementName+">")
	}

	return xmlOutput
}

// replicateXmlnsPlacement removes xmlns from elements that didn't have it, keeps xmlns on elements that did
// Strategy: Parse all opening tags, remove xmlns unless element type is in elementsWithXmlns map
// This achieves zero xmlns delta by matching original xmlns placement exactly
func replicateXmlnsPlacement(xmlOutput string, elementsWithXmlns map[string]string) string {
	if len(elementsWithXmlns) == 0 {
		// No xmlns tracking - remove all nested xmlns to avoid inflation
		// Keep only root element xmlns
		firstGT := strings.Index(xmlOutput, ">")
		if firstGT == -1 {
			return xmlOutput
		}
		rootTag := xmlOutput[:firstGT+1]
		rest := xmlOutput[firstGT+1:]
		// Remove all xmlns from nested elements
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		rest = xmlnsPattern.ReplaceAllString(rest, "")
		return rootTag + rest
	}

	// Strategy: Find all opening tags and remove xmlns if element type not in map
	// Pattern matches: <element_name attr="val" xmlns="uri" ...>
	tagPattern := regexp.MustCompile(`<([a-zA-Z0-9_-]+)(\s[^>]*?)>`)
	result := tagPattern.ReplaceAllStringFunc(xmlOutput, func(match string) string {
		// Extract element name
		tagMatch := tagPattern.FindStringSubmatch(match)
		if len(tagMatch) < 2 {
			return match
		}
		elementName := tagMatch[1]
		attrs := ""
		if len(tagMatch) >= 3 {
			attrs = tagMatch[2]
		}

		// CRITICAL FIX: Deduplicate xmlns attributes first
		// Go's xml.MarshalIndent sometimes produces duplicate xmlns (e.g., xmlns="..." xmlns="...")
		// This happens with nested structs having XMLName with different namespaces
		// Remove all duplicate xmlns declarations, keeping only the first one
		dedupPattern := regexp.MustCompile(`(xmlns="[^"]+")`)
		matches := dedupPattern.FindAllString(attrs, -1)
		if len(matches) > 1 {
			// Found duplicates - keep only first xmlns, remove rest
			firstXmlns := matches[0]
			attrs = dedupPattern.ReplaceAllString(attrs, "")
			attrs = " " + firstXmlns + attrs
		}

		// Check if this element type should have xmlns
		expectedXmlns, shouldHaveXmlns := elementsWithXmlns[elementName]
		if shouldHaveXmlns {
			// This element should have xmlns - ensure it's present and correct
			if !strings.Contains(attrs, "xmlns=") {
				// Missing xmlns - add it
				return "<" + elementName + ` xmlns="` + expectedXmlns + `"` + attrs + ">"
			}
			// Has xmlns - verify it's correct
			if !strings.Contains(attrs, `xmlns="`+expectedXmlns+`"`) {
				// Wrong xmlns - replace it
				xmlnsPattern := regexp.MustCompile(`xmlns="[^"]+"`)
				attrs = xmlnsPattern.ReplaceAllString(attrs, `xmlns="`+expectedXmlns+`"`)
			}
			return "<" + elementName + attrs + ">"
		}

		// This element should NOT have xmlns - remove any xmlns attributes
		xmlnsPattern := regexp.MustCompile(` xmlns(?::[a-zA-Z0-9_-]+)?="[^"]+"`)
		attrs = xmlnsPattern.ReplaceAllString(attrs, "")
		return "<" + elementName + attrs + ">"
	})

	return result
}

// KeyValueType represents the XSD type 'KeyValueType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type KeyValueType struct {
	// DSAKeyValue represents XSD element 'DSAKeyValue'
	DSAKeyValue *DSAKeyValueType `xml:"DSAKeyValue,omitempty"`
	// RSAKeyValue represents XSD element 'RSAKeyValue'
	RSAKeyValue *RSAKeyValueType `xml:"RSAKeyValue,omitempty"`
	Value       string           `xml:",chardata"` // XSD mixed content
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RetrievalMethodType represents the XSD type 'RetrievalMethodType'
// XSD complex type (W3C XSD §3.4)
type RetrievalMethodType struct {
	// Transforms represents XSD element 'Transforms'
	// minOccurs=0, maxOccurs=1
	Transforms *TransformsType `xml:"Transforms,omitempty"`
	// URI represents XSD attribute 'URI'
	// use="optional"
	URI *string `xml:"URI,attr,omitempty"`
	// Type represents XSD attribute 'Type'
	// use="optional"
	Type *string `xml:"Type,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SPKIDataType represents the XSD type 'SPKIDataType'
// XSD complex type (W3C XSD §3.4)
type SPKIDataType struct {
	// SPKISexp represents XSD element 'SPKISexp'
	SPKISexp [][]byte `xml:"SPKISexp"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ManifestType represents the XSD type 'ManifestType'
// XSD complex type (W3C XSD §3.4)
type ManifestType struct {
	// Reference represents XSD element 'Reference'
	// minOccurs=1, maxOccurs=-1
	Reference []ReferenceType `xml:"Reference"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// HMACOutputLengthType represents the XSD type 'HMACOutputLengthType'
// XSD simple type (W3C XSD §4.1)
type HMACOutputLengthType int64

// SignatureValueType represents the XSD type 'SignatureValueType'
// XSD complex type (W3C XSD §3.4)
type SignatureValueTypeWithAttrs struct {
	Value []byte `xml:",chardata"` // XSD simple content
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureValueType is an alias for SignatureValueTypeWithAttrs (maintains compatibility after rename to avoid conflicts)
type SignatureValueType = SignatureValueTypeWithAttrs

// SignedInfoType represents the XSD type 'SignedInfoType'
// XSD complex type (W3C XSD §3.4)
type SignedInfoType struct {
	// CanonicalizationMethod represents XSD element 'CanonicalizationMethod'
	CanonicalizationMethod CanonicalizationMethodType `xml:"CanonicalizationMethod"`
	// SignatureMethod represents XSD element 'SignatureMethod'
	SignatureMethod SignatureMethodType `xml:"SignatureMethod"`
	// Reference represents XSD element 'Reference'
	// minOccurs=1, maxOccurs=-1
	Reference []ReferenceType `xml:"Reference"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureMethodType represents the XSD type 'SignatureMethodType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type SignatureMethodType struct {
	// HMACOutputLength represents XSD element 'HMACOutputLength'
	// minOccurs=0, maxOccurs=1
	HMACOutputLength *HMACOutputLengthType `xml:"HMACOutputLength,omitempty"`
	// Algorithm represents XSD attribute 'Algorithm'
	// use="required"
	Algorithm string `xml:"Algorithm,attr"`
	Value     string `xml:",chardata"` // XSD mixed content
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TransformsType represents the XSD type 'TransformsType'
// XSD complex type (W3C XSD §3.4)
type TransformsType struct {
	// Transform represents XSD element 'Transform'
	// minOccurs=1, maxOccurs=-1
	Transform []TransformType `xml:"Transform"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// X509DataType represents the XSD type 'X509DataType'
// XSD complex type (W3C XSD §3.4)
type X509DataType struct {
	// X509IssuerSerial represents XSD element 'X509IssuerSerial'
	X509IssuerSerial *X509IssuerSerialType `xml:"X509IssuerSerial,omitempty"`
	// X509SKI represents XSD element 'X509SKI'
	X509SKI []byte `xml:"X509SKI,omitempty"`
	// X509SubjectName represents XSD element 'X509SubjectName'
	X509SubjectName *string `xml:"X509SubjectName,omitempty"`
	// X509Certificate represents XSD element 'X509Certificate'
	X509Certificate []byte `xml:"X509Certificate,omitempty"`
	// X509CRL represents XSD element 'X509CRL'
	X509CRL []byte `xml:"X509CRL,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// X509IssuerSerialType represents the XSD type 'X509IssuerSerialType'
// XSD complex type (W3C XSD §3.4)
type X509IssuerSerialType struct {
	// X509IssuerName represents XSD element 'X509IssuerName'
	X509IssuerName string `xml:"X509IssuerName"`
	// X509SerialNumber represents XSD element 'X509SerialNumber'
	X509SerialNumber int64 `xml:"X509SerialNumber"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ObjectType represents the XSD type 'ObjectType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type ObjectType struct {
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// MimeType represents XSD attribute 'MimeType'
	// use="optional"
	MimeType *string `xml:"MimeType,attr,omitempty"`
	// Encoding represents XSD attribute 'Encoding'
	// use="optional"
	Encoding *string `xml:"Encoding,attr,omitempty"`
	InnerXML string  `xml:",innerxml"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// PGPDataType represents the XSD type 'PGPDataType'
// XSD complex type (W3C XSD §3.4)
type PGPDataType struct {
	// PGPKeyID represents XSD element 'PGPKeyID'
	PGPKeyID []byte `xml:"PGPKeyID"`
	// PGPKeyPacket represents XSD element 'PGPKeyPacket'
	// minOccurs=0, maxOccurs=1
	PGPKeyPacket []byte `xml:"PGPKeyPacket,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DSAKeyValueType represents the XSD type 'DSAKeyValueType'
// XSD complex type (W3C XSD §3.4)
type DSAKeyValueType struct {
	// G represents XSD element 'G'
	// minOccurs=0, maxOccurs=1
	G *CryptoBinary `xml:"G,omitempty"`
	// Y represents XSD element 'Y'
	Y CryptoBinary `xml:"Y"`
	// J represents XSD element 'J'
	// minOccurs=0, maxOccurs=1
	J *CryptoBinary `xml:"J,omitempty"`
	// P represents XSD element 'P'
	P CryptoBinary `xml:"P"`
	// Q represents XSD element 'Q'
	Q CryptoBinary `xml:"Q"`
	// Seed represents XSD element 'Seed'
	Seed CryptoBinary `xml:"Seed"`
	// PgenCounter represents XSD element 'PgenCounter'
	PgenCounter CryptoBinary `xml:"PgenCounter"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// RSAKeyValueType represents the XSD type 'RSAKeyValueType'
// XSD complex type (W3C XSD §3.4)
type RSAKeyValueType struct {
	// Modulus represents XSD element 'Modulus'
	Modulus CryptoBinary `xml:"Modulus"`
	// Exponent represents XSD element 'Exponent'
	Exponent CryptoBinary `xml:"Exponent"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// DigestMethodType represents the XSD type 'DigestMethodType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type DigestMethodType struct {
	// Algorithm represents XSD attribute 'Algorithm'
	// use="required"
	Algorithm string `xml:"Algorithm,attr"`
	InnerXML  string `xml:",innerxml"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// CryptoBinary represents the XSD type 'CryptoBinary'
// XSD simple type (W3C XSD §4.1)
type CryptoBinary []byte

// DigestValueType represents the XSD type 'DigestValueType'
// XSD simple type (W3C XSD §4.1)
type DigestValueType []byte

// CanonicalizationMethodType represents the XSD type 'CanonicalizationMethodType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type CanonicalizationMethodType struct {
	// Algorithm represents XSD attribute 'Algorithm'
	// use="required"
	Algorithm string `xml:"Algorithm,attr"`
	InnerXML  string `xml:",innerxml"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignaturePropertiesType represents the XSD type 'SignaturePropertiesType'
// XSD complex type (W3C XSD §3.4)
type SignaturePropertiesType struct {
	// SignatureProperty represents XSD element 'SignatureProperty'
	// minOccurs=1, maxOccurs=-1
	SignatureProperty []SignaturePropertyType `xml:"SignatureProperty"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignaturePropertyType represents the XSD type 'SignaturePropertyType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type SignaturePropertyType struct {
	// Target represents XSD attribute 'Target'
	// use="required"
	Target string `xml:"Target,attr"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id       *string `xml:"Id,attr,omitempty"`
	InnerXML string  `xml:",innerxml"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// SignatureType represents the XSD type 'SignatureType'
// XSD complex type (W3C XSD §3.4)
type SignatureType struct {
	// SignedInfo represents XSD element 'SignedInfo'
	SignedInfo SignedInfoType `xml:"SignedInfo"`
	// SignatureValue represents XSD element 'SignatureValue'
	SignatureValue SignatureValueTypeWithAttrs `xml:"SignatureValue"`
	// KeyInfo represents XSD element 'KeyInfo'
	// minOccurs=0, maxOccurs=1
	KeyInfo *KeyInfoType `xml:"KeyInfo,omitempty"`
	// Object represents XSD element 'Object'
	// minOccurs=0, maxOccurs=-1
	Object []ObjectType `xml:"Object,omitempty"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// ReferenceType represents the XSD type 'ReferenceType'
// XSD complex type (W3C XSD §3.4)
type ReferenceType struct {
	// Transforms represents XSD element 'Transforms'
	// minOccurs=0, maxOccurs=1
	Transforms *TransformsType `xml:"Transforms,omitempty"`
	// DigestMethod represents XSD element 'DigestMethod'
	DigestMethod DigestMethodType `xml:"DigestMethod"`
	// DigestValue represents XSD element 'DigestValue'
	DigestValue DigestValueType `xml:"DigestValue"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id *string `xml:"Id,attr,omitempty"`
	// URI represents XSD attribute 'URI'
	// use="optional"
	URI *string `xml:"URI,attr,omitempty"`
	// Type represents XSD attribute 'Type'
	// use="optional"
	Type *string `xml:"Type,attr,omitempty"`
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// TransformType represents the XSD type 'TransformType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type TransformType struct {
	// XPath represents XSD element 'XPath'
	XPath []string `xml:"XPath,omitempty"`
	// Algorithm represents XSD attribute 'Algorithm'
	// use="required"
	Algorithm string `xml:"Algorithm,attr"`
	Value     string `xml:",chardata"` // XSD mixed content
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}

// KeyInfoType represents the XSD type 'KeyInfoType'
// XSD complex type (W3C XSD §3.4)
// mixed="true"
type KeyInfoType struct {
	// KeyName represents XSD element 'KeyName'
	KeyName []string `xml:"KeyName,omitempty"`
	// KeyValue represents XSD element 'KeyValue'
	KeyValue []KeyValueType `xml:"KeyValue,omitempty"`
	// RetrievalMethod represents XSD element 'RetrievalMethod'
	RetrievalMethod []RetrievalMethodType `xml:"RetrievalMethod,omitempty"`
	// X509Data represents XSD element 'X509Data'
	X509Data []X509DataType `xml:"X509Data,omitempty"`
	// PGPData represents XSD element 'PGPData'
	PGPData []PGPDataType `xml:"PGPData,omitempty"`
	// SPKIData represents XSD element 'SPKIData'
	SPKIData []SPKIDataType `xml:"SPKIData,omitempty"`
	// MgmtData represents XSD element 'MgmtData'
	MgmtData []string `xml:"MgmtData,omitempty"`
	// Id represents XSD attribute 'Id'
	// use="optional"
	Id    *string `xml:"Id,attr,omitempty"`
	Value string  `xml:",chardata"` // XSD mixed content
	// UnknownElements captures any elements not defined in XSD
	UnknownElements []GenericElement `xml:",any,omitempty"`
	// UnknownAttrs captures any attributes not defined in XSD
	UnknownAttrs []xml.Attr `xml:",any,attr,omitempty"`
}
